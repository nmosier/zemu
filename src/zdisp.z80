;; zdisp.z80 -- display routines

#include "zdisp.inc"

;; sfont_width -- get width of small font character
;; INPUTS:
;;  a = character
;; OUTPUTS:
;;  c = width of character
;; DESTROYS: (none)
;; ERRORS: no.
sfont_width:
   push hl
   push de
   ld hl,SFONT_TAB_ADDR
   ld de,SFONT_TAB_ENTLEN
   ld d,a
   mlt de
   add hl,de
   ld c,(hl)
   pop de
   pop hl
   ret


;; sys_clrcurrow -- clear cursor row
;; INPUTS:
;;  a = cursor row (0 - 10?)
;; OUTPUTS: (none)
;; DESTROYS: a, b, de
;; ERRORS: no.
sys_clrcurrow:
   rlca
   rlca
   rlca ; a *= 8
   add a,$80
   jp _ClearRow



;; zdisp_rowaddr -- address of row in VRAM
;; INPUTS:
;;  a = row number
;; OUTPUTS:
;;  hl = row address
;; DESTROYS: de
;; ERRORS: no.
zdisp_rowaddr:
   ld hl,0
   ld l,lcdWidth/2  ; otherwise wouldn't fit in 8 bits
   ld h,a
   mlt hl
   add hl,hl
   add hl,hl
   ld de,vRam
   add hl,de
   ret


;; zdisp_pixaddr -- address of pixel in VRAM
;; INPUTS:
;;  a = row number
;;  hl = column number
;; OUTPUTS:
;;  hl = pixel address
;; DESTROYS: de
;; ERRORS: no.
zdisp_pixaddr:
   push hl
   call zdisp_rowaddr
   pop de
   add hl,de
   add hl,de ; x2 because there are 2 bytes per pixel
   ret

;; zdisp_fillrect -- fill rectangle
;; INPUTS:
;;  hl = fill value
;;  ix = pointer to zrect
;; OUTPUTS:
;;  ix = pointer to zrect
;; DESTROYS: (all)
;; ERRORS: no.
zdisp_fillrect:
   ld (fillRectColor),hl
   ld hl,(ix+ZRECT.ORGCOL)
   ld de,(ix+ZRECT.WIDTH)
   add hl,de
   ex de,hl
   dec de
   ld hl,(ix+ZRECT.ORGCOL)
   ; cols set
   ld a,(ix+ZRECT.ORGROW)
   ld b,a
   add a,(ix+ZRECT.HEIGHT)
   dec a
   ld c,a
   push ix
   call _FillRect
   pop ix
   ret

;; zdisp_init -- do basic initialization of LCD
;; INPUTS: (none)
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: a
zdisp_init:
;   ld a,$2D
;   ld (mpLcdRange+lcdCtrl),a
   ret


;; zdisp_scrollrect_up -- shift rectangle upwards in VRAM
;; INPUTS:
;;  ix = rectangle
;;  a = upward shift (in pixels)
;; OUTPUTS: ???
;; ERRORS: no.
zdisp_scrollrect_up:
   call zdisp_scrollrect_up.copy
   call zdisp_scrollrect_up.clear
   ret

;; zdisp_scrollrect_up.copy -- scroll up by copying contents of VRAM
;; INPUTS:
;;  ix = rectangle
;;  a = upward shift
;; OUTPUTS:
;;  ix = rectangle
;;  a = upward shift
;; ERRORS: no.
;; DESTROYS: ???
zdisp_scrollrect_up.copy:
   push af
   ld b,(ix+ZRECT.HEIGHT)
   ld c,a
   sub a,b
   jr nc,zdisp_scrollrect_up.copy.done  ; nothing to copy
   neg
   ld b,a
   ;; b stores number of rows to copy (b > 0)
   push bc
   ;; compute src and dst addresses
   ;;  compute dst address
   ld a,(ix+ZRECT.ORGROW)
   ld hl,(ix+ZRECT.ORGCOL)
   call zdisp_pixaddr
   push hl
   ;;  compute src address
   add a,c  ;  add upward shift
   ld hl,(ix+ZRECT.ORGCOL)
   call zdisp_pixaddr
   push hl
   jr zdisp_scrollrect_up.copy.entry
zdisp_scrollrect_up.copy.loop:
   push bc
   ld bc,(ix+ZRECT.WIDTH)
   sla c
   rl b
   or a,a
   sbc hl,bc
   ex de,hl
   sbc hl,bc
   ld bc,DISP_WIDTH*PIXEL_SIZE
   add hl,bc
   ex de,hl
   add hl,bc
   push de
   push hl
zdisp_scrollrect_up.copy.entry:
   pop hl   ; src
   pop de   ; dst
   ld bc,(ix+ZRECT.WIDTH)
   sla c
   rl b
   ldir
   pop bc
   djnz zdisp_scrollrect_up.copy.loop
zdisp_scrollrect_up.copy.done:
   pop af
   ret


;; zdisp_scrollrect_up.clear -- clear rectangle after scrolling up
;; INPUTS:
;;  ix = rectangle
;;  a = upward shift (in pixels)
;; OUTPUTS:
;;  ix = rectangle
;;  a = upward shift
;; ERRORS: no.
;; DESTROYS: (all)
zdisp_scrollrect_up.clear:
   ;; clear lower rectangle that will be exposed by scroll
   ;; initialize clear-rect
   push af
   push ix
   lea hl,ix
   ld ix,-ZRECT_SIZE
   add ix,sp
   ld sp,ix
   lea de,ix
   ld bc,ZRECT_SIZE
   ldir
   ld b,a
   ld c,(ix+ZRECT.HEIGHT)
   ;; clear-rect.height <- min(upward-shift, rect-height)
   cp a,c   ; flags(shift - rect.height)
   jr c,_
   ld a,c
_  ld (ix+ZRECT.HEIGHT),a  ; save clear-rect.height
   ;; clear-rect.orgrow <- rect.orgrow + rect.height - clear-rect.height
   neg
   add a,c
   add a,(ix+ZRECT.ORGROW)
   ld (ix+ZRECT.ORGROW),a  ; save clear-rect.orgrow
   ;; NOTE: orgcol and width stay the same.
   ld hl,$ffff     ; white
   call zdisp_fillrect
   lea hl,ix+ZRECT_SIZE
   ld sp,hl
   pop ix
   pop af
   ret
