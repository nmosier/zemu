#include "ti84pce.inc"
#include "zemu.inc"
#include "zhdr.inc"
#include "zutil.inc"
#include "zwin.inc"
#include "zhex.inc"

.assume ADL=1
.org userMem-2


.db tExtTok, tAsm84CeCmp

start:
   call zdisp_init

#ifdef ZDBG
   call zdbg_init
#endif
   call init_windows

   ; clear screen & reset cursor
   ; no scrolling for now
   res appAutoScroll,(iy+appFlags)  ; TODO: is this necessary?

   xor a,a
   ld (curRow),a
   ld (curCol),a
   
   ld hl,zork_zmap
   call zemu_open ; open story file
   ld hl,zemu_open_str
   jp c,zemu_perror
   call zmem_init ; initialize memory
   ld hl,zmem_init_str
   jp c,zemu_perror

#ifndef ZDBG
   call zcpu_init
   call zcpu_run
#else
   call zdbg_init
   call zdbg_run
#endif
   ld hl,zemu_str
   jp c,zemu_perror

zemu_str: .db "zemu",0

;; intialize windows
init_windows:
   ld ix,win_main
   call zwin_clear

#ifdef ZDBG
   push iy
   
   ld iy,win_dbgout
   ld a,SFONT_HEIGHT*2
   ld b,0 ; don't buffer
   call zwin_split_bottom

   ld iy,win_dbgin
   ld a,SFONT_HEIGHT
   ld b,MASK(ZWIN.FLAGS.BUFD)
   call zwin_split_bottom

   ld iy,win_dbg1
   ld hl,100
   ld b,0 ; don't buffer
   call zwin_split_right

   ld ix,win_dbg1
   ld iy,win_dbg2
   ld a,lcdHeight/2
   ld b,0 ; don't buffer
   call zwin_split_bottom

   pop iy
#endif
   ret

win_main: D_ZWIN(2, 2, DISP_WIDTH-4, DISP_HEIGHT-4, MASK(ZWIN.FLAGS.BUFD), 512)
win_main_protector: .db $42

#ifdef ZDBG
win_dbgout: RES_ZWIN(0) ; not buffered
win_dbgin: D_ZWIN(0, 0, 0, 0, 0, WIN_DBGIN_BUFSIZE) ; buffered
win_dbg1: RES_ZWIN(0) ; not buffered
win_dbg2: RES_ZWIN(0) ; not buffered
#endif


zemu_open_str: .db "zemu_open",0
zmem_init_str: .db "zmem_init",0

; zemu_open -- open zemu story file
; INPUTS:
;  - hl = name of story file's canonical zmap
; OUTPUTS:
;  zemu_appvar, zemu_header, zemu_table set
; DESTROYS: (all)
zemu_open:
   ld de,zmap_name_canonical
   ld bc,VARNAMELEN
   call strncpy
   ld hl,zmap_name_canonical
zemu_open.find_zmap:
   call zmap_load
zemu_open.table_init:
   ld ix,(zmap_header)
   ld b,(ix+ZMAP_HDR_NPAGES)
   ld ix,(zmap_table)
zemu_open.table_init.loop:
   ; move varname into OP1
   push ix
   push bc
   lea hl,ix+ZMAP_ENT_VARNAME
   call appvar_find
   pop bc
   pop ix
   jr c,zemu_open.err
   call _ChkInRAM
   jr nz,_
   set ZMAP_ENT_FLAGS_INRAM,(ix+ZMAP_ENT_FLAGS)
_  ; save pointer
   inc de
   inc de
   ld (ix+ZMAP_ENT_PTR),de
zemu_open.table_init.loop_end:      
   lea ix,ix+ZMAP_TABENTLEN
   ; loop condition
   djnz zemu_open.table_init.loop
   or a,a      ; SUCCESS
   ret

zemu_open.err:
   ld a,ZERR_NOVAR
   ret
   
   
;; zemu_cleanup -- cleanup in preparation for exit
zemu_cleanup:
   ; check if zmap was found
   ld hl,(zmap_appvar)
   ld de,0
   or a,a
   sbc hl,de ; (hl == 0)
   jr z,zemu_cleanup.table_loop.end ; skip table cleanup if zmap not loaded
   ld ix,(zmap_header)
   ld b,(ix+ZMAP_HDR_NPAGES)
   ld ix,(zmap_table)
zemu_cleanup.table_loop:
   ; if zpage is in RAM, archive it
   bit ZMAP_ENT_FLAGS_INRAM,(ix+ZMAP_ENT_FLAGS)
   jr z,zemu_cleanup.table_loop.cond
   ; move varname into OP1
   lea hl,ix+ZMAP_ENT_VARNAME
   call appvar_to_OP1
   call _Arc_Unarc ; archive zpage
zemu_cleanup.table_loop.cond:
   lea ix,ix+ZMAP_TABENTLEN
   djnz zemu_cleanup.table_loop
zemu_cleanup.table_loop.end:
zemu_cleanup.done:
zemu_exit.done:
   scf \ ccf ; success
   ret


;; TESTING ;;
zork_zmap: .db "ZORK",0

;;;;;;;;;;;;;
;; GLOBALS ;;
;;;;;;;;;;;;;

;; story_name -- name of current story (max of STORY_NAME_MAXLEN) bytes
story_name: RESB(STORY_NAME_MAXLEN)



#include "zerr.z80"
#include "zutil.z80"
#include "zmem.z80"
#include "zaddr.z80"
#include "zmap.z80"
#include "zcode.z80"
#include "zvar.z80"
#include "zobj.z80"
#include "zop.z80"
#include "zbranch.z80"
#include "zexec.z80"
#include "zstr.z80"
#include "zrand.z80"
#include "zcall.z80"
#include "zdisp.z80"
#include "zdbg.z80"
#include "zwin.z80"
#include "zin.z80"
#include "zdict.z80"
#include "zcpu.z80"
#include "zsave.z80"
#include "zapp.z80"