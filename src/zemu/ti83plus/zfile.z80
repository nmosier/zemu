#ifndef TI83PLUS_ZFILE_Z80
#define TI83PLUS_ZFILE_Z80


;; file_addr -- get address of byte in file
;; INPUTS:
;;  ix = file pointer
;;  hl = offset (offset < 16KB - 2B)
;; OUTPUTS:
;;  [a:hl] = RAM/flash address of byte
;;  ZF = whether in RAM (Z = RAM, NZ = flash)
;; DESTROYS: (all)
;; ERRORS: yes.
file_addr:
  push hl
   call file_info
   jr c,file_addr.err1
   ld a,b
   or a,a
   jr z,file_addr.RAM ; hl >= $8000, so in RAM, and size bytes skipped
file_addr.flash:
   ;; get length of symbol
   ld hl,9 ; offset of name length
   call add_flash
   ld de,file_addr.namelen
   ld bc,1
   push af
    SYSCALL(_FlashToRAM)
    ex de,hl
    dec hl
    ld c,(hl)
    ld b,0
    inc c \ inc c ; skip size bytes
   pop af
  pop hl
  add hl,bc ; add name length plus size bytes to requested offset
  ex de,hl
  call add_flash
  or a,a
  ret

file_addr.RAM:
  pop hl
  inc hl \ inc hl ; skip size bytes
  add hl,de       
  or a,a         ; NC, Z
  ret             ; success

file_addr.err1:
  pop hl
  ret

file_addr.namelen: .db 0


;; add_flash -- add offset to flash pointer
;; INPUTS:
;;  a = page no.
;;  hl = page offset
;;  de = offset to add
;; OUTPUTS:
;;  a = page no.
;;  hl = page offset
;; DESTROYS: (none)
;; ERRORS: no.
add_flash:
  add hl,de
  bit 7,h
  ret z
  res 7,h
  set 6,h
  inc a
  ret

;; sub_flash, sbc_flash -- subtract offset from flash pointer
;; INPUTS:
;;  a = page no.
;;  hl = page offset
;;  de = offset to subtract
;; OUTPUTS:
;;  a = page no.
;;  hl = page offset
;; DESTROYS: (none)
;; ERRORS: no.
sub_flash:
  or a,a
sbc_flash:
  sbc hl,de
  bit 6,h
  ret nz
  set 6,h
  dec a
  ret


;; file_size -- get size of file
;; INPUTS:
;;  ix = file pointer
;; OUTPUTS:
;;  hl = size
;; DESTROYS: (all)
;; ERRORS: yes.
;; OPTIM: preserve more registers.
file_size:
  ;; first check if already cached
  bit FILE.FLAGS.SIZE,(ix+FILE.FLAGS)
  jr nz,file_size.done
  LD_HL_0
  call file_addr
  ret c
  jr z,file_size.RAM
file_size.flash:
  ld de,2
  call sub_flash
  ld bc,2
  LEA_DE_IX(FILE.SIZE)
  SYSCALL(_FlashToRAM)
  jr file_size.done

file_size.RAM:
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ld (ix+FILE.SIZE),l
  ld (ix+FILE.SIZE+1),h
file_size.done:
  ld l,(ix+FILE.SIZE)
  ld h,(ix+FILE.SIZE+1)
  set FILE.FLAGS.SIZE,(ix+FILE.FLAGS)
  or a,a
  ret


;; file_readn -- read bytes from file into buffer
;; INPUTS:
;;  ix = file pointer
;;  hl = file offset
;;  de = output buffer
;;  bc = size (size > 0)
;; OUTPUTS:
;;  bc = 0
;;  hl <- hl + bc
;;  de <- de + bc
;; DESTROYS: (all)
;; ERRORS: ???
file_readn:
  push de
  push bc
  call file_addr
  pop bc
  pop de
  ret c
  SYSCALL(_FlashToRAM)
  or a,a
  ret


;; file_readb -- read byte from file
;; INPUTS:
;;  ix = file pointer
;;  hl = offset into file
;; OUTPUTS:
;   a = byte
;; DESTROYS: (all)
;; ERRORS: yes.
file_readb:
  call file_addr
  ret c
  ld de,file_read.buf
  ld bc,1
  SYSCALL(_FlashToRAM)
  ld a,(file_read.buf)
  or a,a ; success
  ret


;; file_readw, file_readl -- read word, long from file
;; INPUTS:
;;  ix = file pointer
;;  hl = offset into file
;; OUTPUTS:
;;  hl = word, long
;; DESTROYS: (all)
;; ERRORS: yes.
file_readw:
file_readl:
  call file_addr
  ret c
  ld de,file_read.buf
  ld bc,2
  SYSCALL(_FlashToRAM)
  ld hl,(file_read.buf)
  ret


;; file_writel -- write long to file
;; INPUTS:
;;  ix = file struct
;;  hl = file offset
;;  de = long
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
file_writel .equ file_writew


file_read.buf: RESB(VARNAMELEN) ; max(VARNAMELEN, BYTE_SIZE, WORD_SIZE, LONG_SIZE)

#endif