#ifndef TI83PLUS_ZWIN_Z80
#define TI83PLUS_ZWIN_Z80

;; zwin_select -- select window for displaying characters
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: (none)
;; ERRORS: no.
;; *** portable ***
zwin_select:
  push af
  ld a,(ix+ZWIN.CURROW)
  ld (penRow),a
  ld a,(ix+ZWIN.CURCOL)
  ld (penCol),a
  pop af
  ret

#ifdef ZBORDER
;; zwin_border -- display window border
;; INPUTS:
;;  ix = window
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: no.
;; NOTE: Assumes that window has display margin of at least 1px.
zwin_border:
   ;; fetch rows
   ld h,(ix+ZWIN.ORGROW)
   ld l,(ix+ZWIN.ORGCOL)
   ld a,h
   add a,(ix+ZWIN.HEIGHT)
   dec a
   ld d,a
   ld a,l
   add a,(ix+ZWIN.WIDTH)
   dec a
   ld e,a
   push ix
   bcall(_DrawRectBorder)
   pop ix
   ret
#endif

;; zwin_putc.base.other
;; INPUTS:
;;  a = character
;;  ix = pointer to window struct
;; OUTPUTS:
;;  ix = pointer to window struct
;; DESTROYS: (all)
;; ERRORS: (none)
zwin_putc.base.other:
  ; compute new length of line with added character
  call sfont_width
  ld c,a
  push bc ; save char and sfontlen
  ld a,(ix+ZWIN.CURCOL)
  add a,b
  sub a,(ix+ZWIN.ORGCOL)
  ; a = new width of line
  ; if line > width, newline
  scf
  sbc a,(ix+ZWIN.WIDTH)
  ld a,c ; restore char
  call nc,zwin_newline_bare ; newline, no buffering
  call zwin_select ; select window for writing
  push ix
  ; a = char
  bcall(_VPutMap)
  pop ix
  pop af ; a <- sfont_len
  ; update current column
  add a,(ix+ZWIN.CURCOL)
  ld (ix+ZWIN.CURCOL),a
  ret


;; zwin_unputc -- remove last character from window
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; ERRORS: no, but safe.
;; DESTROYS: a, bc
;; NOTES: erases character on screen.
zwin_unputc:
zwin_unputcursor:
  push hl \ push de

  ;; get buffer index
  push ix \ pop de
  LD_HL_FROM_IX(ZWIN.BUFPTR)
  push hl
  ld de,ZWIN.BUF
  LD_BC_IX
  or a,a
  sbc hl,de
  sbc hl,bc
  ;; if index == 0, nothing to unput 
  jr z,zwin_unputc.done

  ;; decrement buffer pointer and get removed char
  pop hl
  dec hl
  ld a,(hl)
  LD_HL_TO_IX(ZWIN.BUFPTR)

  ;; get width of removed char
  call sfont_width
  ld a,(ix+ZWIN.CURCOL)
  sub a,b
  cp a,(ix+ZWIN.ORGCOL)
  jr z,zwin_unputc.prevline

  ;; save new width
  ld (ix+ZWIN.CURCOL),a

  ;; clear char rectangle
  ld c,(ix+ZWIN.CURROW)
  push ix
  ld ix,-ZRECT_SIZE
  add ix,sp
  ld sp,ix
  ld (ix+ZRECT.ORGCOL),a
  ld (ix+ZRECT.ORGROW),c
  ld (ix+ZRECT.WIDTH),b
  ld (ix+ZRECT.HEIGHT),SFONT_HEIGHT
  call zdisp_clearrect
  ld ix,ZRECT_SIZE
  add ix,sp
  ld sp,ix
  pop ix
zwin_unputc.done:
  pop de \ pop hl
  or a,a
  ret

zwin_unputc.prevline:
  call zwin_redraw
  jr zwin_unputc.done





#endif