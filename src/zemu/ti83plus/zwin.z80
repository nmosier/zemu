#ifndef TI83PLUS_ZWIN_Z80
#define TI83PLUS_ZWIN_Z80

;; zwin_select -- select window for displaying characters
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: (none)
;; ERRORS: no.
;; *** portable ***
zwin_select:
  push af
  ld a,(ix+ZWIN.CURROW)
  ld (penRow),a
  ld a,(ix+ZWIN.CURCOL)
  ld (penCol),a
  pop af
  ret

#ifdef ZBORDER
;; zwin_border -- display window border
;; INPUTS:
;;  ix = window
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: no.
;; NOTE: Assumes that window has display margin of at least 1px.
zwin_border:
   ;; fetch rows
   ld h,(ix+ZWIN.ORGROW)
   ld l,(ix+ZWIN.ORGCOL)
   ld a,h
   add a,(ix+ZWIN.HEIGHT)
   dec a
   ld d,a
   ld a,l
   add a,(ix+ZWIN.WIDTH)
   dec a
   ld e,a
   push ix
   bcall(_DrawRectBorder)
   pop ix
   ret
#endif

;; zwin_putc.base.other
;; INPUTS:
;;  a = character
;;  ix = pointer to window struct
;; OUTPUTS:
;;  ix = pointer to window struct
;; DESTROYS: (all)
;; ERRORS: (none)
zwin_putc.base.other:
  ; compute new length of line with added character
  call sfont_width
  ld c,a
  push bc ; save char and sfontlen
  ld a,(ix+ZWIN.CURCOL)
  add a,b
  sub a,(ix+ZWIN.ORGCOL)
  ; a = new width of line
  ; if line > width, newline
  scf
  sbc a,(ix+ZWIN.WIDTH)
  ld a,c ; restore char
  call nc,zwin_newline_bare ; newline, no buffering
  call zwin_select ; select window for writing
  push ix
  ; a = char
  bcall(_VPutMap)
  pop ix
  pop af ; a <- sfont_len
  ; update current column
  add a,(ix+ZWIN.CURCOL)
  ld (ix+ZWIN.CURCOL),a
  ret

#endif