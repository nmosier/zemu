#ifndef TI84PCE_ZWIN_Z80
#define TI84PCE_ZWIN_Z80

;; zwin_select -- select window for displaying characters
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: (none)
;; ERRORS: no.
;; *** portable ***
zwin_select:
  push af
  push hl
  ld a,(ix+ZWIN.CURROW)
  ld (penRow),a
  ld hl,(ix+ZWIN.CURCOL)
  ld (penCol),hl
  pop hl
  pop af
  ret

#ifdef ZBORDER
;; zwin_border -- display window border
;; INPUTS:
;;  ix = window
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: no.
;; NOTE: Assumes that window has display margin of at least 1px.
zwin_border:
   ;; fetch rows
   ld a,(ix+ZWIN.ORGROW)
   ld b,a
   dec b
   add a,(ix+ZWIN.HEIGHT)
   ld c,a
   ;; fetch cols
   ld de,(ix+ZWIN.ORGCOL)
   ld hl,(ix+ZWIN.WIDTH)
   add hl,de
   ex de,hl
   dec hl
   ;; draw rect
   push ix
   call _DrawRectBorder
   pop ix
   ret
#endif


;; zwin_putc.base.other
;; INPUTS:
;;  a = character
;;  ix = pointer to window struct
;; OUTPUTS:
;;  ix = pointer to window struct
;; DESTROYS: (all)
;; ERRORS: (none)
zwin_putc.base.other:
   push ix
   ld hl,(ix+ZWIN.CURCOL)
   ld de,(ix+ZWIN.ORGCOL)
   or a,a
   sbc hl,de ; find current width of line
   
   call sfont_width ; bc = character width
   ld d,b
   ld bc,0
   ld c,d
   ; bc = character width
   
   push bc
   add hl,bc
   ld bc,(ix+ZWIN.WIDTH)
   scf
   sbc hl,bc ; new strlen - width - 1
   call nc,zwin_newline_bare ; don't buffer
   call zwin_select ; select window for writing
   call _VPutMap ; display char
   pop bc
   pop ix
   ; update current column
   ld hl,(ix+ZWIN.CURCOL)
   add hl,bc
   ld (ix+ZWIN.CURCOL),hl
   ret  

;; zwin_unputc -- remove last character from window
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; ERRORS: no, but safe.
;; DESTROYS: a, bc
;; NOTES: erases character on screen.
zwin_unputc:
zwin_unputcursor:
   push hl \ push de

   ;; get buffer index
   ld hl,(ix+ZWIN.BUFPTR)
   lea de,ix+ZWIN.BUF
   or a,a
   sbc hl,de
   jr z,zwin_unputc.done ; nothing to unput
   add hl,de
   dec hl
   ld a,(hl)
   ld (ix+ZWIN.BUFPTR),hl
   ld hl,(ix+ZWIN.CURCOL)
   call sfont_width
   ld d,b
   ld bc,0
   ld c,d
   or a,a
   sbc hl,bc
   ld de,(ix+ZWIN.ORGCOL)
   sbc hl,de   ; NOTE: always NC
   add hl,de
   jr z,zwin_unputc.prevline
   ld (ix+ZWIN.CURCOL),hl
   ;; clear rectangle
   ld a,(ix+ZWIN.CURROW)
   push ix
   ld ix,-ZRECT_SIZE
   add ix,sp
   ld sp,ix
   ld (ix+ZRECT.ORGCOL),hl
   ld (ix+ZRECT.ORGROW),a
   ld (ix+ZRECT.WIDTH),bc
   ld (ix+ZRECT.HEIGHT),SFONT_HEIGHT
   call zdisp_clearrect
   ld ix,ZRECT_SIZE
   add ix,sp
   ld sp,ix
   pop ix
zwin_unputc.done:
   pop de \ pop hl
   or a,a ; NC
   ret

zwin_unputc.prevline:
   call zwin_redraw
   jr zwin_unputc.done


;; zwin_puts_c -- C wrapper for zwin_puts
;; INPUTS:
;;  arg1 = char *string
;;  arg2 = struct zwin **win
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: (all)
zwin_puts_c:
   push ix
   push iy
   ld iy,0
   add iy,sp
   ld hl,(iy+9)  ; arg1 -- string
   ld ix,(iy+12) ; arg2 -- context
   ld ix,(ix)   ; window
   push iy
   ld iy,flags
   call zwin_puts
   pop iy
   ld sp,iy
   pop iy
   pop ix
   ret




#endif