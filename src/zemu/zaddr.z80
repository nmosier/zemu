; zaddr.z80 -- routines for zaddresses
#ifndef ZADDR_Z80
#define ZADDR_Z80

#include "zemu.inc"
#include "zhdr.inc"
#include "zutil.inc"
#include "zaddr.inc"

; Note on zaddrs:
; Z-machine V3 story files are at most 128 KB in size. This means that high mem addresses must be
; represented in 17 bits. The Z80 has a word size of 16 bits and the eZ80 has a word size of 24
; bits, so the TI-84+ CE can represent the size in a multibyte register while the TI-83+ family
; can't.
;
; In the future, it'd be nice to support versions above v3, so the most forward-compatible approach
; would be to use another register as the upper address byte on the TI-83+. For symmetry in the ABI,
; all TI-84+ CE zaddr_* routines should also accept the same parameter; however, they should ignore
; it and continue to use the 24-bit long registers for addresses.

;; zaddr_valid -- check whether address is valid
;; INPUTS:
;;  [b:hl] = Z-address
;;  a = access mask
;;  ix = pointer to zmap header
;; OUTPUTS: (none)
;; ERRORS: yes (ZERR_BADADDR).
;; DESTROYS: de
;; *** portable ***
zaddr_valid:
   push bc
   bit ZADDR_WRITE,a
   jr nz,zaddr_valid.write
zaddr_valid.read:
   LD_CDE_FROM_IX_ZA(ZMAP_HDR_STORYSIZE)
zaddr_valid.cmp:
   call zaddr_cp
   pop bc
   ccf
   ret nc
   ld a,ZERR_BADADDR
   ret
zaddr_valid.write:
   LD_CDE_FROM_IX_ZAW(ZMAP_HDR_STATIC)
   jr zaddr_valid.cmp

;; zaddr_page -- get page number of Z-address
;; INPUTS:
;;  [b:hl] = Z-address
;;  ix = pointer to zmap header
;; OUTPUTS:
;;  a = page number
;; ERRORS: yes.
;; DESTROYS: (none)
;; *** portable ***
zaddr_pageno:
   push bc
   ;; get mask of page number (only high byte)
   ld a,(ix+ZMAP_HDR_PAGEMASK)
   cpl
   and a,h
   ld c,a
   ;; get upper byte of address -> a
#if TI83PLUS
   ld a,b
#elif TI84PCE
   call upperbyte
#endif
   ;; rotate byte
   ld b,(ix+ZMAP_HDR_PAGEBITS)
   inc b
   or a,a   ; NC for loop
   jr zaddr_pageno.entry
zaddr_pageno.shift:
   rra
   rr c
zaddr_pageno.entry:
   ;; INVARIANT: always NC
   djnz zaddr_pageno.shift
   ;; Once loop is completed, A should be 0.
   ld a,c
zaddr_pageno.done:
   ;; NOTE: due to previous loop, always NC, so SUCCESS.
   pop bc
   ret

;; zaddr_offset -- get offset of address within page
;; INPUTS:
;;  [h:l] = Z-address, lower 16 bits
;;  ix = pointer to zmap header
;; OUTPUTS:
;;  de = offset
;; DESTROYS: a
;; ERRORS: no, but always NC.
;; *** portable ***
zaddr_offset:
   UCAST_L_TO_DE ; pages are always multiples of lower bit
   ld a,(ix+ZMAP_HDR_PAGEMASK)
   and a,h
   ld d,a
   ret

;; zaddr_pageent -- get address of page entry
;; INPUTS:
;;  a = page number
;; OUTPUTS:
;;  ix = pointer to page entry
;; DESTROYS: de
;; ERRORS: no (but always NC)
;; *** portable ***
zaddr_pageent:
   MLT_A(ZMAP_TABENTLEN, R_DE)
   ld ix,(zmap_table)
   add ix,de ; pointer to table entry
   ret

#if 0
;; zaddr_accesspage -- get pointer to access page with given permissions
;; INPUTS:
;;  a = page number
;;  b = access mode (ZADDR_READ, ZADDR_WRITE)
;; OUTPUTS:
;;  hl = pointer to page
;; ERRORS: yes.
;; DESTROYS: ???
zaddr_accesspage:
   call zaddr_pageent
   bit ZADDR_WRITE,b
   jr nz,zaddr_accesspage.write

zaddr_accesspage.write:
   ;; check if address in dynamic memory
   bit ZMAP_ENT_FLAGS_COPY,(ix+ZMAP_ENT_FLAGS)
   call nz,zmap_copypage
#endif

;; zaddr_to_paddr -- get physical byte address of Z-machine byte address
;; INPUTS:
;;  [b:hl] = Z-address
;;  a = access mode
;; OUTPUTS:
;;  hl = physical address
;; ERRORS: yes.
;; DESTROYS: (all)
;; NOTE: Only access the single byte pointed to by the physical address.
;; OPTIM: preserve registers to minimize code size.
;; *** portable ***
zaddr_to_paddr:
   push ix
   ld ix,(zmap_header)
   call zaddr_valid           ; check if Z-address is valid, given access mode
   push hl                    ; preserve Z-address, lower 16 bits
   ld d,a                     ; access mode
   call nc,zaddr_pageno       ; get page number -> a
   ld b,d                     ; access mode
   call nc,zmap_fetchpage     ; get page physical address -> hl
   ld ix,(zmap_header)        ; refresh header pointer
   ex (sp),hl                 ; restore Z-address & preserve physical page address
   call nc,zaddr_offset       ; get page offset -> de
   pop hl                     ; restore physical page address
   pop ix
   ret c                      ; ERROR
   add hl,de                  ; compute physical byte address
   ret                        ; SUCCESS (always NC)

;; zaddr_fetch -- fetch byte at logical address
;; INPUTS:
;;  [b:hl] = zaddr (logical address)
;; OUTPUTS:
;;  a = byte at zaddr
;;  [b:hl] <- [b:hl] + 1
;; ERROR: yes.
;; DESTROYS: (none)
;; *** portable ***
zaddr_fetch:
   push de
   PUSH_BHL_ZA
   ld a,MASK(ZADDR_READ)
   call zaddr_to_paddr
   ex de,hl
   POP_BHL_ZA
   jr c,zaddr_fetch.cleanup
   ld a,(de) ; load byte
   INC_BHL_ZA ; inc z-addr in [b:hl]
   ; C reset (nc)
zaddr_fetch.cleanup:
   pop de
   ret

;; zaddr_fetch_c -- C wrapper for zaddr_fetch
;; ARGS:
;;  arg1 = uint24_t address
;; RETV: uint8_t byte = *address
;; ERRORS: no.
;; DESTROYS: (all)
;; TODO: make portable.
zaddr_fetch_c:
   ; push ix
   push iy
   ld iy,0
   add iy,sp
   ld hl,(iy+9) ; address
   push iy
   call zaddr_fetch
   pop iy
   jr nc,_ ; error, but can't propogate
   xor a,a  
_  ld hl,0
   ld l,a
   ld sp,iy
   pop iy
   ; pop ix
   ret


;; zaddr_fetchw -- fetch big-endian word at logical address
;; INPUTS:
;;  [b:hl] = logical address
;; OUTPUTS:
;;  [b:hl] <- [b:hl] + 2
;;  de = word, sign-extended
;; ERRORS: yes.
;; DESTROYS: (all)
;; *** portable ***
zaddr_fetchw:
   call zaddr_fetch
   ret c
   ld d,a
   call zaddr_fetch
   ret c
   ld e,a
   ex de,hl
   call wtols ; upcast
   ex de,hl
   or a,a ; NC
   ret

;; zaddr_fetchwu -- fetch unsigned word at logical address
;; INPUTS:
;;  [b:hl] = Z-addr
;; OUTPUTS:
;;  [b:hl] <- [b:hl] + 2
;;  de = word, zero-extended
;; ERRORS: yes.
;; DESTROYS: (all)
;; *** portable ***
zaddr_fetchwu:
   call zaddr_fetch
   ret c
   ld d,a
   call zaddr_fetch
   ret c
   ld e,a
   ex de,hl
   call wtolu ; upcast
   ex de,hl
   or a,a ; NC
   ret

;; zaddr_fetchb -- fetch byte at logical address and sign-extend
;; INPUTS:
;;  [b:hl] = Z-addr
;; OUTPUTS:
;;  [b:hl] <- [b:hl] + 1
;;  de = byte, sign-extended
;; ERRORS: yes.
;; DESTROYS: (all)
;; *** portable ***
zaddr_fetchb:
   call zaddr_fetch
   ret c
   ex de,hl
   call btols
   ex de,hl
   or a,a ; NC
   ret

;; zaddr_store -- store byte at logical address
;; INPUTS:
;;  [b:hl] = zaddr (logical address)
;;  a = byte to store at zaddr
;; OUTPUTS:
;;  [b:hl] <- [b:hl] + 1
;; ERROR: yes.
;; DESTROYS: a
;; *** portable ***
zaddr_store:
   PUSH_BHL_ZA ; save zaddr
   push de
   push af
   ld a,MASK(ZADDR_WRITE)
   call zaddr_to_paddr
   pop bc ; restore byte to store (in b)
   jr c,zaddr_fetch.cleanup
   ld (hl),b ; store byte
   ex de,hl
zaddr_store.cleanup:
   pop de
   POP_BHL_ZA
   ret c
   INC_BHL_ZA
   ret


;; zaddr_storew -- store word at logical address
;; INPUTS:
;;  [b:hl] = logical address
;;  de = word to store
;; OUTPUTS:
;;  [b:hl] <- [b:hl] + 2
;; ERRORS: yes.
;; DESTROYS: a
zaddr_storew:
   ld a,d
   call zaddr_store
   ret c
   ld a,e
   jp zaddr_store

;; zaddr_unpack -- convert packed address to byte address
;; INPUTS:
;;  [b:hl] = packed address
;; OUTPUTS:
;;  [b:hl] = byte address
;; ERRORS: no.
;; DESTROYS: (none)
;; *** portable ***
zaddr_unpack:
#if TI83PLUS
   add hl,hl
   rlc b
#elif TI84PCE
   add hl,hl
#endif
   ret


;; zaddr_fetchn -- fetch n bytes
;; INPUTS:
;;  [b:hl] = logical address
;;  de = destination buffer
;;  a = count
;; OUTPUTS:
;;  [b:hl] <- [b:hl] + a
;;  de = destination buffer
;; ERRORS: yes.
;; DESTROYS: ac
zaddr_fetchn:
   or a,a
   ret z ; nothing to do
   push de
zaddr_fetchn.loop:
   push af
   call zaddr_fetch ; fetch byte at logical address [b:hl]
   jr c,zaddr_fetchn.err
   ld (de),a
   inc de
   pop af
   dec a
   jr nz,zaddr_fetchn.loop
   pop de
   ret
zaddr_fetchn.err:
   pop de
   pop de
   ret

;; zaddr_set -- set bit
;; zaddr_res -- reset bit
;; zaddr_bit -- test bit
;; INPUTS:
;;  [b:hl] = Z-address
;;  a = bit number
;; OUTPUTS:
;;  ZF set properly (zaddr_bit)
;; DESTROYS: (all)
;; ERRORS: yes.
;; *** portable ***
zaddr_set:
   call maskb
   push af
   ld a,(1 << ZADDR_READ) | (1 << ZADDR_WRITE)
   call zaddr_to_paddr
   pop bc
   ret c
   ld a,b
   or a,(hl)
   ld (hl),a
   ret

zaddr_res:
   call maskb
   push af
   ld a,(1 << ZADDR_READ) | (1 << ZADDR_WRITE)
   call zaddr_to_paddr
   pop bc
   ret c
   ld a,b
   cpl
   and a,(hl)
   ld (hl),a
   ret

zaddr_bit:
   call maskb
   push af
   ld a,MASK(ZADDR_READ)
   call zaddr_to_paddr
   pop bc
   ret c
   and a,(hl)
   ret

#if TI83PLUS
#include "ti83plus/zaddr.z80"
#elif TI84PCE
#include "ti84pce/zaddr.z80"
#endif

#include "zmap.z80"

#endif