;; zapp.z80 -- AppVar routines
;; *** portable ***
#ifndef ZAPP_Z80
#define ZAPP_Z80

#include "zapp.inc"
#include "zerr.inc"

; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: (all)
; *** portable ***
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   xor a
   ld bc,VARNAMELEN
appvar_to_OP1.loop:
   ldi
   ret po
   cp (hl)
   jr nz,appvar_to_OP1.loop
   ld b,c ; remainder bytes to zero out
appvar_to_OP1.zero:
   ld (de),a
   inc de
   djnz appvar_to_OP1.zero
   ret



;; appvar_touch -- create appvar (if doens't already exist) and move it into RAM. 
;; INPUTS:
;;  hl = name string
;;  bc.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; ERROR: yes.
;; TODO: don't use MemChk (use EnoughMem instead).
;; *** portable ***
appvar_touch:
   push bc
   call appvar_to_RAM
   pop hl   ; appvar size now in hl.s
   ret nc ; found appvar and is in RAM
   ; check if enough RAM
   push hl
   SYSCALL(_MemChk)
   pop de
   or a,a
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   ; create var
   ex de,hl
   SYSCALL(_CreateAppVar)
   inc hl \ inc hl ; skip size bytes
   or a,a   ; NC
   ret


;; appvar_trunc -- resize appvar
;; INPUTS:
;;  hl = pointer to appvar data
;;  bc = new size
;; OUTPUTS:
;;  hl = pointer to appvar data
;; ERRORS: yes.
;; DESTROYS: (all)
;; *** portable ***
appvar_trunc:
   ;; initialize stack record
   push ix
   ld ix,-LONG_SIZE
   add ix,sp
   push hl     ; appvar data  ix-0L
   push bc     ; new size     ix-1L
   ;; fetch current size of appvar
   CLEAR_UPPER_DE
   ld e,(hl)
   inc hl
   ld d,(hl)
   push de     ; cur size     ix-2L
   ;; calculate extra memory required
   ex de,hl
   or a,a
   sbc hl,bc
   jr z,appvar_trunc.done
   push ix                 ; preserve ix from destruction by OS calls
   jr c,appvar_trunc.del   ; if new < current, then need to delete memory
appvar_trunc.insert:
   ;; check if enough mem
   SYSCALL(_EnoughMem)    ; de <- extra mem
   jr c,appvar_trunc.err
   ;; compute end of appvar
   LD_HL_FROM_IX(-LONG_SIZE*0)
   LD_BC_FROM_IX(-LONG_SIZE*2)
   add hl,bc
   ex de,hl
   ;; NOTE: hl = extra mem; de = end of appvar
   SYSCALL(_InsertMem)
   jr appvar_trunc.update

appvar_trunc.del:
   ;; calculate memory to delete
   ex de,hl
   or a,a
   sbc hl,hl
   sbc hl,de
   ;; calculate deletion address (mid-appvar)
   LD_HL_FROM_IX(-LONG_SIZE*0)
   LD_BC_FROM_IX(-LONG_SIZE*1)
   add hl,bc
   ;; delete memory
   SYSCALL(_DelMem)
appvar_trunc.update:
   pop ix
   ;; update size field
   LD_HL_FROM_IX(-LONG_SIZE*0)
   LD_BC_FROM_IX(-LONG_SIZE*1)
   ld (hl),c
   inc hl
   ld (hl),b
   or a,a         ; SUCCESS
appvar_trunc.done:
   ;; leave
   ld sp,ix
   pop hl      ; appvar data ptr
   pop ix
   inc hl \ inc hl ; skip size bytes
   ret

appvar_trunc.err:
   ld a,ZERR_NOMEM
   jr appvar_trunc.done


;; appvar_touch_trunc -- create appvar if it doesn't exist, bring into RAM, and resize
;; INPUTS:
;;  hl = name of appvar
;;  bc = size
;; OUTPUTS:
;;  hl = pointer to appvar data
;; DESTROYS: (all)
;; ERRORS: yes.
;; *** portable ***
appvar_touch_trunc:
   push bc
   call appvar_touch
   pop bc
   ex de,hl
   jp nc,appvar_trunc
   ret


#if TI83PLUS
#include "ti83plus/zapp.z80"
#elif TI84PCE
#include "ti84pce/zapp.z80"
#endif

#endif
