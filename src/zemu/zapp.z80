;; zapp.z80 -- AppVar routines

#include "zapp.inc"
#include "zerr.inc"

; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: (all)
; *** portable ***
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   xor a
   ld bc,VARNAMELEN
appvar_to_OP1.loop:
   ldi
   ret po
   cp (hl)
   jr nz,appvar_to_OP1.loop
   ld b,c ; remainder bytes to zero out
appvar_to_OP1.zero:
   ld (de),a
   inc de
   djnz appvar_to_OP1.zero
   ret

;; appvar_find -- find AppVar
;; INPUTS:
;;  hl = name string
;; OUTPUTS:
;;  de = pointer to appvar data
;;  a = whether in RAM ($00 = no, $ff = yes)
;;  ZF = whether in RAM (z = no, nz = yes)
;; ERRORS: yes.
;; NOTE: Doesn't change storage location (archive vs. RAM).
;; *** portable ***
appvar_find:
   call appvar_to_OP1
   call _ChkFindSym
   ld a,ZERR_NOVAR
   ret c
#if TI84PCE
   call _ChkInRAM
#elif TI83PLUS
   ld a,b
   or a,a
#endif
   ld a,$ff
   jr z,_ ; in RAM, so don't skip syment
   ex de,hl
   call syment_size
   add hl,de   ; skip entry
   ex de,hl
   xor a,a     ; not in RAM
_  or a,a
   ret


; appvar_to_RAM -- bring appvar into RAM
; INPUTS:
;  hl = name string
; OUTPUTS:
;  de = pointer to appvar data in RAM
; ERROR: a = error code, CF set
; DESTROYS: (all), OP1
; *** portable ***
appvar_to_RAM:
   call appvar_find
   ret c ; AppVar not found
   jr nz,appvar_to_RAM.done
   ex de,hl
   CLEAR_UPPER_DE
   ld e,(hl)
   inc hl
   ld d,(hl)
   call _MemChk
   or a,a
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   call _Arc_Unarc
appvar_to_RAM.done:
   call _ChkFindSym
   ret ; NOTE: CF will always be reset

;; appvar_touch -- create appvar (if doens't already exist) and move it into RAM. 
;; INPUTS:
;;  hl = name string
;;  bc.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; ERROR: yes.
;; TODO: don't use MemChk (use EnoughMem instead).
;; *** portable ***
appvar_touch:
   push bc
   call appvar_to_RAM
   pop hl   ; appvar size now in hl.s
   ret nc ; found appvar and is in RAM
   ; check if enough RAM
   push hl
   call _MemChk
   pop de
   or a,a
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   ; create var
   ex de,hl
   call _CreateAppVar
   or a,a   ; NC
   ret

#if 0
;; appvar_create -- create appvar (deleting existing one of same name).
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; DESTROYS: (all)
;; ERROR: yes.
appvar_create:
   push de
   call appvar_to_OP1
   call _ChkFindSym
   jr c,appvar_create.deleted
   call _DelVarArc
appvar_create.deleted:
   call _MemChk
   pop de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c ; not enough mem
   ex de,hl ; hl = size
   call _CreateAppVar
   ; de = ptr to appvar
   ret
#endif

;; appvar_copy -- copy contents of one appvar into another
;; INPUTS:
;;  hl = name of src appvar
;;  de = name of dst appvar
;; OUTPUTS:
;;  hl = dst appvar data ptr
;; ERRORS: yes (memory)
;; DESTROYS: (all)
;; *** portable ***
appvar_copy:
   push de        ; preserve dst name
   call appvar_find
   ex de,hl ; hl <- address (regardless of whether in RAM/archive)
   ;; fetch src size
   CLEAR_UPPER_BC
   ld c,(hl)
   inc hl
   ld b,(hl)
   dec hl
   ex (sp),hl  ; preserve src ptr and restore dst name
   push bc     ; preserve size
   call nc,appvar_touch_trunc
   ex de,hl    ; de <- dst ptr
   pop bc      ; restore size
   pop hl      ; restore src ptr
   ret c       ; ERROR
   push de
   ldir        ; perform copy
   pop hl
   ret         ; SUCCESS

;; appvar_trunc -- resize appvar
;; INPUTS:
;;  hl = pointer to appvar data
;;  bc = new size
;; OUTPUTS:
;;  hl = pointer to appvar data
;; ERRORS: yes.
;; DESTROYS: (all)
;; *** portable ***
appvar_trunc:
   ;; initialize stack record
   push ix
   ld ix,-LONG_SIZE
   add ix,sp
   push hl     ; appvar data  ix-0L
   push bc     ; new size     ix-1L
   ;; fetch current size of appvar
   CLEAR_UPPER_BC
   ld e,(hl)
   inc hl
   ld d,(hl)
   push de     ; cur size     ix-2L
   ;; calculate extra memory required
   ex de,hl
   or a,a
   sbc hl,bc
   jr z,appvar_trunc.done
   push ix                 ; preserve ix from destruction by OS calls
   jr c,appvar_trunc.del   ; if new < current, then need to delete memory
appvar_trunc.insert:
   ;; check if enough mem
   call _EnoughMem    ; de <- extra mem
   jr c,appvar_trunc.err
   ;; compute end of appvar
   ld hl,(ix-LONG_SIZE*0)
   ld bc,(ix-LONG_SIZE*2)
   add hl,bc
   ex de,hl
   ;; NOTE: hl = extra mem; de = end of appvar
   call _InsertMem
   jr appvar_trunc.update

appvar_trunc.del:
   ;; calculate memory to delete
   ex de,hl
#if 0 
   ld hl,0
   or a,a
   sbc hl,de
#else
   or a,a
   sbc hl,hl
   sbc hl,de
#endif
   ;; calculate deletion address (mid-appvar)
   ld hl,(ix-0*LONG_SIZE)
   ld bc,(ix-1*LONG_SIZE)
   add hl,bc
   ;; delete memory
   call _DelMem
appvar_trunc.update:
   pop ix
   ;; update size field
   ld hl,(ix-0*LONG_SIZE)
   ld bc,(ix-1*LONG_SIZE)
   ld (hl),c
   inc hl
   ld (hl),b
   or a,a         ; SUCCESS
appvar_trunc.done:
   ;; leave
   ld sp,ix
   pop hl      ; appvar data ptr
   pop ix
   ret

appvar_trunc.err:
   ld a,ZERR_NOMEM
   jr appvar_trunc.done


;; appvar_touch_trunc -- create appvar if it doesn't exist, bring into RAM, and resize
;; INPUTS:
;;  hl = name of appvar
;;  bc = size
;; OUTPUTS:
;;  hl = pointer to appvar data
;; DESTROYS: (all)
;; ERRORS: yes.
appvar_touch_trunc:
   push bc
   call appvar_touch
   pop bc
   ex de,hl
   jp nc,appvar_trunc
   ret

;; syment_size -- compute size of symbol table entry
;; INPUTS:
;;  hl = pointer to symbol table entry
;; OUTPUTS:
;;  de = size
;; DESTROYS: all but hl
;; ERRORS: no.
;; *** portable ***
syment_size:
   ld bc,SYMENT.NL
   ld a,SYMENT.VARNAME
   add hl,bc
   add a,(hl)
   sbc hl,bc   ; always NC
   UCAST_A_TO_DE
   ret
