;; zapp.z80 -- AppVar routines
;; *** portable ***
#ifndef ZAPP_Z80
#define ZAPP_Z80

#include "zapp.inc"
#include "zerr.inc"

; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: (all)
; *** portable ***
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   xor a
   ld bc,VARNAMELEN
appvar_to_OP1.loop:
   ldi
   ret po
   cp (hl)
   jr nz,appvar_to_OP1.loop
   ld b,c ; remainder bytes to zero out
appvar_to_OP1.zero:
   ld (de),a
   inc de
   djnz appvar_to_OP1.zero
   ret

;; appvar_find -- find AppVar
;; INPUTS:
;;  hl = name string
;; OUTPUTS:
;;  de = pointer to appvar data
;;   TI83PLUS: only if in RAM (nz)
;;   TI84PCE: always
;;  a = whether in RAM ($00 = no, $ff = yes)
;;  ZF = whether in RAM (z = no, nz = yes)
;; ERRORS: yes.
;; NOTE: Doesn't change storage location (archive vs. RAM).
;; *** portable ***
appvar_find:
   call appvar_to_OP1
   SYSCALL(_ChkFindSym)
   ld a,ZERR_NOVAR
   ret c
#if TI83PLUS
   xor a,a
   inc b \ dec b
   jr nz,_
   cpl
_  or a,a
   ret
#elif TI84PCE
   call _ChkInRam
   ld a,$ff
   jr z,_ ; in RAM, so don't skip syment
   ex de,hl
   call syment_size
   add hl,de   ; skip entry
   ex de,hl
   xor a,a     ; not in RAM
_  or a,a
   ret
#endif

; appvar_to_RAM -- bring appvar into RAM
; INPUTS:
;  hl = name string
; OUTPUTS:
;  de = pointer to appvar data in RAM
; ERROR: a = error code, CF set
; DESTROYS: (all), OP1
; *** portable ***
appvar_to_RAM:
   call appvar_find
   ret c  ; AppVar not found
   ret nz ; already in RAM
#if TI83PLUS
   AppOnErr(appvar_err.nomem)
   SYSCALL(_Arc_Unarc)
   AppOffErr
   ld a,AppVarObj ; stupid bug in TIOS
   ld (OP1),a
   SYSCALL(_ChkFindSym)
   ret ; NOTE: CF always reset, since we know appvar exists
#elif TI84PCE
   ex de,hl
   CLEAR_UPPER_DE
   ld e,(hl)
   inc hl
   ld d,(hl)
   SYSCALL(_MemChk)
   or a,a
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   SYSCALL(_Arc_Unarc)
   SYSCALL(_ChkFindSym)
   ret ; NOTE: CF will always be reset
#endif

appvar_err.nomem:
  ld a,ZERR_NOMEM
  scf
  ret

;; appvar_touch -- create appvar (if doens't already exist) and move it into RAM. 
;; INPUTS:
;;  hl = name string
;;  bc.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; ERROR: yes.
;; TODO: don't use MemChk (use EnoughMem instead).
;; *** portable ***
appvar_touch:
   push bc
   call appvar_to_RAM
   pop hl   ; appvar size now in hl.s
   ret nc ; found appvar and is in RAM
   ; check if enough RAM
   push hl
   SYSCALL(_MemChk)
   pop de
   or a,a
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   ; create var
   ex de,hl
   SYSCALL(_CreateAppVar)
   or a,a   ; NC
   ret

#if 0
;; appvar_create -- create appvar (deleting existing one of same name).
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; DESTROYS: (all)
;; ERROR: yes.
appvar_create:
   push de
   call appvar_to_OP1
   SYSCALL(_ChkFindSym)
   jr c,appvar_create.deleted
   SYSCALL(_DelVarArc)
appvar_create.deleted:
   SYSCALL(_MemChk)
   pop de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c ; not enough mem
   ex de,hl ; hl = size
   SYSCALL(_CreateAppVar)
   ; de = ptr to appvar
   ret
#endif

;; appvar_copy -- copy contents of one appvar into another
;; INPUTS:
;;  hl = name of src appvar
;;  de = name of dst appvar
;; OUTPUTS:
;;  hl = dst appvar data ptr
;; ERRORS: yes (memory)
;; DESTROYS: (all)
;; *** portable ***
appvar_copy:
   push hl        ; preserve src name
   push de        ; preserve dst name
#if TI83PLUS
   call appvar_to_RAM ; must be in RAM to read
#elif TI84PCE    
   call appvar_find   ; can be read directly in archive
#endif
   jr c,appvar_copy.err2
   ex de,hl ; hl <- address (regardless of whether in RAM/archive)
   ;; fetch src size
   CLEAR_UPPER_BC
   ld c,(hl)
   inc hl
   ld b,(hl)
   dec hl
   ex (sp),hl  ; preserve src ptr and restore dst name
   push bc     ; preserve size
   call nc,appvar_touch_trunc
   ex de,hl    ; de <- dst ptr
   pop bc      ; restore size
   pop hl      ; restore src ptr
   ret c       ; ERROR
   push de
   ldir        ; perform copy
   pop hl      ; restore dst ptr
   ex (sp),hl  ; save dst ptr, restore src name
   call appvar_to_OP1
   SYSCALL(_Arc_Unarc)
   pop hl
   or a,a      ; NC
   ret         ; SUCCESS
appvar_copy.err2:
   pop hl
   pop hl
   ret

;; appvar_trunc -- resize appvar
;; INPUTS:
;;  hl = pointer to appvar data
;;  bc = new size
;; OUTPUTS:
;;  hl = pointer to appvar data
;; ERRORS: yes.
;; DESTROYS: (all)
;; *** portable ***
appvar_trunc:
   ;; initialize stack record
   push ix
   ld ix,-LONG_SIZE
   add ix,sp
   push hl     ; appvar data  ix-0L
   push bc     ; new size     ix-1L
   ;; fetch current size of appvar
   CLEAR_UPPER_DE
   ld e,(hl)
   inc hl
   ld d,(hl)
   push de     ; cur size     ix-2L
   ;; calculate extra memory required
   ex de,hl
   or a,a
   sbc hl,bc
   jr z,appvar_trunc.done
   push ix                 ; preserve ix from destruction by OS calls
   jr c,appvar_trunc.del   ; if new < current, then need to delete memory
appvar_trunc.insert:
   ;; check if enough mem
   SYSCALL(_EnoughMem)    ; de <- extra mem
   jr c,appvar_trunc.err
   ;; compute end of appvar
   LD_HL_FROM_IX(-LONG_SIZE*0)
   LD_BC_FROM_IX(-LONG_SIZE*2)
   add hl,bc
   ex de,hl
   ;; NOTE: hl = extra mem; de = end of appvar
   SYSCALL(_InsertMem)
   jr appvar_trunc.update

appvar_trunc.del:
   ;; calculate memory to delete
   ex de,hl
   or a,a
   sbc hl,hl
   sbc hl,de
   ;; calculate deletion address (mid-appvar)
   LD_HL_FROM_IX(-LONG_SIZE*0)
   LD_BC_FROM_IX(-LONG_SIZE*1)
   add hl,bc
   ;; delete memory
   SYSCALL(_DelMem)
appvar_trunc.update:
   pop ix
   ;; update size field
   LD_HL_FROM_IX(-LONG_SIZE*0)
   LD_BC_FROM_IX(-LONG_SIZE*1)
   ld (hl),c
   inc hl
   ld (hl),b
   or a,a         ; SUCCESS
appvar_trunc.done:
   ;; leave
   ld sp,ix
   pop hl      ; appvar data ptr
   pop ix
   ret

appvar_trunc.err:
   ld a,ZERR_NOMEM
   jr appvar_trunc.done


;; appvar_touch_trunc -- create appvar if it doesn't exist, bring into RAM, and resize
;; INPUTS:
;;  hl = name of appvar
;;  bc = size
;; OUTPUTS:
;;  hl = pointer to appvar data
;; DESTROYS: (all)
;; ERRORS: yes.
;; *** portable ***
appvar_touch_trunc:
   push bc
   call appvar_touch
   pop bc
   ex de,hl
   jp nc,appvar_trunc
   ret

#if TI84PCE
;; syment_size -- compute size of symbol table entry
;; INPUTS:
;;  hl = pointer to symbol table entry
;; OUTPUTS:
;;  de = size
;; DESTROYS: all but hl
;; ERRORS: no.
;; *** portable ***
syment_size:
   ld bc,SYMENT.NL
   ld a,SYMENT.VARNAME
   add hl,bc
   add a,(hl)
   sbc hl,bc   ; always NC
   UCAST_A_TO_DE
   ret
#endif


#endif