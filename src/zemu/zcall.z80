;; zcall.z80 -- routine calling functions

#ifndef ZCALL_Z80
#define ZCALL_Z80

#include "zcall.inc"

;; zcall0 -- call Z-routine without setting any arguments or return value
;; zcall0_unpacked -- same, but don't unpack address
;; INPUTS:
;;  hl = packed address of routine  - or -  [b:hl] = unpacked address of routine
;; OUTPUTS:
;;  [b:hl] = new PC value
;; DESTROYS: (all)
;; ERRORS: yes.
;; NOTE: it is safe to assign arguments directly after calling this function.
;; NOTE: doesn't actaully write to zframe_pc b/c arguments may need to be assigned.
;; TODO: use stack, not global mem.
;; *** portable ***
zcall0:
   call zaddr_unpack
zcall0.unpacked:
   call zaddr_fetch
   ret c
   push hl ; save PC (b also preserved)
   call zstack_enter ; a = # of locals
   pop hl ; restore PC
   ret c
   ; initialize locals
   or a,a
   jr z,zcall0.jump ; no locals to initialize
   ld ix,zcall0.index
   ld (ix+0),1
   ld (ix+1),a
zcall0.loop:
   push ix
   call zaddr_fetchw ; fetch default val
   pop ix
   ret c
   ld a,(ix+0)
   push ix
   PUSH_BHL_ZA ; preserve new PC
   ex de,hl
   call zvar_store ; store val in local
   POP_BHL_ZA  ; restore new PC
   pop ix
   ret c
   inc (ix+0)
   dec (ix+1)
   jr nz,zcall0.loop
zcall0.jump:
   ; hl points to byte address after last local init val
   ; ld (zframe_pc),hl
   or a,a
   ret

zcall0.index:
zcall0.i: .db 0
zcall0.d: .db 0

#ifdef ZDBG

;; zcall_ext -- external (manual) call
;; INPUTS:
;;  [hl = routine]
;;  [de = arg1]
;;  [bc = arg2]
;;  [ix = arg3]
;;  a = argc
;; OUTPUTS:
;;  hl = return value
;; DESTROYS: (all)
;; ERRORS: yes.
zcall_ext:
   ; push args
   push ix
   push bc
   push de
   ; save stack pointer
   ld ix,9
   add ix,sp
   ; invariant: ix is addr of retval on stack
   push af
   cp a,ZCALL_MAXARG+1
   ccf
   jr c,zcall_ext.err
   ; set break frame address
   ld de,(zframe_fp)
   ld (zdbg_frame),de

   push ix
   call zcall0.unpacked ; bare call, sets stack
   pop ix
   ld (zframe_pc),hl ; set PC
   ld a,ZVAR_STACK
   ld (zframe_rv),a ; set return variable
   jr c,zcall_ext.exit
   ; now write variables
   pop af
   or a,a
   jr z,zcall_ext.run
   ld b,1 ; arg counter
   ld c,a ; args left
zcall_ext.loop:
   pop hl ; pop off arg
   push bc
   push ix
   ld a,b
   call nc,zvar_store
   pop ix
   pop bc
   inc b
   dec c
   jr nz,zcall_ext.loop
zcall_ext.run:
   ; execute function, run until ZADDR_NULL
   push ix
   ld ix,zdbg_flags
   call nc,zdbg_run
   pop ix
   jr c,zcall_ext.exit
   ld a,ZVAR_STACK
   call zvar_fetch
zcall_ext.exit:
   ld sp,ix
   ret

zcall_ext.err:
   ld a,ZERR_ARGC
   jr zcall_ext.exit
   
#endif

#endif