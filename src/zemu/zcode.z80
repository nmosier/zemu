;; zcode.z80
;; Nicholas Mosier 2019

#include "zcode.inc"

;; zcode_decode -- decode single instruction
;; INPUTS:
;;  zframe_pc set
;; OUTPUTS: (none)
;; ERROR: yes. set CF and nonzero %a indicates error.
;; DESTROYS: (all)
zcode_decode:
   ; fetch first byte
   ld hl,(zframe_pc)
   call zaddr_fetch
   ret c ; addr translation error
zcode_decode.type:
   ; determine opcode type
   cp ZOPCODE_EXTENDED
   jp z,zcode_decode_extended
   bit ZOPCODE_TYPE_H,a
   jp z,zcode_decode_long ; $$0x -> long
   bit ZOPCODE_TYPE_L,a
   jp z,zcode_decode_short ; $$10
   jp nz,zcode_decode_variable ; $$11
   ;--;

zcode_decode.types: .db 0

;; Each of these functions (zcode_decode_{short,long,variable})
;; decode and execute the instruction. Never called directly.
;; Upon entry, a = first byte of opcode.
zcode_decode_short:
   ld b,a ; save
zcode_decode_short.operand:
   ; 4.3.1 opcode type (& count) is given by bits 4-5. $$11 = 0OP, otherwise 1OP.
   ; left-justify opcode type, then set `omitted' terminator
   rlca
   rlca
   and a,$c0 ; mask of op1 type
   cp a,$c0
   ld ix,zcode_LUT.1OP
   jr nz,_
   ld ix,zcode_LUT.0OP
_
   or a,$3f ; mask in 3 omitteds
   ld (zcode_decode.types),a
   ld (zframe_pc),hl
zcode_decode_short.opnum:
   ; 4.3.1 opcode number given in bottom 4 bits.
   ld a,b
   and a,$0f ; opcode num
#if 1
   MLT_A(LONG_SIZE, R_DE)
#else
   ld de,3
   ld d,a
   mlt de
#endif
   add ix,de
zcode_decode_short.exec:
   ld ix,(ix)
   jp (ix)
   

zcode_decode_long:
   ; 4.3.2 opcode count is always 2OP
   ; 4.4.2 In long form, bit 6 of the opcode gives the type of the first operand,
   ;       bit 5 of the second. A value of 0 means a small constant and 1 means a variable.
   ld b,a
   ld a,$ff
zcode_decode_long.op1:
   bit 6,b
   jr nz,zcode_decode_long.op1_var
zcode_decode_long.op1_small:
   res 7,a
   jr zcode_decode_long.op2
zcode_decode_long.op1_var:
   res 6,a
zcode_decode_long.op2:
   bit 5,b
   jr nz,zcode_decode_long.op2_var
zcode_decode_long.op2_small:
   res 5,a
   jr zcode_decode_long.store_opinfo
zcode_decode_long.op2_var
   res 4,a
zcode_decode_long.store_opinfo
   ; store operand information
   ld (zcode_decode.types),a
   ld (zframe_pc),hl
zcode_decode_long.opnum:
   ld a,b ; restore opcode
   and a,$1f
   ld ix,zcode_LUT.2OP ; always 2OP
   MLT_A(LONG_SIZE, R_DE)
   add ix,de
   ld ix,(ix)
zcode_decode_long.exec:
   jp (ix)
   ;; NOTE: only possible operand types are SHORT and VAR.
   

zcode_decode_variable:
   ; 4.3.3 if bit 5 is 0, then 2OP; otherwise VAR
   ; 4.4.3 In variable or extended forms, a byte of 4 operand types is given next.
   ;       This contains 4 2-bit fields: bits 6 and 7 are the first field, bits 0 and 1 the fourth.
   ; NOTE: does bit 5 even matter?
   ; TODO: figure out whether this even works...
   ld d,a
   call zaddr_fetch ; preserves de; hl++
   ret c
   ld (zcode_decode.types),a
   ld (zframe_pc),hl
zcode_decode_variable.opnum:
   ld a,d
   bit 5,a
   ld ix,zcode_LUT.VAR
   jr nz,_
   ld ix,zcode_LUT.2OP
_
   and a,$1f
   MLT_A(LONG_SIZE, R_DE)
   add ix,de
zcode_decode_variable.exec:
   ld ix,(ix)
   jp (ix)


;;-- NOT SUPPORTED --;;
;; TODO: support extended opcodes.
zcode_decode_extended:
   ld a,ZERR_NOTAVAIL
   ret c ; NOT SUPPORTED YET


;; zcode_fetch_op -- fetch operand from logical address.
;; INPUTS:
;;  hl = zaddr of operand
;;  a = operand type
;; OUTPUTS:
;;  de = operand
;;  hl points to byte after operand
;; ERRORS: yes.
;; DESTROYS: (all)
zcode_fetch_op:
   ; ld de,0 ; for zero-padding
   cp ZOP_LARGE
   jp z,zcode_fetch_op.large
   cp ZOP_SMALL
   jp z,zcode_fetch_op.small
   cp ZOP_VARIABLE
   jp z,zcode_fetch_op.variable
   jp zcode_fetch_op.omitted

zcode_fetch_op.large:
   call zaddr_fetch ; hl++
   ret c
   ld d,a
   call zaddr_fetch ; hl++
   ret c
   ld e,a
   ex de,hl
   call wtols ; upcast
   ex de,hl
   or a,a
   ret

zcode_fetch_op.small:
   call zaddr_fetch ; hl++
   ret c
   ex de,hl
   call btolu ; upcast
   ex de,hl
   or a,a
   ret

zcode_fetch_op.variable:
   call zaddr_fetch ; hl++
   ret c
   ; now %a contains variable no.
   ; fetch variable value
   push hl
   call zvar_fetch ; hl++
   pop de
   ex de,hl
   ; result in %de, errflg set
   ret

;; NOTE: there is no result.
zcode_fetch_op.omitted:
   or a,a
   ret
   
zcode_err.bad:
   ld a,ZERR_BADINSTR
   scf
   ret

zcode_err.notavail:
   ld a,ZERR_NOTAVAIL
   scf
   ret


;; zcode_readvarnum -- read variable number (1 byte)
;; INPUTS:
;;  zframe_pc
;; OUTPUTS:
;;  zframe_pc <- zframe_pc + 1
;;  %a contains variable number
;; ERRORS: yes.
;; DESTROYS: all but %hl
zcode_readvarnum:
   push hl
   ld hl,(zframe_pc)
   call zaddr_fetch
   ret c ; error
   ld (zframe_pc),hl
   pop hl
   ret

;; zcode_decode_branch -- decode branch in opcode.
;; INPUTS:
;;  hl = logical pointer to branch byte(s).
;; OUTPUTS:
;;  de = offset (raw, 24 bits, signed)
;;  hl points to logical address after branch info
;;  Z if branch when false; NZ if branch when true
;; DESTROYS: (all)
;; ERRORS: yes.
;; TODO: input needs to be long ZA.
zcode_decode_branch:
   ; 4.7 If bit 6 is set, then the branch occupies 1 byte only, and the offset
   ;     is in the range 0 to 63, given in the bottom 6 bits. If bit 6 is clear,
   ;     then the offset is a signed 14-bit number given in bits 0 to 5 of the
   ;     first byte followed by all 8 of the second.
   ld de,0
   call zaddr_fetch
   ret c
   ld b,a
   bit 6,b
   jr z,zcode_decode_branch.14bits
zcode_decode_branch.6bits:
   ; unsigned 6-bit offset
   and $3f ; NC
   ld e,a
   bit 7,b
   ret ; NC

zcode_decode_branch.14bits:
   ; signed 14-bit offset
   ; test sign of offset
   and $3f
   bit 5,a
   jr z,zcode_decode_branch.de_signed
   ; offset < 0
   dec de ; de = $ffffff
   add a,$c0 ; set 7,a; set 6,a
zcode_decode_branch.de_signed:
   ld d,a
   push bc
   call zaddr_fetch
   pop bc
   ret c
   ld e,a
   scf \ ccf
   bit 7,b
   ret


zcode_LUT.2OP:
   .dl zcode_err.bad       ; $00
   .dl zexec.je            ; $01
   .dl zexec.jl            ; $02
   .dl zexec.jg            ; $03
   .dl zexec.dec_chk       ; $04
   .dl zexec.inc_chk       ; $05
   .dl zexec.jin           ; $06
   .dl zexec.test          ; $07
   .dl zexec.or            ; $08
   .dl zexec.and           ; $09
   .dl zexec.test_attr     ; $0A
   .dl zexec.set_attr      ; $0B
   .dl zexec.clear_attr    ; $0C
   .dl zexec.store         ; $0D
   .dl zexec.insert_obj    ; $0E
   .dl zexec.loadw         ; $0F
   .dl zexec.loadb         ; $10
   .dl zexec.get_prop      ; $11
   .dl zexec.get_prop_addr ; $12
   .dl zexec.get_next_prop ; $13
   .dl zexec.add           ; $14
   .dl zexec.sub           ; $15
   .dl zexec.mul           ; $16
   .dl zexec.div           ; $17
   .dl zexec.mod           ; $18
   .dl zcode_err.notavail  ; $19
   .dl zcode_err.notavail  ; $1A
   .dl zcode_err.notavail  ; $1B
   .dl zcode_err.notavail  ; $1C
   .dl zcode_err.bad       ; $1D
   .dl zcode_err.bad       ; $1E
   .dl zcode_err.bad       ; $1F

zcode_LUT.1OP:
   .dl zexec.jz            ; $0
   .dl zexec.get_sibling   ; $1
   .dl zexec.get_child     ; $2
   .dl zexec.get_parent    ; $3
   .dl zexec.get_prop_len  ; $4
   .dl zexec.inc           ; $5
   .dl zexec.dec           ; $6
   .dl zexec.print_addr    ; $7
   .dl zcode_err.notavail  ; $8
   .dl zexec.remove_obj    ; $9
   .dl zexec.print_obj     ; $A
   .dl zexec.ret           ; $B
   .dl zexec.jump          ; $C
   .dl zexec.print_paddr   ; $D
   .dl zexec.load          ; $E
   .dl zexec.not           ; $F

zcode_LUT.0OP:
   .dl zexec.rtrue         ; $0
   .dl zexec.rfalse        ; $1
   .dl zexec.print         ; $2
   .dl zexec.print_ret     ; $3
   .dl zexec.nop           ; $4
   .dl zexec.save          ; $5
   .dl zexec.restore       ; $6
   .dl zexec.restart       ; $7
   .dl zexec.ret_popped    ; $8
   .dl zexec.pop           ; $9
   .dl zexec.quit          ; $A
   .dl zexec.new_line      ; $B
   .dl zcode_err.notavail  ; $C
   .dl zexec.verify        ; $D

zcode_LUT.VAR:
   .dl zexec.call          ; $00
   .dl zexec.storew        ; $01
   .dl zexec.storeb        ; $02
   .dl zexec.put_prop      ; $03
   .dl zexec.read          ; $04
   .dl zexec.print_char    ; $05
   .dl zexec.print_num     ; $06
   .dl zexec.random        ; $07
   .dl zexec.push          ; $08
   .dl zexec.pull          ; $09
   .dl zcode_err.notavail  ; $0A
   .dl zcode_err.notavail  ; $0B
   .dl zcode_err.notavail  ; $0C
   .dl zcode_err.notavail  ; $0D
   .dl zcode_err.notavail  ; $0E
   .dl zcode_err.notavail  ; $0F
   .dl zcode_err.notavail  ; $10
   .dl zcode_err.notavail  ; $11
   .dl zcode_err.notavail  ; $12
   .dl zcode_err.notavail  ; $13


;; zcode_decoden -- decode and execute a given number of instructions
;; INPUTS:
;;  hl = address of 1st instruction
;;  b = number of instructions
;; OUTPUTS:
;;  zframe_pc modified
;; DESTROYS: (all)
;; ERRORS: yes.
zcode_decoden:
   ld (zframe_pc),hl
zcode_decoden.loop:
   push bc
   call zcode_decode
   pop bc
   ret c
   djnz zcode_decoden.loop
   ret


;; zcode_rununtil -- execute CPU until given address
;; INPUTS:
;;  hl = (unpacked) address of instruction to break at
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
zcode_rununtil:
   ld de,zcode_rununtil.nop
   ld (zcode_stepuntil.fn),de
   jp zcode_stepuntil
zcode_rununtil.nop:
   or a,a
   ret


;; zcode_stepuntil -- step thru instructions until reach given address
;; INPUTS:
;;  hl = (unpacked) address to break at
;;  (zcode_stepuntil.fn) = function to call at each step
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
zcode_stepuntil:
   push hl
   call zcode_stepuntil.call   
   call nc,zcode_decode
   pop hl
   ret c
   ld de,(zframe_pc)
   call cp_hl_de
   jr nz,zcode_stepuntil
   ret

zcode_stepuntil.call:
   ld hl,(zcode_stepuntil.fn)
   jp (hl)

zcode_stepuntil.fn: .dl 0



