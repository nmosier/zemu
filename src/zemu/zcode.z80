;; zcode.z80
;; Nicholas Mosier 2019

#ifndef ZCODE_Z80
#define ZCODE_Z80

#include "zaddr.inc"
#include "zcode.inc"
#include "util.inc"

;; zcode_decode -- decode single instruction
;; INPUTS:
;;  zframe_pc set
;; OUTPUTS: (none)
;; ERROR: yes. set CF and nonzero %a indicates error.
;; DESTROYS: (all)
;; TODO: use stack mem, not global mem.
zcode_decode:
   ; fetch first byte
   LD_BHL_FROM_ABS_ZA(zframe_pc)
   call zaddr_fetch
   ret c ; addr translation error
zcode_decode.type:
   ; determine opcode type
   cp a,ZOPCODE_EXTENDED
   jp z,zcode_decode_extended
   bit ZOPCODE_TYPE_H,a
   jp z,zcode_decode_long ; $$0x -> long
   bit ZOPCODE_TYPE_L,a
   jp z,zcode_decode_short ; $$10
   jp nz,zcode_decode_variable ; $$11
   ;--;

zcode_decode.types: .db 0

;; Each of these functions (zcode_decode_{short,long,variable})
;; decode and execute the instruction. Never called directly.
;; Upon entry, a = first byte of opcode.
zcode_decode_short:
   LD_BHL_TO_ABS_ZA(zframe_pc)
   ld c,a ; save
zcode_decode_short.operand:
   ; 4.3.1 opcode type (& count) is given by bits 4-5. $$11 = 0OP, otherwise 1OP.
   ; left-justify opcode type, then set `omitted' terminator
   rlca
   rlca
   and a,$c0 ; mask of op1 type
   cp a,$c0
   ld hl,zcode_LUT.1OP
   jr nz,_
   ld hl,zcode_LUT.0OP
_  or a,$3f ; mask in 3 omitteds
   ld (zcode_decode.types),a
zcode_decode_short.opnum:
   ; 4.3.1 opcode number given in bottom 4 bits.
   ld a,c
   and a,$0f ; opcode num
   jp zcode_decode.exec


zcode_decode_long:
   ; 4.3.2 opcode count is always 2OP
   ; 4.4.2 In long form, bit 6 of the opcode gives the type of the first operand,
   ;       bit 5 of the second. A value of 0 means a small constant and 1 means a variable.
   ld c,a
   ld a,$ff
zcode_decode_long.op1:
   bit 6,c
   jr nz,zcode_decode_long.op1_var
zcode_decode_long.op1_small:
   res 7,a
   jr zcode_decode_long.op2
zcode_decode_long.op1_var:
   res 6,a
zcode_decode_long.op2:
   bit 5,c
   jr nz,zcode_decode_long.op2_var
zcode_decode_long.op2_small:
   res 5,a
   jr zcode_decode_long.store_opinfo
zcode_decode_long.op2_var
   res 4,a
zcode_decode_long.store_opinfo
   ; store operand information
   ld (zcode_decode.types),a
   LD_BHL_TO_ABS_ZA(zframe_pc)
zcode_decode_long.opnum:
   ld a,c ; restore opcode
   and a,$1f
   ld hl,zcode_LUT.2OP ; always 2OP
   jp zcode_decode.exec
   

zcode_decode_variable:
   ; 4.3.3 if bit 5 is 0, then 2OP; otherwise VAR
   ; 4.4.3 In variable or extended forms, a byte of 4 operand types is given next.
   ;       This contains 4 2-bit fields: bits 6 and 7 are the first field, bits 0 and 1 the fourth.
   ; NOTE: does bit 5 even matter?
   ; TODO: figure out whether this even works...
   ld d,a
   call zaddr_fetch ; preserves de; hl++
   ret c
   ld (zcode_decode.types),a
   LD_BHL_TO_ABS_ZA(zframe_pc)
zcode_decode_variable.opnum:
   ld a,d
   bit 5,a
   ld hl,zcode_LUT.VAR
   jr nz,_
   ld hl,zcode_LUT.2OP
_  and a,$1f
   jp zcode_decode.exec


;; [INTERNAL] zcode_decode.exec -- look up opcode handler and execute
;; INPUTS:
;;  ix = pointer to table
;; OUTPUTS: see zexec.* functions
zcode_decode.exec:
  MLT_A(LONG_SIZE, R_DE)
  add hl,de
#if TI83PLUS
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
#elif TI84PCE
  ld hl,(hl)
#endif
  jp (hl)


;;-- NOT SUPPORTED --;;
;; TODO: support extended opcodes.
zcode_decode_extended:
   ld a,ZERR_NOTAVAIL
   scf
   ret c ; NOT SUPPORTED YET


;; zcode_fetch_op -- fetch operand from logical address.
;; INPUTS:
;;  hl = zaddr of operand
;;  a = operand type
;; OUTPUTS:
;;  de = operand
;;  hl points to byte after operand
;; ERRORS: yes.
;; DESTROYS: (all)
zcode_fetch_op:
   cp a,ZOP_LARGE
   jp z,zcode_fetch_op.large
   cp a,ZOP_SMALL
   jp z,zcode_fetch_op.small
   cp a,ZOP_VARIABLE
   jp z,zcode_fetch_op.variable
   jp zcode_fetch_op.omitted

zcode_fetch_op.large:
   call zaddr_fetch ; [b:hl]++
   ret c
   ld d,a
   call zaddr_fetch ; [b:hl]++
   ret c
   ld e,a
   ex de,hl
   WTOLS_HL ; upcast
   ex de,hl
   or a,a
   ret

zcode_fetch_op.small:
   call zaddr_fetch ; [b:hl]++
   ret c
   ex de,hl
   call btolu ; upcast
   ex de,hl
   or a,a
   ret

zcode_fetch_op.variable:
   call zaddr_fetch ; [b:h]l++
   ret c
   ; now %a contains variable no.
   ; fetch variable value
   PUSH_BHL_ZA
   call zvar_fetch ; hl++
   ex de,hl
   POP_BHL_ZA
   ; result in %de, errflg set
   ret

;; NOTE: there is no result.
zcode_fetch_op.omitted:
   or a,a
   ret
   
zcode_err.bad:
   ld a,ZERR_BADINSTR
   scf
   ret

zcode_err.notavail:
   ld a,ZERR_NOTAVAIL
   scf
   ret


;; zcode_readvarnum -- read variable number (1 byte)
;; INPUTS:
;;  zframe_pc
;; OUTPUTS:
;;  zframe_pc <- zframe_pc + 1
;;  %a contains variable number
;; ERRORS: yes.
;; DESTROYS: all but %hl
zcode_readvarnum:
   push hl
   LD_BHL_FROM_ABS_ZA(zframe_pc)
   call zaddr_fetch
   ret c ; error
   LD_BHL_TO_ABS_ZA(zframe_pc)
   pop hl
   ret

;; zcode_decode_branch -- decode branch in opcode.
;; INPUTS:
;;  [b:hl] = logical pointer to branch byte(s).
;; OUTPUTS:
;;  de = offset (raw, 24 bits, signed)
;;  [b:hl] points to logical address after branch info
;;  Z if branch when false; NZ if branch when true
;; DESTROYS: (all)
;; ERRORS: yes.
;; TODO: input needs to be long ZA.
zcode_decode_branch:
   ; 4.7 If bit 6 is set, then the branch occupies 1 byte only, and the offset
   ;     is in the range 0 to 63, given in the bottom 6 bits. If bit 6 is clear,
   ;     then the offset is a signed 14-bit number given in bits 0 to 5 of the
   ;     first byte followed by all 8 of the second.
   ld de,0
   call zaddr_fetch
   ret c
   ld c,a
   bit 6,c
   jr z,zcode_decode_branch.14bits
zcode_decode_branch.6bits:
   ; unsigned 6-bit offset
   and a,$3f ; NC
   ld e,a
   bit 7,c
   ret ; NC

zcode_decode_branch.14bits:
   ; signed 14-bit offset
   ; test sign of offset
   and a,$3f
   bit 5,a
   jr z,zcode_decode_branch.de_signed
   ; offset < 0
   dec de ; de = $ffffff
   add a,$c0 ; set 7,a; set 6,a
zcode_decode_branch.de_signed:
   ld d,a
   push bc
   call zaddr_fetch
   ex (sp),hl
   ld c,l
   pop hl
   ret c
   ld e,a
   or a,a
   bit 7,c
   ret


zcode_LUT.2OP:
   DL zcode_err.bad       ; $00
   DL zexec.je            ; $01
   DL zexec.jl            ; $02
   DL zexec.jg            ; $03
   DL zexec.dec_chk       ; $04
   DL zexec.inc_chk       ; $05
   DL zexec.jin           ; $06
   DL zexec.test          ; $07
   DL zexec.or            ; $08
   DL zexec.and           ; $09
   DL zexec.test_attr     ; $0A
   DL zexec.set_attr      ; $0B
   DL zexec.clear_attr    ; $0C
   DL zexec.store         ; $0D
   DL zexec.insert_obj    ; $0E
   DL zexec.loadw         ; $0F
   DL zexec.loadb         ; $10
   DL zexec.get_prop      ; $11
   DL zexec.get_prop_addr ; $12
   DL zexec.get_next_prop ; $13
   DL zexec.add           ; $14
   DL zexec.sub           ; $15
   DL zexec.mul           ; $16
   DL zexec.div           ; $17
   DL zexec.mod           ; $18
   DL zcode_err.notavail  ; $19
   DL zcode_err.notavail  ; $1A
   DL zcode_err.notavail  ; $1B
   DL zcode_err.notavail  ; $1C
   DL zcode_err.bad       ; $1D
   DL zcode_err.bad       ; $1E
   DL zcode_err.bad       ; $1F

zcode_LUT.1OP:
   DL zexec.jz            ; $0
   DL zexec.get_sibling   ; $1
   DL zexec.get_child     ; $2
   DL zexec.get_parent    ; $3
   DL zexec.get_prop_len  ; $4
   DL zexec.inc           ; $5
   DL zexec.dec           ; $6
   DL zexec.print_addr    ; $7
   DL zcode_err.notavail  ; $8
   DL zexec.remove_obj    ; $9
   DL zexec.print_obj     ; $A
   DL zexec.ret           ; $B
   DL zexec.jump          ; $C
   DL zexec.print_paddr   ; $D
   DL zexec.load          ; $E
   DL zexec.not           ; $F

zcode_LUT.0OP:
   DL zexec.rtrue         ; $0
   DL zexec.rfalse        ; $1
   DL zexec.print         ; $2
   DL zexec.print_ret     ; $3
   DL zexec.nop           ; $4
   DL zexec.save          ; $5
   DL zexec.restore       ; $6
   DL zexec.restart       ; $7
   DL zexec.ret_popped    ; $8
   DL zexec.pop           ; $9
   DL zexec.quit          ; $A
   DL zexec.new_line      ; $B
   DL zcode_err.notavail  ; $C
   DL zexec.verify        ; $D

zcode_LUT.VAR:
   DL zexec.call          ; $00
   DL zexec.storew        ; $01
   DL zexec.storeb        ; $02
   DL zexec.put_prop      ; $03
   DL zexec.read          ; $04
   DL zexec.print_char    ; $05
   DL zexec.print_num     ; $06
   DL zexec.random        ; $07
   DL zexec.push          ; $08
   DL zexec.pull          ; $09
   DL zcode_err.notavail  ; $0A
   DL zcode_err.notavail  ; $0B
   DL zcode_err.notavail  ; $0C
   DL zcode_err.notavail  ; $0D
   DL zcode_err.notavail  ; $0E
   DL zcode_err.notavail  ; $0F
   DL zcode_err.notavail  ; $10
   DL zcode_err.notavail  ; $11
   DL zcode_err.notavail  ; $12
   DL zcode_err.notavail  ; $13

#if 0
;; zcode_decoden -- decode and execute a given number of instructions
;; INPUTS:
;;  [b:hl] = address of 1st instruction
;;  b = number of instructions
;; OUTPUTS:
;;  zframe_pc modified
;; DESTROYS: (all)
;; ERRORS: yes.
zcode_decoden:
   ld (zframe_pc),hl
zcode_decoden.loop:
   push bc
   call zcode_decode
   pop bc
   ret c
   djnz zcode_decoden.loop
   ret

;; zcode_rununtil -- execute CPU until given address
;; INPUTS:
;;  hl = (unpacked) address of instruction to break at
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
zcode_rununtil:
   ld de,zcode_rununtil.nop
   ld (zcode_stepuntil.fn),de
   jp zcode_stepuntil
zcode_rununtil.nop:
   or a,a
   ret

;; zcode_stepuntil -- step thru instructions until reach given address
;; INPUTS:
;;  hl = (unpacked) address to break at
;;  (zcode_stepuntil.fn) = function to call at each step
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
zcode_stepuntil:
   push hl
   call zcode_stepuntil.call   
   call nc,zcode_decode
   pop hl
   ret c
   ld de,(zframe_pc)
   call cp_hl_de
   jr nz,zcode_stepuntil
   ret

zcode_stepuntil.call:
   ld hl,(zcode_stepuntil.fn)
   jp (hl)

zcode_stepuntil.fn: .dl 0

#endif

#include "zexec.z80"

#endif