;; zerr.z80
;; *** portable ***

#include "zerr.inc"

zerrmsg_success:    .db "success",0
zerrmsg_novar:      .db "appvar not found",0
zerrmsg_nomem:      .db "not enough free RAM",0
zerrmsg_badaddr:    .db "bad address",0
zerrmsg_notavail:   .db "opcode not supported",0
zerrmsg_nolocl:     .db "invalid local variable",0
zerrmsg_stackempty: .db "cannot pop from empty stack",0
zerrmsg_badinstr:   .db "illegal instruction",0
zerrmsg_badvarno:   .db "invalid variable number",0
zerrmsg_divzero:    .db "divide by 0",0
zerrmsg_badobj:     .db "invalid object",0
zerrmsg_badattr:    .db "attribute number out of range",0
zerrmsg_noprop:     .db "object missing property",0
zerrmsg_badprop:    .db "invalid property length",0
zerrmsg_badchar:    .db "bad character",0
zerrmsg_argc:       .db "too many arguments",0
zerrmsg_intr:       .db "interrupt",0
zerrmsg_zchar:      .db "not a ZSCII character",0
zerrmsg_txtbuf:     .db "text buffer too small",0
zerrmsg_prsbuf:     .db "parse buffer too small",0
zerrmsg_toolong:    .db "name is too long",0
zerrmsg_badname:    .db "name contains invalid character",0
zerrmsg_rdonly:     .db "write attempt to read-only memory",0
zerrmsg_stackover:  .db "stack overflow",0
zerrmsg_internal:   .db "internal error",0

zerrtab:
   DL zerrmsg_success
   DL zerrmsg_novar
   DL zerrmsg_nomem
   DL zerrmsg_badaddr
   DL zerrmsg_notavail
   DL zerrmsg_nolocl
   DL zerrmsg_stackempty
   DL zerrmsg_badinstr
   DL zerrmsg_badvarno
   DL zerrmsg_divzero
   DL zerrmsg_badobj
   DL zerrmsg_badattr
   DL zerrmsg_noprop
   DL zerrmsg_badprop
   DL zerrmsg_badchar
   DL zerrmsg_argc
   DL zerrmsg_intr
   DL zerrmsg_zchar
   DL zerrmsg_txtbuf
   DL zerrmsg_prsbuf
   DL zerrmsg_toolong
   DL zerrmsg_badname
   DL zerrmsg_rdonly
   DL zerrmsg_stackover
   DL zerrmsg_internal

;; zemu_perror -- print error message given zerror code.
;; INPUTS:
;;  a = zerror code
;;  hl = string
;; OUTPUTS: (none)
;; DESTROYS: All
;; NOTE: zemu_perror always sets the carry flag to indicate
;;  error condition. This doesn't mean that zemu_perror failed
;;  (it can't fail), but it is rather for convenience so that
;;  error-handling code can jump to zemu_perror without having
;;  to set the carry flag after calling zemu_perror.
;; *** portable ***
zemu_perror:
   ld ix,win_main
   push af
   call cp_hl_0
   jr z,zemu_perror.bare
   call zwin_puts
   ld hl,zemu_perror.sep
   call zwin_puts
   jr zemu_perror.bare
zemu_perror.done:
   scf
   ret
zemu_perror.sep: .db ": ",0

zemu_perror.bare:
   pop af
   push ix
   call zemu_strerror
   pop ix
   call zwin_puts
   jr zemu_perror.done


zemu_perror_sep: .db ": ",0

;; zemu_strerror -- return error string given error code.
;; INPUTS:
;;  a = zerror code
;; OUTPUTS:
;;  hl = error string (null-terminated)
;;  CF is set
;; DESTROYS: de, ix
;; *** portable ***
zemu_strerror:
   MLT_A(LONG_SIZE, R_DE)
   ld ix,zerrtab
   add ix,de
   ld hl,(ix+0)
   scf
   ret

