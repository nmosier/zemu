#ifndef ZFILE_Z80
#define ZFILE_Z80

#include "zfile.inc"
#include "zti.inc"

; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: (all)
; *** portable ***
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   xor a
   ld bc,VARNAMELEN
appvar_to_OP1.loop:
   ldi
   ret po
   cp (hl)
   jr nz,appvar_to_OP1.loop
   ld b,c ; remainder bytes to zero out
appvar_to_OP1.zero:
   ld (de),a
   inc de
   djnz appvar_to_OP1.zero
   ret



;; file_open -- open existing file
;; INPUTS:
;;  ix = file struct, with name field populated
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
file_open:
  call file_size
  ret c
  ld (ix+FILE.SIZE),l
  ld (ix+FILE.SIZE+1),h
  ret

;; file_create -- create file of given size, removing an existing file of the same name
;; INPUTS:
;;  ix = file struct, with name field and size populated
;; OUTPUTS:
;;  [INTERNAL] de = pointer to appvar data (skips size bytes)
;; DESTROYS: all but ix
;; ERRORS: yes.
file_create:
  LEA_HL_IX(FILE.NAME)
  call appvar_to_OP1
  SYSCALL(_ChkFindSym)
  jr c,file_create.create
  SYSCALL(_DelVarArc)
file_create.create:
  SYSERR_PUSH(file_error.nomem) ; destroys hl
  CLEAR_UPPER_HL
  ld l,(ix+FILE.SIZE)
  ld h,(ix+FILE.SIZE+1)
  SYSCALL(_CreateAppVar)
  SYSERR_POP
  inc de \ inc de ; skip size bytes
  or a,a
  ret


;; file_writeb -- write byte to file
;; INPUTS:
;;  ix = file struct
;;  hl = offset into file
;;  a = byte
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
file_writeb:
  push af
  push hl
  call file_to_RAM
  pop hl
  pop bc
  ret c
  add hl,de
  ld (hl),b
  ret


;; file_writew -- write word to file
;; INPUTS:
;;  ix = file struct
;;  hl = file offset
;;  de = word
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
file_writew:
  push de
  push hl
  call file_to_RAM
  pop hl
  pop bc
  ret c
  add hl,de
  ld (hl),c
  inc hl
  ld (hl),b
  ret


;; file_writen -- write bytes from buffer to file
;; INPUTS:
;;  ix = file pointer
;;  hl = source pointer
;;  de = destination file offset
;;  bc = size (size > 0)
;; OUTPUTS:
;;  bc = 0
;;  hl <- hl + bc
;;  de <- de + bc
;; DESTROYS: (all)
;; ERRORS: ???
file_writen:
  push bc
  push hl
  push de
  call file_to_RAM
  pop hl
  jr c,_
  add hl,de
  ex de,hl
_ pop hl
  pop bc
  ret c
  ldir
  ret


;; file_copy -- copy file
;; INPUTS:
;;  ix = source file struct
;;  iy = destination file struct
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
file_copy:
  ;; copy size bytes
  ld a,(ix+FILE.SIZE)
  ld (iy+FILE.SIZE),a
  ld a,(ix+FILE.SIZE+1)
  ld (iy+FILE.SIZE+1),a
  push iy
   ld iy,flags ; calls require iy = flags unless iy is a parameter
   ex (sp),ix
   ;; create new file
   call file_create
   jr c,file_copy.err1
   ex (sp),ix
   ret c
   sbc hl,hl ; ld hl,0
   push de ; save dst data ptr
    call file_addr
   pop de
   jr c,file_copy.err1
   CLEAR_UPPER_BC
   ld c,(ix+FILE.SIZE)
   ld b,(ix+FILE.SIZE+1)
#if TI83PLUS
   SYSCALL(_FlashToRAM)
#elif TI84PCE
   ldir
#endif
  pop iy
  or a,a
  ret

file_copy.err1:
  pop hl
  ret

;=== INTERNAL ===;

file_error.nomem:
  ld a,ZERR_NOMEM
  scf
  ret


;; file_to_RAM -- bring file into RAM
;; INPUTS:
;;  ix = file pointer
;; OUTPUTS:
;;  de = pointer to file data
;; DESTROYS: 
;; ERRORS: yes.
file_to_RAM:
  call file_info
  ret c           ; error
  inc de \ inc de ; skip size bytes
  ret z           ; already in RAM
  SYSCALL(_Arc_Unarc)
  or a,a 
  ret


;; file_info -- get file info
;; INPUTS:
;;  ix = file pointer
;; OUTPUTS:
;;  [b:de] = address
;;  ZF = whether in RAM (Z = RAM, NZ = archive)
;; DESTROYS: ???
;; ERRORS: yes.
file_info:
  LEA_HL_IX(FILE.NAME)
  call appvar_to_OP1
  SYSCALL(_ChkFindSym)
  ld a,ZERR_NOVAR
  ret c
#if TI83PLUS
  ld a,b
  or a,a
#elif TI84PCE
  call _ChkInRAM
  scf \ ccf ; NC
#endif
  ret


;; file_appvar_to_OP1 -- copy AppVar name to OP1
;; INPUTS:
;;  ix = file pointer
;;  hl = file offset
;; OUTPUTS:
;;  OP1 contains AppVar token + string
;; DESTROYS: ???
;; ERRORS: yes.
file_appvar_to_OP1:
  call file_addr
  ld de,OP1
  ld a,AppVarObj
  ld (de),a
  inc de
  ld bc,VARNAMELEN
  jp nc,file_readn
  ret


;; file_memcpy -- copy memory from file
;; INPUTS:
;;  ix = file pointer
;;  hl = offset into file (source)
;;  de = destination pointer (p-addr)
;;  bc = bytes to copy (bc > 0)
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: yes.
file_memcpy:
  call file_addr
  ret c
#if TI83PLUS
  SYSCALL(_FlashToRAM)
#elif TI84PCE
  ldir
#endif
  or a,a
  ret


#if TI83PLUS
#include "ti83plus/zfile.z80"
#elif TI84PCE
#include "ti84pce/zfile.z80"
#endif


#endif