;; zmap.z80 -- zmap routines
;; Nicholas Mosier 2019
#ifndef ZMAP_Z80
#define ZMAP_Z80

#include "zaddr.inc"
#include "zemu.inc"

;; zmap_fetchpage -- fetch pointer to zpage.
;; INPUTS:
;;  a = page number
;;  b = access mode (ZADDR_READ, ZADDR_WRITE)
;; OUTPUT:
;;  ix = file pointer
;; DESTROYS: (all)
;; ERRORS: yes.
;; NOTE: performs no validation of page number.
;; TODO: this should check if INRAM flag of page for writes.
zmap_fetchpage:
  call zaddr_pageent
  bit ZADDR_WRITE,b
  ret z
  bit ZMAP_ENT.FLAGS.COPY,(ix+ZMAP_ENT.FLAGS)
  ret z
  ld hl,zemu_pagepfx
  call zmap_copypage_ent
  ret c
  set ZMAP_ENT.FLAGS.SAVE,(ix+ZMAP_ENT.FLAGS)
  LEA_IX_IX(ZMAP_ENT.FILE)
  jp file_to_RAM


;; zmap_copypage -- copy page (used when write to page is read-only)
;; zmap_copypage_ent -- copy page, given pointer to entry
;; INPUTS:
;;  a = page number
;;  hl = name prefix
;;  ix = pointer to page entry in zmap (zmap_copypage_ent)
;; OUTPUTS:
;;  hl = pointer to zpage in RAM (skips over size bytes)
;;  current zmap updated
;; DESTROYS: (all) but ix
;; ERRORS: yes.
;; TODO: parameterize page naming.
;; *** portable ***
zmap_copypage:
  ;; get pointer to entry
  call zaddr_pageent
zmap_copypage_ent:
  ;; get src and dst var names
  ;; name page
  ld de,zmap_copypage.file + FILE.NAME
  call zmap_namepage
  push ix
   push iy
    LEA_IX_IX(ZMAP_ENT.FILE)
    ld iy,zmap_copypage.file
    call file_copy
   pop iy
  pop ix
  ret c ; error
  ld hl,zmap_copypage.file
  LEA_DE_IX(ZMAP_ENT.FILE)
  ld bc,SIZEOF_FILE
  ldir
  ret

zmap_copypage.file: RES_FILE

zemu_pagepfx: .db "ZEMUP",0

;; zmap_namepage -- rename page after being copied
;; INPUTS:
;;  hl = prefix
;;  a = page ID
;;  de = buffer (at least 8 chars)
;; OUTPUTS:
;;  hl = buffer
;; DESTROYS: a, bc, de
;; ERRORS: no.
;; *** portable ***
zmap_namepage:
   push de     ; buffer
   push af     ; ID
   ld bc,VARNAMELEN-2
   call strncpy
   pop af      ; ID
   ex de,hl
   ld b,a
   and a,$f0
   rrca
   rrca
   rrca
   rrca
   call xtoc
   ld (hl),a
   inc hl
   ld a,b
   and a,$0f
   call xtoc
   ld (hl),a
   inc hl
   ex de,hl
   ld hl,0
   call cp_hl_bc
   ex de,hl
   jr z,_
   ld (hl),0
_  pop hl
   ret

;; zmap_load -- load saved zmap into working zmap
;; INPUTS:
;;  hl = name of saved zmap (zmap_load)
;; OUTPUTS:
;;  touches & resizes working zmap and copies contents of saved zmap into it
;; DESTROYS: (all, including ix)
;; ERRORS: yes.
;; *** portable ***
zmap_load:
  ld de,zmap_canonical_file+FILE.NAME
  ld bc,VARNAMELEN
  call strncpy
  push ix
   push iy
    ld ix,zmap_canonical_file
    ld iy,zmap_working_file
    call file_open
    call nc,file_copy
   pop iy
  pop ix
  ret
  

;; zmap_header -- get pointer to zmap header
;; INPUTS: (none)
;; OUTPUTS:
;;  ix = pointer to zmap header
;; DESTROYS: (none)
;; ERRORS: yes.
;; OPTIM required
zmap_header:
  push hl
   push de
    push bc
     push af
      ld ix,zmap_working_file
      LD_HL_0
      call file_addr
      LD_IX_HL
     pop bc
     ld a,b
    pop bc
   pop de
  pop hl
  ret

;; zmap_table -- get pointer to zmap table
;; INPUTS: (none)
;; OUTPUTS:
;;  ix = pointer to zmap table
;; DESTROYS: (none)
;; ERRORS: yes.
;; OPTIM required.
zmap_table:
  push hl
   push de
    push bc
     push af
      ld ix,zmap_working_file
      ld hl,ZMAP_HDRSIZE
      call file_addr
      LD_IX_HL
     pop bc
     ld a,b
    pop bc
   pop de
  pop hl
  ret

;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; ZMAP GLOBALS ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;

zmap_working_file: D_FILE("ZEMUMAP", 0)
zmap_canonical_file: RES_FILE
zmap_name_canonical: RESB(VARNAMELEN)
zmap_name_current:   .db "ZEMUMAP",0

#include "zapp.z80"

#endif