;; zmap.z80 -- zmap routines
;; Nicholas Mosier 2019
#ifndef ZMAP_Z80
#define ZMAP_Z80

#include "zaddr.inc"
#include "zemu.inc"

;; zmap_fetchpage -- fetch pointer to zpage.
;; INPUTS:
;;  a = page number
;;  b = access mode (ZADDR_READ, ZADDR_WRITE)
;; OUTPUT:
;;  hl = pointer to zpage in RAM (skips over size bytes)
;; DESTROYS: (all)
;; ERRORS: yes.
;; NOTE: performs no validation of page number.
;; TODO: this should check if INRAM flag of page for writes.
zmap_fetchpage:
   call zaddr_pageent
zmap_fetchpage_ent:
   bit ZADDR_WRITE,b
   jr z,zmap_fetchpage.check_update    ; don't need to copy or move appvar for reads
   bit ZMAP_ENT_FLAGS_COPY,(ix+ZMAP_ENT_FLAGS)
   jr z,zmap_fetchpage.check_RAM
   ;; copy page and update flags
   ld hl,zemu_pagepfx
   call zmap_copypage_ent
   ret c
   set ZMAP_ENT_FLAGS_SAVE,(ix+ZMAP_ENT_FLAGS)
   jr zmap_fetchpage.addr        ; don't need to check for update
zmap_fetchpage.check_RAM:
   bit ZMAP_ENT_FLAGS_INRAM,(ix+ZMAP_ENT_FLAGS)
   call z,zmap_page_to_RAM
   jr zmap_fetchpage.addr
zmap_fetchpage.check_update:
   bit ZMAP_ENT_FLAGS_UPDATE,(ix+ZMAP_ENT_FLAGS)
   call nz,zmap_update_ent
zmap_fetchpage.addr:
   LD_HL_FROM_IX(ZMAP_ENT_PTR)
   or a,a
   ret


;; zmap_copypage -- copy page (used when write to page is read-only)
;; zmap_copypage_ent -- copy page, given pointer to entry
;; INPUTS:
;;  a = page number
;;  hl = name prefix
;;  ix = pointer to page entry in zmap (zmap_copypage_ent)
;; OUTPUTS:
;;  hl = pointer to zpage in RAM (skips over size bytes)
;;  current zmap updated
;; DESTROYS: (all) but ix
;; ERRORS: yes.
;; TODO: parameterize page naming.
;; *** portable ***
zmap_copypage:
   ;; get pointer to entry
   call zaddr_pageent
zmap_copypage_ent:
   ;; get src and dst var names
   ;; name page
   ld de,zmap_copypage.buf
   call zmap_namepage
   LEA_DE_IX(ZMAP_ENT_VARNAME)
   ex de,hl
   ;; copy appvar
   push ix
   call appvar_copy
   pop ix
   ret c
   inc hl   ; skip size bytes
   inc hl 
   ;; update zmap entry
   LD_HL_TO_IX(ZMAP_ENT_PTR)
   ld a,MASK(ZMAP_ENT_FLAGS_INRAM)
   ld (ix+ZMAP_ENT_FLAGS),a
   push hl
   ld hl,zmap_copypage.buf
   LEA_DE_IX(ZMAP_ENT_VARNAME)
   ld bc,VARNAMELEN
   call strncpy
   pop hl
   or a,a
   ret
zmap_copypage.buf: RESB(VARNAMELEN)

zemu_pagepfx: .db "ZEMUP",0

;; zmap_namepage -- rename page after being copied
;; INPUTS:
;;  hl = prefix
;;  a = page ID
;;  de = buffer (at least 8 chars)
;; OUTPUTS:
;;  hl = buffer
;; DESTROYS: a, bc, de
;; ERRORS: no.
;; *** portable ***
zmap_namepage:
   push de     ; buffer
   push af     ; ID
   ld bc,VARNAMELEN-2
   call strncpy
   pop af      ; ID
   ex de,hl
   ld b,a
   and a,$f0
   rrca
   rrca
   rrca
   rrca
   call xtoc
   ld (hl),a
   inc hl
   ld a,b
   and a,$0f
   call xtoc
   ld (hl),a
   inc hl
   ex de,hl
   ld hl,0
   call cp_hl_bc
   ex de,hl
   jr z,_
   ld (hl),0
_  pop hl
   ret

;; zmap_load -- load saved zmap into working zmap
;; INPUTS:
;;  hl = name of saved zmap (zmap_load)
;; OUTPUTS:
;;  touches & resizes working zmap and copies contents of saved zmap into it
;; DESTROYS: (all, including ix)
;; ERRORS: yes.
;; *** portable ***
zmap_load:
   ;; copy canonical zmap into temporary zmap
   ld de,zmap_name_current
   call appvar_copy
   ret c    ; ERROR
   call zmap_setptr
   ld ix,(zmap_header)
   call zmap_markupdate
   or a,a   ; SUCCESS
   ret

;; zmap_setptr -- update global zmap variables to point to zmap at given address
;; INPUTS:
;;  hl = pointer to zmap appvar
;; OUTPUTS: (none)
;; ERRORS: no (but always NC)
;; DESTROYS: hl, de
;; *** portable ***
zmap_setptr:
   ;; set global zmap pointers
   ld (zmap_appvar),hl
   inc hl
   inc hl
   ld (zmap_header),hl
   ld de,ZMAP_HDRSIZE
   add hl,de
   ld (zmap_table),hl
   ret

;; zmap_markupdate -- set all pages in given zmap as needing update
;; INPUTS:
;;  ix = zmap pointer
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: b, ix
zmap_markupdate:
   ld b,(ix+ZMAP_HDR_NPAGES)
   LEA_IX_IX(ZMAP_HDRSIZE)
zmap_markupdate.loop:
   set ZMAP_ENT_FLAGS_UPDATE,(ix+ZMAP_ENT_FLAGS)
   LEA_IX_IX(ZMAP_TABENTLEN)
   djnz zmap_markupdate.loop
zmap_markupdate.done:
   ret

;; zmap_update_ent -- update pointer in given page entry
;; INPUTS:
;;  ix = pointer to page entry in zmap
;; OUTPUTS:
;;  hl = pointer to page entry
;; ERRORS: yes.
;; DESTROYS: all but ix
;; *** portable ***
zmap_update_ent:
   LEA_HL_IX(ZMAP_ENT_VARNAME)
   push ix
   call appvar_find
   pop ix
   ret c
   ex de,hl
   inc hl
   inc hl
   LD_HL_TO_IX(ZMAP_ENT_PTR)
   res ZMAP_ENT_FLAGS_UPDATE,(ix+ZMAP_ENT_FLAGS)
   ;; update INRAM flag
   and a,MASK(ZMAP_ENT_FLAGS_INRAM)
   or a,(ix+ZMAP_ENT_FLAGS)
   ld (ix+ZMAP_ENT_FLAGS),a
zmap_update_ent.done:
   or a,a
   ret

;; zmap_page_to_RAM -- move page into RAM
;; INPUTS:
;;  ix = page entry
;; OUTPUTS:
;;  hl = page pointer
;;  page pointer updated in entry as well
;;  entry flags also updated
;; ERRORS: yes.
;; DESTROYS: all but ix
;; *** portable ***
zmap_page_to_RAM:
   push ix
   LEA_HL_IX(ZMAP_ENT_VARNAME)
   call appvar_to_RAM
   pop ix
   ex de,hl
   ret c
   LD_HL_TO_IX(ZMAP_ENT_PTR)
   set ZMAP_ENT_FLAGS_INRAM,(ix+ZMAP_ENT_FLAGS)
   res ZMAP_ENT_FLAGS_UPDATE,(ix+ZMAP_ENT_FLAGS)
   or a,a
   ret
   
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; ZMAP GLOBALS ;;;;;
;;;;;;;;;;;;;;;;;;;;;;;

zmap_appvar: DL 0
zmap_header: DL 0
zmap_table:  DL 0
zmap_name_canonical: RESB(VARNAMELEN)
zmap_name_current:   .db "ZEMUMAP",0

#include "zapp.z80"

#endif