;; zmem.z80 -- memory management for zemu & save states
;; TODO -- stack overflow?


ZMEM_SIZE .equ $2000

;; GLOBAL VARIABLES ;;

;; NOTE: stack grows up.
zstack_begin: .dl 0

zframe_begin:
zframe_fp: .dl 0
zframe_sp: .dl 0
zframe_pc: .dl 0
zframe_nl: .db 0
zframe_rv: .db 0
zframe_end:

;;

;; zmem_init -- initialize memory for zemu. Empty call state and program stack.
;; INPUTS: (none)
;; OUTPUTS:
;;  Sets zmem_appvar, zmem_callstate_top, zmem_stack_top.
;; ERROR: a = error code, CF set
;; DESTROYS: (all), OP1
;; TODO: check size bytes of appvar.
zmem_init:
   ; get appvar in RAM
   ld hl,zmem_name
   ld bc,ZMEM_SIZE+2 ; +2 for size bytes
   call appvar_touch
   ret c
   ex de,hl
   inc hl ; skip size bytes
   inc hl
   ld (zstack_begin),hl
   ld hl,0
   ld (zframe_fp),hl
   ld (zframe_sp),hl
   xor a,a
   ld (zframe_nl),a
   ld hl,ZADDR_NULL
   ld (zframe_pc),hl
   ret
   

zmem_name: .db "ZEMUMEM",0

;; zstack_enter -- enter new stack frame
;; INPUTS:
;;  a = number of local variables
;; OUTPUTS: (none)
;; DESTROYS: hl,de,ix
;; ERRORS: (none)
zstack_enter:
   push bc ; save variable number
   ; push new stack frame onto stack
   ld hl,(zstack_begin)
   push hl
   ld de,(zframe_sp)
   add hl,de
   ex de,hl
   ld hl,zframe_begin
   ld bc,ZFRAME_SIZE
   ldir
   pop bc
   ex de,hl
   or a,a
   sbc hl,bc
   ld (zframe_fp),hl
   MLT_A(ZWORD_SIZE, R_DE)
   add hl,de
   ld (zframe_sp),hl
   ; update number of locals (NL)
   ld (zframe_nl),a
   ; update return variable
   pop bc ; restore variable number
   ret   


;; zstack_leave -- leave current stack frame
;; INPUTS: (none)
;; OUTPUTS: (none)
;; DESTROYS: hl,bc,de,ix
;; ERRORS: yes.
zstack_leave:
   ; restore stack frame
   ld ix,(zframe_fp)
   ld de,(zstack_begin)
   add ix,de
   lea hl,ix-ZFRAME_SIZE
   ld de,zframe_begin
   ld bc,ZFRAME_SIZE
   ldir
   or a,a
   ret

