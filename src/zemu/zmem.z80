;; zmem.z80 -- memory management for zemu & save states
;; TODO -- stack overflow?


ZMEM_SIZE .equ $400 ; 1K -- absolute minimum is 1K by Z-machine standard

;; GLOBAL VARIABLES ;;

;; NOTE: stack grows up.
zstack_begin: DL 0

zframe_begin:
zframe_fp: DL 0   ; p-addr
zframe_sp: DL 0   ; p-addr
zframe_pc: DZA(0) ; z-addr
zframe_nl: .db 0
zframe_rv: .db 0
zframe_end:

;;

;; zmem_init -- initialize memory for zemu. Empty call state and program stack.
;; INPUTS: (none)
;; OUTPUTS:
;;  Sets zmem_appvar, zmem_callstate_top, zmem_stack_top.
;; ERROR: a = error code, CF set
;; DESTROYS: (all), OP1
;; TODO: check size bytes of appvar.
;; *** portable ***
zmem_init:
   ; get appvar in RAM
   ld hl,zmem_name
   ld bc,ZMEM_SIZE+2 ; +2 for size bytes
   call appvar_touch_trunc
   ret c
   ex de,hl
   inc hl ; skip size bytes
   inc hl
   ld (zstack_begin),hl
   ld hl,0
   ld (zframe_fp),hl
   ld (zframe_sp),hl
   xor a,a
   ld (zframe_nl),a
   LD_BHL_IMM(ZADDR_NULL)
   LD_BHL_TO_ABS_ZA(ZFRAME_PC)
   ret
   

zmem_name: .db "ZEMUMEM",0

;; zstack_enter -- enter new stack frame
;; INPUTS:
;;  a = number of local variables
;; OUTPUTS: (none)
;; DESTROYS: hl,de
;; ERRORS: (none)
;; *** portable ***
zstack_enter:
   push bc ; save variable number
   ; push new stack frame onto stack
   ld hl,(zstack_begin)
   push hl
   ld de,(zframe_sp)
   add hl,de
   ex de,hl
   ld hl,zframe_begin
   ld bc,ZFRAME_SIZE
   ldir
   pop bc
   ex de,hl
   or a,a
   sbc hl,bc
   ld (zframe_fp),hl
   MLT_A(ZWORD_SIZE, R_DE)
   add hl,de
   ld (zframe_sp),hl
   ; update number of locals (NL)
   ld (zframe_nl),a
   ; update return variable
   pop bc ; restore variable number
   ret


;; zstack_leave -- leave current stack frame
;; INPUTS: (none)
;; OUTPUTS: (none)
;; DESTROYS: (all),ix
;; ERRORS: yes.
;; *** portable ***
zstack_leave:
   ; restore stack frame
   ld ix,(zframe_fp)
   ld de,(zstack_begin)
   add ix,de
   LEA_HL_IX(-ZFRAME_SIZE)
   ld de,zframe_begin
   ld bc,ZFRAME_SIZE
   ldir
   or a,a
   ret
