#include "ti84pce.inc"

.assume ADL=1
.org userMem-2
.db tExtTok,tAsm84CeCmp

start:
   call _ClrScrnFull
   xor a
   ld (curRow),a
   ld (curCol),a

   ld hl,-100007
   ld de,-1000

   call cp_hl_de
   

   call div_hl_de
   push de
   push hl
   ld hl,str.div
   call _PutS
   pop hl
   call DispHL_signed
   call _NewLine
   ld hl,str.mod
   call _PutS
   pop hl
   call DispHL_signed
   ret   

str.div: .db "div:",0
str.mod: .db "mod:",0

DispHL_signed:
   ld (DispHL_signed.val),hl
   ld ix,DispHL_signed.val
   bit 7,(ix+2)
   jr z,DispHL_signed.pos
   ld a,'-'
   call _PutC
   ld hl,DispHL_signed.val
   ld b,3
   call memneg_short
DispHL_signed.pos:
   ld hl,(DispHL_signed.val)
   call _DispHL
   ret
   

DispHL_signed.val: .long 1


;; memcpl_short -- complement up to 256 bytes of memory
;; INPUTS:
;;  hl = pointer
;;  b = count
;; OUTPUTS:
;;  hl <- hl + b
;; DESTROYS: a, b, hl
memcpl_short:
memcpl_short.loop:
   ld a,(hl)
   cpl
   ld (hl),a
   inc hl
   djnz memcpl_short.loop
   ret

;; memneg_short -- negate up to 256 bytes of memory
;; INPUTS:
;;  hl = pointer
;;  b = count
;; OUTPUTS:
;; DESTROYS: a, bc, hl
memneg_short:
   ld c,b
   push hl
   call memcpl_short
   pop hl
memneg_short.loop:
   inc (hl)
   ret po ; no overflow
   inc hl
   dec c
   jr nz,memneg_short.loop
   ret

;; memset_short -- set up to 256 bytes of memory to a value
;; INPUTS:
;;  hl = pointer to memory
;;  b = count (in bytes)
;;  a = value
;; OUTPUTS:
;;  hl <- hl + b
;;  b <- 0
;; DESTROYS: hl, b
;; ERRORS: no.
memset_short:
memset_short.loop:
   ld (hl),a
   inc hl
   djnz memset_short.loop
   ret




;; div_hl_de -- divide hl by de using 24-bit signed division
;; INPUTS:
;;  hl (dividend), de (divisor)
;; OUTPUTS:
;;  hl <- hl / de
;;  de <- hl % de
;; DESTROYS: (all)
;; ERRORS: no???
;; TODO: divide by zero error
div_hl_de:
	xor a ; initialize A to store sign
div_hl_de.signs:
   ld (div_hl_de.hl),hl
   ld (div_hl_de.de),de
   ld hl,div_hl_de.hl
   ld b,3
   call memabs_short
   ld hl,div_hl_de.de
   ld b,3
   call memabs_short
   ld hl,(div_hl_de.hl)
   ld de,(div_hl_de.de)
div_hl_de.loopinit:
	push af ; save sign bit
	ld bc,0
	push bc ; initialize accumulator on stack
	xor a
	ld	b,24
div_hl_de.loop:
   ; INVARIANTS:
   ;  (sp) -- remainder
   ;  hl -- dividend
   ;  de -- divisor
	add hl,hl ; sets/resets carry flag for rl
	ex	(sp),hl
   adc hl,hl ; rl h \ rl l
	jr	c,div_hl_de.overflow
   call cp_hl_de
   jr c,div_hl_de.skip
div_hl_de.overflow:
   ; overflow and when rem > divisor
	xor a ; faster
	sbc	hl,de
	ex	(sp),hl
	inc	hl
	djnz	div_hl_de.loop
	jr div_hl_de.done
div_hl_de.skip:
	ex	(sp),hl
	djnz div_hl_de.loop
div_hl_de.done:
	pop de ; remainder?
	pop af ; restore sign of result
	or a
	ret z ; if positive, return result
   push de
	ex de,hl
	ld hl,0
	sbc hl,de ; else negate result
   ex de,hl
   pop bc ; restore remainder
   ld hl,0
   sbc hl,bc ; negate remainder
   ex de,hl
	ret

div_hl_de.hl: .dl 0
div_hl_de.de: .dl 0


;; memabs_short -- find absolute value of up to 256-byte integer in memory
;; INPUTS:
;;  hl = pointer to little endian integer in memory
;;  b = count (1 <= b <= 256)
;; OUTPUTS:
;;  if (hl) < 0, a <- ~a, (hl) <- ~(hl)
;; DESTROYS: (all)
;; ERRORS: no.
memabs_short:
   ld de,0
   ld e,b
   dec e
   add hl,de
   bit 7,(hl)
   ret z ; (hl) >= 0
   scf \ ccf
   sbc hl,de
   push af
   call memneg_short
   pop af
   xor a,$ff
   ret


;; cp_hl_de
cp_hl_de:
   scf \ ccf
   sbc hl,de
   push af
   add hl,de
   pop af
   ret
