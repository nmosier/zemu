#include "ti84pce.inc"
#include "zutil.inc"
#include "zerr.inc"

.assume ADL=1
.org userMem-2
.db tExtTok,tAsm84CeCmp

start:
   call _ClrScrnFull
   xor a
   ld (curRow),a
   ld (curCol),a

   ld hl,-100007
   ld de,-1000

   call cp_hl_de
   

   call div_hl_de
   push de
   push hl
   ld hl,str.div
   call _PutS
   pop hl
   call DispHL_signed
   call _NewLine
   ld hl,str.mod
   call _PutS
   pop hl
   call DispHL_signed
   ret   

str.div: .db "div:",0
str.mod: .db "mod:",0

DispHL_signed:
   call absl
   jr nc,_
   ld a,'-'
   call _PutC
_  jp _DispHL


;; div_hl_de -- divide hl by de using 24-bit signed division
;; INPUTS:
;;  hl (dividend), de (divisor)
;; OUTPUTS:
;;  hl <- hl / de
;;  de <- hl % de
;; DESTROYS: (all)
;; ERRORS: no???
;; TODO: divide by zero error
div_hl_de:
   ld bc,0
   ex de,hl
   or a,a ; reset CF
   sbc hl,bc ; cp de,bc
   ld a,ZERR_DIVZERO
   ccf
   ret z
   ex de,hl
	xor a ; initialize A to store sign
div_hl_de.signs:
   call absl
   jr nc,div_hl_de.signs.de
   cpl
div_hl_de.signs.de:
   ex de,hl
   call absl
   jr nc,div_hl_de.signs.done
   cpl
div_hl_de.signs.done:
   ex de,hl
div_hl_de.loopinit:
	push af ; save sign bit
	ld bc,0
	push bc ; initialize accumulator on stack
	xor a
	ld	b,24
div_hl_de.loop:
   ; INVARIANTS:
   ;  (sp) -- remainder
   ;  hl -- dividend
   ;  de -- divisor
	add hl,hl ; sets/resets carry flag for rl
	ex	(sp),hl
   adc hl,hl ; rl h \ rl l
	jr	c,div_hl_de.overflow
   call cp_hl_de
   jr c,div_hl_de.skip
div_hl_de.overflow:
   ; overflow and when rem > divisor
	xor a ; faster
	sbc	hl,de
	ex	(sp),hl
	inc	hl
	djnz	div_hl_de.loop
	jr div_hl_de.done
div_hl_de.skip:
	ex	(sp),hl
	djnz div_hl_de.loop
div_hl_de.done:
	pop de ; remainder?
	pop af ; restore sign of result
	or a
	ret z ; if positive, return result
   push de
	ex de,hl
	ld hl,0
	sbc hl,de ; else negate result
   ex de,hl
   pop bc ; restore remainder
   ld hl,0
   sbc hl,bc ; negate remainder
   ex de,hl
	ret

div_hl_de.hl: .dl 0
div_hl_de.de: .dl 0


;; cp_hl_de -- flags(hl - de)
;; INPUTS:
;;  hl, de
;; OUTPUTS:
;;  all flags
;; DESTROYS: (none)
;; ERRORS: no.
cp_hl_de:
   scf \ ccf
   sbc hl,de
   push af
   add hl,de
   pop af
   ret


;; cp_hl_de_sgn -- signed flags(hl - de)
;; TODO -- there must be a more elegant way to do this.
cp_hl_de_sgn:
   push ix
   ld ix,cp_hl_de_sgn.tab
cp_hl_de_sgn.lhs:
   call sgnl ; sign of lhs
   jr nc,cp_hl_de_sgn.rhs
   lea ix,ix+(2*3)
cp_hl_de_sgn.rhs:
   ex de,hl
   call sgnl
   ex de,hl
   jr nc,cp_hl_de_sgn.op
   lea ix,ix+(1*3)
cp_hl_de_sgn.op:
   jp (ix)

cp_hl_de_sgn.tab:
   .dl cp_hl_de_sgn.pp
   .dl cp_hl_de_sgn.pn
   .dl cp_hl_de_sgn.np
   .dl cp_hl_de_sgn.nn

cp_hl_de_sgn.pp:
   jp cp_hl_de
   
cp_hl_de_sgn.pn:
   push de
   ld de,0
   inc hl
   call cp_hl_de
   dec hl
   pop de
   ret

cp_hl_de_sgn.np:
   push hl
   ld hl,0
   inc de
   call cp_hl_de
   dec de
   pop hl
   ret

cp_hl_de_sgn.nn: ; flags(-1 - -2) == flags(1) == flags(2 - 1) 
   call negl
   ex de,hl
   call negl
   jp cp_hl_de


;; absl -- absolute value of long
;; INPUTS:
;;  hl = signed long
;; OUTPUTS:
;;  hl <- |hl|
;; DESTROYS: (none)
;; FLAGS: C if negative, NC otherwise
;; ERRORS: no.
absl:
   call sgnl
   jp c,negl ; flag: C
   ; flag: NC
   ret

;; sgnl -- sign of long
;; INPUTS:
;;  hl = long
;; OUTPUTS:
;;  C if negative
;;  NC if nonnegative
;; DESTROYS: (none)
;; ERRORS: no.
sgnl:
   push de
   ld de,LONG_MAX
   call cp_hl_de
   pop de
   ccf
   ret

;; negl -- negate long
;; INPUTS:
;;  hl = long
;; OUTPUTS:
;;  hl <- -hl
;; DESTROYS: (none)
;; ERRORS: no.
;; FLAGS: C if hl != 0
negl:
   push de
   ex de,hl
   ld hl,0
   or a,a
   sbc hl,de
   pop de
   ret
