
#include "zstr.inc"

;; sscanf -- scan characters
;; sscanf(char *buf, char *fmt, ...)
;; INPUTS: (arguments pushed on stack)
;; OUTPUTS:
;;  a = number of arguments assigned
;; DESTROYS:
;; ERRORS:
SSCANF.FLAGS.MODE .equ 0 ; 0 = regular, 1 = format
sscanf:
   push iy
   ld iy,3
   add iy,sp
   ld bc,0
   push bc ; parameters assigned
   ld hl,(iy+3) ; buf
   ld de,(iy+6) ; fmt
   lea iy,iy+9 ; pointer to first variable argument   
sscanf.loop:
   
sscanf.done:
   pop iy


sscanf.handle:
   

; compare loop
; expect hl = buf, de = fmt
sscanf.compare:
   ld a,(de)
   inc de
   ; check for format prefix
   cp a,'%'
   jr z,sscanf.format
   ; otherwise, check matches
   cp a,(hl)
   inc hl
   ret nz
   jr z,sscanf.compare

; format parser
; expect hl = buf, de = fmt, where (de-1) == '%'
; (the '%' has already been read)
; each format subhandler returns the number of arguments parsed and CF if error
sscanf.format:
   ld a,(de) ; the conversion char
   inc de
   ; switch on conversion type
   cp a,'%' ; literal %
   jr sscanf.format.pct
   cp a,'d' ; signed decimal integer
   jr sscanf.format.d
   ; todo

sscanf.format.pct:
   ; normal conversion -- go back to compare state
   dec de
   jr sscanf.compare

sscanf.format.d:
   ; read decimal integer
   push de
   ld a,10 ; base 10
   call strtol
   ld (iy),hl ; store even if invalid?
   ex de,hl
   pop de
   jr c,sscanf.format.error
   jr sscanf.format.done
   
sscanf.format.i:
   ; read integer of unspecified radix
   ;; TODO

sscanf.format.done:
   lea iy,iy+3
   pop bc
   inc bc
   push bc
   jp sscanf.compare

sscanf.format.error:
   scf
   jp sscanf.done



