; zaddr.z80 -- routines for zaddresses

;; zaddr_to_paddr -- convert logical address to physical CPU address.
;; INPUTS:
;;  hl = logical address
;;  zmap_header, zmap_table set
;; OUTPUTS:
;;  hl = physical address
;; ERROR: yes.
;; DESTROYS: (all)
zaddr_to_paddr:
   ld ix,(zmap_header)
zaddr_to_paddr.check_size:
   push hl
   ld de,(ix+ZMAP_HDR_STORYSIZE)
   call cp_hl_de
   pop hl
   ld a,ZERR_BADADDR
   ccf
   ret c ; if logaddr >= storysize, then bad addr
zaddr_to_paddr.page_num:
   ld e,(ix+ZMAP_HDR_PAGEMASK)
   ld d,(ix+ZMAP_HDR_PAGEMASK+1)
   ; and hl,~de => page number * page size
   push hl
   push de
   ld a,d
   cpl
   and h
   ld d,a
   ld a,e
   cpl
   and l
   ld e,a
   ; NOTE: we don't need to invert the highest bit of de
   ; because it will always be 0 (since page sizes are less
   ; than 0xffff).
   ld b,(ix+ZMAP_HDR_PAGEBITS)
   ld (zaddr_to_paddr.long),hl ; need to get upper byte
   ld hl,zaddr_to_paddr.long+2
zaddr_to_paddr.page_num_shift:
   ; (zaddr_to_paddr.long+2):d:e >>= 1
   srl (hl)
   rr d
   rr e
   djnz zaddr_to_paddr.page_num_shift
   ld a,e
zaddr_to_paddr.page_ent:
   call zmap_fetchpage
   pop bc ; page mask
   pop de ; offset
   ret c
zaddr_to_paddr.get_offset:
   ;; NOTE: since the zpage size is less than 2^16,
   ;; the offset will be contained in the lower 16 bits
   ;; of register de.
   ; de <- bc & de
   ld a,b
   and d
   ld d,a
   ld a,c
   and e
   ld e,a
   add hl,de ; hl = physical address
   scf \ ccf
   ret

zaddr_to_paddr.long: .dl 0

;; TODO: consider parameterizing zaddr_fetch and zaddr_store,
;;       since they only differ by a single instruction?

;; zaddr_fetch -- fetch byte at logical address
;; INPUTS:
;;  hl = zaddr (logical address)
;; OUTPUTS:
;;  a = byte at zaddr
;;  hl <- hl + 1
;; ERROR: yes.
;; DESTROYS: everything but de
zaddr_fetch:
   push hl
   push de
   call zaddr_to_paddr
   ex de,hl
   pop hl
   jr c,zaddr_fetch.cleanup
   ld a,(de) ; load byte
   inc hl  ; update ptr
   ; C reset (nc)
zaddr_fetch.cleanup:
   pop de
   ret

;; zaddr_store -- store byte at logical address
;; INPUTS:
;;  hl = zaddr (logical address)
;; OUTPUTS:
;;  a = byte to store at zaddr
;;  hl <- hl + 1
;; ERROR: yes.
;; DESTROYS: everything but de
zaddr_store:
   push hl
   push de
   call zaddr_to_paddr
   ex de,hl
   pop hl
   jr c,zaddr_fetch.cleanup
   ld (de),a ; store byte
   inc hl ; update ptr
   ; C reset (nc)
zaddr_store.cleanup:
   pop de
   ret

;; zaddr_fetchw -- fetch big-endian word at logical address
;; INPUTS:
;;  hl = logical address
;; OUTPUTS:
;;  hl <- hl + 2
;;  de[15:0] = word
;; ERRORS: yes.
;; DESTROYS: (all)
zaddr_fetchw:
   call zaddr_fetch
   ld e,a
   call nc,zaddr_fetch
   ld d,a
   ret ; errflg set
