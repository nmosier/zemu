; zaddr.z80 -- routines for zaddresses

#include "zemu.inc"
#include "zhdr.inc"
#include "zutil.inc"

;; zaddr_to_paddr -- convert logical address to physical CPU address.
;; INPUTS:
;;  hl = logical address
;;  zmap_header, zmap_table set
;; OUTPUTS:
;;  hl = physical address
;; ERROR: yes.
;; DESTROYS: (all)
zaddr_to_paddr:
   ld ix,(zmap_header)
zaddr_to_paddr.check_size:
   push hl
   ld de,(ix+ZMAP_HDR_STORYSIZE)
   call cp_hl_de
   pop hl
   ld a,ZERR_BADADDR
   ccf
   ret c ; if logaddr >= storysize, then bad addr
zaddr_to_paddr.page_num:
   ld de,0
   ld e,(ix+ZMAP_HDR_PAGEMASK)
   ld d,(ix+ZMAP_HDR_PAGEMASK+1)
   ; and hl,~de => page number * page size
   push hl
   push de
   ld a,d
   cpl
   and h
   ld d,a
   ld a,e
   cpl
   and l
   ld e,a
   ; NOTE: we don't need to invert the highest bit of de
   ; because it will always be 0 (since page sizes are less
   ; than 0xffff).
   ld b,(ix+ZMAP_HDR_PAGEBITS)
   ld (zaddr_to_paddr.long),hl ; need to get upper byte
   ld hl,zaddr_to_paddr.long+2
zaddr_to_paddr.page_num_shift:
   ; (zaddr_to_paddr.long+2):d:e >>= 1
   srl (hl)
   rr d
   rr e
   djnz zaddr_to_paddr.page_num_shift
   ld a,e
zaddr_to_paddr.page_ent:
   call zmap_fetchpage
   pop de ; page mask
   pop bc ; offset
   ret c
zaddr_to_paddr.get_offset:
   ;; NOTE: since the zpage size is less than 2^16,
   ;; the offset will be contained in the lower 16 bits
   ;; of register de.
   ; de <- bc & de
   ld a,b
   and d
   ld d,a
   ld a,c
   and e
   ld e,a
   add hl,de ; hl = physical address
   scf \ ccf
   ret

zaddr_to_paddr.long: .dl 0

;; TODO: consider parameterizing zaddr_fetch and zaddr_store,
;;       since they only differ by a single instruction?

;; zaddr_fetch -- fetch byte at logical address
;; INPUTS:
;;  hl = zaddr (logical address)
;; OUTPUTS:
;;  a = byte at zaddr
;;  hl <- hl + 1
;; ERROR: yes.
;; DESTROYS: everything but de
zaddr_fetch:
   push de
   push hl
   call zaddr_to_paddr
   ex de,hl
   pop hl
   jr c,zaddr_fetch.cleanup
   ld a,(de) ; load byte
   inc hl  ; update ptr
   ; C reset (nc)
zaddr_fetch.cleanup:
   pop de
   ret

;; zaddr_store -- store byte at logical address
;; INPUTS:
;;  hl = zaddr (logical address)
;; OUTPUTS:
;;  a = byte to store at zaddr
;;  hl <- hl + 1
;; ERROR: yes.
;; DESTROYS: everything but de
zaddr_store:
   push hl
   push de
   call zaddr_to_paddr
   ex de,hl
   pop hl
   jr c,zaddr_fetch.cleanup
   ld (de),a ; store byte
   inc hl ; update ptr
   ; C reset (nc)
zaddr_store.cleanup:
   pop de
   ret

;; zaddr_fetchw -- fetch big-endian word at logical address
;; INPUTS:
;;  hl = logical address
;; OUTPUTS:
;;  hl <- hl + 2
;;  de = word, sign-extended
;; ERRORS: yes.
;; DESTROYS: (all)
zaddr_fetchw:
   call zaddr_fetch
   ret c
   ld e,a
   call zaddr_fetch
   ret c
   ld d,a
   push hl
   ex de,hl
   call wtols ; upcast
   ex de,hl
   pop hl
   scf \ ccf
   ret

;; zaddr_fetchwu -- fetch unsigned word at logical address
zaddr_fetchwu:
   call zaddr_fetch
   ret c
   ld d,a
   call zaddr_fetch
   ret c
   ld e,a
   push hl
   ex de,hl
   call wtolu ; upcast
   pop hl
   scf \ ccf
   ret

;; zaddr_fetchb -- fetch byte at logical address and sign-extend
;; INPUTS:
;;  hl = logical address
;; OUTPUTS:
;;  hl <- hl + 1
;;  de = byte, sign-extended
;; ERRORS: yes.
;; DESTROYS: (all)
zaddr_fetchb:
   call zaddr_fetch
   ret c
   ex de,hl
   call btols
   ex de,hl
   scf \ ccf
   ret


;; zaddr_unpack -- convert packed address to byte address
;; INPUTS:
;;  hl = packed address
;; OUTPUTS:
;;  hl = byte address
;; ERRORS: no.
;; DESTROYS:
zaddr_unpack:
   add hl,hl
   ret
