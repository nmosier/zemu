; zaddr.z80 -- routines for zaddresses

;; zaddr_to_phys -- convert logical address to physical CPU address.
;; INPUTS:
;;  hl = logical address
;;  zmap_header, zmap_table set
;; OUTPUTS:
;;  hl = physical address
;; TODO: check if logical addr < story size, then don't need to do page # checks.
zaddr_to_phys:
   ld ix,(zmap_header)
zaddr_to_phys.check_size:
   push hl
   ld de,(ix+ZMAP_HDR_STORYSIZE)
   call cp_hl_de
   pop hl
   ld a,ZERR_BADADDR
   ccf
   ret c ; if logaddr >= storysize, then bad addr
zaddr_to_phys.page_num:
   ld e,(ix+ZMAP_HDR_PAGEMASK)
   ld d,(ix+ZMAP_HDR_PAGEMASK+1)
   ; and hl,~de => page number * page size
   push hl
   push de
   ld a,d
   cpl
   and h
   ld d,a
   ld a,e
   cpl
   and l
   ld e,a
   ; NOTE: we don't need to invert the highest bit of de
   ; because it will always be 0 (since page sizes are less
   ; than 0xffff).
   ld b,(ix+ZMAP_HDR_PAGEBITS)
   ld (zaddr_to_phys.long),hl ; need to get upper byte
   ld hl,zaddr_to_phys.long+2
zaddr_to_phys.page_num_shift:
   ; (zaddr_to_phys.long+2):d:e >>= 1
   srl (hl)
   rr d
   rr e
   djnz zaddr_to_phys.page_num_shift
   ld a,e
zaddr_to_phys.page_ent:
   call zmap_fetchpage
   pop bc ; page mask
   pop de ; offset
   ret c
zaddr_to_phys.get_offset:
   ;; NOTE: since the zpage size is less than 2^16,
   ;; the offset will be contained in the lower 16 bits
   ;; of register de.
   ; de <- bc & de
   ld a,b
   and d
   ld d,a
   ld a,c
   and e
   ld e,a
   add hl,de ; hl = physical address
   scf \ ccf
   ret

zaddr_to_phys.long: .dl 0


