;; zcode.z80
;; Nicholas Mosier 2019

ZOPCODE_TYPE_H .equ 7
ZOPCODE_TYPE_L .equ 6
ZOPCODE_EXTENDED .equ $be

Z_2OP .equ 2
Z_1OP .equ 1
Z_0OP .equ 0
Z_VAR .equ -1

ZOP_OMITTED .equ $03
ZOP_VARIABLE .equ $02
ZOP_SMALL .equ $01
ZOP_LARGE .equ $00

;; zcode_decode -- decode single instruction
;; INPUTS:
;;  hl = zaddr of instruction (logical address)
;; OUTPUTS:
;; ERROR:
;; DESTROYS:
zcode_decode:
   ; fetch first byte
   call zaddr_fetch
   ret c ; addr translation error
zcode_decode.type:
   ; determine opcode type
   cp ZOPCODE_EXTENDED
   jp z,zcode_decode_extended
   bit ZOPCODE_TYPE_H,a
   jp z,zcode_decode_long ; $$0x -> long
   bit ZOPCODE_TYPE_L,a
   jp z,zcode_decode_short ; $$10
   jp nz,zcode_decode_variable ; $$11
   ;--;

;; Each of these functions (zcode_decode_{short,long,variable})
;; decode and execute the instruction. Never called directly.
;; Upon entry, a = first byte of opcode.
zcode_decode_short:
   ; 4.3.1 opcode count is given by bits 4-5. $$11 = 0OP, otherwise 1OP.
   ld b,a
   rrca
   rrca
   rrca
   rrca
   and $03
   ld (zcode_decode.optype),a
   ; fetch operand
   ;; TODO: write function for doing this.
   ; 4.3.1 opcode number given in bottom 4 bits.
   ld a,b
   and $0f
   ld c,a
zcode_decode_short.opnumset:
   ; 4.4.1 bits 4-5 also give the operand type.
   ; fetch operand and type
   

zcode_decode.optype: .db 0
zcode_decode.opval: .dl 0
   

zcode_decode_long:
   ; 4.3.2 opcode count is always 2OP
   ld b,Z_2OP
zcode_decode_long.opcntset:
   and a,$1f
   ld c,a
zcode_decode_long.opnumset:
   ;; TODO


zcode_decode_variable:
   ; 4.3.3 if bit 5 is 0, then 2OP; otherwise VAR
   ld b,Z_2OP
   bit 5,a
   jr z,zcode_decode_variable.opcntset
   ld b,Z_VAR
zcode_decode_variable.opcntset:
   and a,$1f
   ld c,a
zcode_decode_variable.opnumset:
   ;; TODO



;;-- NOT SUPPORTED --;;

;; TODO: support extended opcodes.
zcode_decode_extended:
   ld a,ZERR_NOTAVAIL
   ret c ; NOT SUPPORTED YET
   ; 4.3.4 opcode count is VAR
   ld b,Z_VAR
zcode_decode_extended.opcntset:
   ld c,a
   push bc
   call zaddr_fetch
   pop bc
   ret c ; error
   ld d,c
   ld c,a
   ld a,d ;; swp a,c
zcode_decode_extended.opnumset:
   ;; TODO


;; zcode_fetch_op -- fetch operand from logical address.
;; INPUTS:
;;  hl = zaddr of operand
;;  a = operand type
;; OUTPUTS:
;;  de = operand (if large or variable value)
;;  a = small 
;;  hl points to byte after operand
;; ERRORS: yes.
zcode_fetch_op:
   cp ZOP_LARGE
   jp z,zcode_fetch_op.large
   cp ZOP_SMALL
   jp z,zcode_fetch_op.small
   cp ZOP_VARIABLE
   jp z,zcode_fetch_op.variable
   jp zcode_fetch_op.omitted

;; TODO: I changed the above function; need to verify that subroutines all obey
;;       invariants.

;; NOTE: result contained in de.
zcode_fetch_op.large:
   ex de,hl
   call zaddr_fetch
   ret c
   ld d,a
   push de
   call zaddr_fetch
   pop de
   ret c
   ld e,a
   scf \ ccf
   ret

;; NOTE: result contained in a.
zcode_fetch_op.small:
   ex de,hl
   call zaddr_fetch
   ret c
   scf \ ccf
   ret

;; NOTE: result contained in de
zcode_fetch_op.variable:
   ex de,hl
   call zaddr_fetch ; hl++
   ret c
   ; fetch variable value
   call zvar_fetch ; hl++
   ret c
   scf \ ccf
   ret

zcode_fetch_op.omitted:
   ex de,hl
   scf \ ccf
   ret

ZVAR_STACK .equ 0
ZVAR_LOCALMIN .equ 1
ZVAR_GLOBALMIN .equ 16

;; zvar_localaddr -- get address of local variable
;; INPUTS:
;;  a = local variable number
;; OUTPUTS:
;;  hl = pointer to local variable
;; DESTROYS: a,de
;; ERRORS: yes. (Checks bounds of var num)
zvar_localaddr:
   ; validate var num
   dec a
   ld de,2
   ld d,a
   ld hl,zframe_nl
   cp (hl)
   ld a,ZERR_NOLOCL
   ret c
   ; calculate address
   mlt de
   ld hl,(zframe_fp)
   add hl,de
   scf \ ccf ; success
   ret

;; zvar_globaladdr -- get address of global variable
;; INPUTS:
;;  a = global variable number
;; OUTPUTS:
;;  hl = logical address of global variable
;; ERRORS: (none)
;; DESTROYS: hl,ix
zvar_globaladdr:
   sub ZVAR_GLOBALMIN
   ld ix,(zmap_header)
   lea hl,ix
   ld de,2
   ld d,a
   mlt de
   add hl,de
   ld d,(ix+ZHDR_GLOBALS)
   ld e,(ix+ZHDR_GLOBALS+1)
   add hl,de
   ret

;; zvar_fetch -- fetch variable value.
;; INPUTS:
;;  a = variable number
;; OUTPUTS:
;;  hl = variable value (16-bit)
zvar_fetch:
   cp ZVAR_STACK
   jp z,zvar_fetch.stack
   cp ZVAR_GLOBALMIN
   jp c,zvar_fetch.local
   jp zvar_fetch.global

zvar_fetch.stack:
   ; check if stack is empty
   ld de,(zframe_sp)
   ld hl,(zframe_fp)
   call cp_hl_de  ; fp < sp <=> C
   ccf
   ld a,ZERR_STACKEMPTY
   ret c
   ; get value
   ex de,hl
   dec hl
   ld e,(hl)
   dec hl
   ld d,(hl)
   ; update stack ptr
   ld (zframe_sp),hl
   scf \ ccf
   ret

zvar_fetch.local:
   ; get addr of local var (on stack)
   dec a
   call zvar_localaddr
   ret c ; error
   ; load var
   ld d,(hl)
   inc hl
   ld e,(hl)
   ex de,hl
   scf \ ccf
   ret

zvar_fetch.global:
   call zvar_globaladdr
   call zaddr_fetch ; hl += 1
   ret c ; fetch error
   ld d,a
   call zaddr_fetch
   ret c
   ld e,a
   ex de,hl
   ; C reset (nc)
   ret

;; zvar_store -- store value to variable
;; INPUTS:
;;  a = variable number
;;  hl = value to store
;; ERRORS: yes.
zvar_store:
   ex de,hl
   cp ZVAR_STACK
   jp z,zvar_store.stack
   cp ZVAR_GLOBALMIN
   jp c,zvar_store.local
   jp zvar_store.global

zvar_store.stack:
   ld hl,(zframe_sp)
   ld (hl),d
   inc hl
   ld (hl),e
   inc hl
   ld (zframe_sp),hl
   scf \ ccf
   ret

zvar_store.local:
   ; get addr
   dec a
   push de
   call zvar_localaddr
   pop de
   ret c ; error
   ; store val
   ld (hl),d
   inc hl
   ld (hl),e
   scf \ ccf
   ret

zvar_store.global:
   push hl
   call zvar_globaladdr
   pop de
   ld a,d
   call zaddr_store ; hl++
   ret c
   ld a,e
   call zaddr_store ; hl++
   ret c
   ret