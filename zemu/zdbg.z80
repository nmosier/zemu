;; zdbg.z80 -- debugging routines

#include "zdbg.inc"

;; zdbg_init -- initialize debugger
;; INPUTS: (none)
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: hl, a
zdbg_init:
   ld hl,zdbg_flags
   res ZDBG_FLAGS_STEP,(hl)
   res ZDBG_FLAGS_BREAK,(hl)
   set ZDBG_FLAGS_MODE,(hl)
   set ZDBG_FLAGS_INTR,(hl)
   set ZDBG_FLAGS_STAT,(hl)
   set ZDBG_FLAGS_STACK,(hl)
   xor a,a
   ld (zdbg_alerts),a
   ret

;; zdbg_puts -- put string in debug line
;; NOTE: clears line first.
zdbg_puts:
   push ix \ push de \ push bc
   push hl
   ld ix,win_dbgout
   call zwin_clear
   pop hl
   push hl
   call zwin_puts
   pop hl
   pop bc \ pop de \ pop ix
   ret

;; zdbg_step -- do stuff before instruction is executed
zdbg_step:
   bit ZDBG_FLAGS_STAT,(ix)
   call nz,zdbg_status
   bit ZDBG_FLAGS_STACK,(ix)
   call nz,zdbg_disp_stack
   bit ZDBG_FLAGS_INTR,(ix)
   ld a,0
   call nz,_GetKey
   cp a,kClear
   jr z,zdbg_step.intr
   cp a,kEnter
   jr z,zdbg_step.run
   JCLASS(k0,k9,zdbg_step.num)
   cp a,kAdd ; read command
   jr z,zdbg_step.cmd
   or a,a
   jr zdbg_step.done

zdbg_step.run:
   res ZDBG_FLAGS_MODE,(ix)
   jr zdbg_step.done

zdbg_step.num:
   sub a,k0
   jr nz,_
   ld a,10
_  ld (zdbg_stepn),a
   jr  zdbg_step.done

zdbg_step.done:
   res ZDBG_FLAGS_STEP,(ix)
   ret
   
zdbg_step.intr:
   ld a,ZERR_INTR
   scf
   jr zdbg_step.done

zdbg_step.cmd:
   ld hl,zdbg_step.cmd_buf
   ld bc,32
   call zdbg_getsn
   call zdbg_cmd
   jr zdbg_step.done

zdbg_step.cmd_buf: RESB(32)



;; zdbg_cmd -- parse command
;; INPUTS:
;;  hl = command string
;; OUTPUTS:
;;  CF = whether failed
;;  ix = zdbg_flags
;; ERRORS: no.
;; DESTROYS: (all)
zdbg_cmd:
   ld ix,zdbg_flags
   ld a,(hl)
   inc hl
   cp a,'B'
   jr z,zdbg_cmd.break
   cp a,'W'
   jr z,zdbg_cmd.watch
   cp a,'D'
   jr z,zdbg_cmd.disable
   cp a,'P'
   jr z,zdbg_cmd.print
   or a,a
   ret

zdbg_cmd.break:
   ld a,16
   call strtoul ; to hex
   ccf
   ret nc ; failed to convert
   ld (zdbg_break),hl
   ex de,hl
   ld ix,zdbg_flags
   set ZDBG_FLAGS_BREAK,(ix)
   or a,a ; NC
   ret

zdbg_cmd.watch:
   ld a,16 ; hex
   call strtoul ; to i
   ccf
   ret nc
   ld a,l
   ld l,0
   call cp_hl_0
   ret nz
   ld (zdbg_watch),a
   ld ix,zdbg_flags
   set ZDBG_FLAGS_WATCH,(ix)
   or a,a
   ret ; NC

zdbg_cmd.disable:
   ; which to disable?
   ld a,(hl)
   inc hl
   cp a,'B' ; disable breakpoints?
   jr z,zdbg_cmd.disable.break
   cp a,'W' ; disable watchpoints?
   jr z,zdbg_cmd.disable.watch
zdbg_cmd.disable.done:
   or a,a
   ret
zdbg_cmd.disable.break:
   res ZDBG_FLAGS_BREAK,(ix)
   jr zdbg_cmd.disable.done
zdbg_cmd.disable.watch:
   res ZDBG_FLAGS_WATCH,(ix)
   jr zdbg_cmd.disable.done


zdbg_cmd.print:
   ; print variable
   ld a,16 ; hex
   call strtoul
   ccf
   ret nc
   ld a,l
   ld l,0
   call cp_hl_0
   ret nz
   ; fetch variable
   call zvar_fetch
   ; format
   push hl ; value
   ld hl,zdbg_cmd.print.fmt
   push hl ; format
   ld hl,zdbg_cmd.print.buf
   push hl ; buffer
   call _sprintf
   pop hl \ pop hl \ pop hl
   ld hl,zdbg_cmd.print.buf
   call zdbg_puts
   call _GetKey ; TODO: should have its own window
   or a,a
   ret

zdbg_cmd.print.buf: RESB(8)
zdbg_cmd.print.fmt: .db " %4x",0

;; zdbg_status -- display status information
zdbg_status:
   ; watchpoint status info
   push ix
   ld ix,ZDBG_ALERTS
   bit ZDBG_ALERTS_WATCH,(ix)
   ld hl,emptystr
   jr z,_
   res ZDBG_ALERTS_WATCH,(ix)
   ld hl,zdbg_alert_watch.str
_  push hl ; arg4
   ld hl,(zframe_pc)
   push hl ; arg3
   ld hl,zdbg_status.fmt
   push hl ; arg2
   ld hl,zdbg_status.buf
   push hl ; arg1
   call _sprintf
   pop hl \ pop hl \ pop hl \ pop hl
   ld hl,zdbg_status.buf
   call zdbg_puts
   pop ix
   ret

zdbg_status.buf: RESB(32)
zdbg_status.fmt: .db "%x %s",0   ; PC [WATCH]

;; zdbg_exec -- run ZCPU in debugging mode
;; INPUTS:
;;  zdbg_flags set
;; OUTPUTS:
;; DESTROYS:
;; ERRORS: yes.
zdbg_exec:
   ld ix,zdbg_flags
   ;res ZDBG_FLAGS_STEP,(ix)
   
zdbg_exec.frame:
   ; 0. Check if exit frame has been reached.
   call zdbg_stkcmp
   ld hl,(zframe_pc)
   jp z,zdbg_exit

zdbg_exec.break:
   ; 1. Check if should break.
   bit ZDBG_FLAGS_BREAK,(ix)
   jr z,_
   call zdbg_brkcmp
   jr nz,zdbg_exec.mode
   set ZDBG_FLAGS_STEP,(ix)
   set ZDBG_FLAGS_MODE,(ix) ; back to step mode
_
zdbg_exec.alerts:
   ; 1.5 Check for alerts.
   ld a,(zdbg_alerts)
   or a,a
   jr z,_
   set ZDBG_FLAGS_STEP,(ix)
   set ZDBG_FLAGS_MODE,(ix) ; back to step mode
_
zdbg_exec.mode:
   ; 2. Check mode.
   bit ZDBG_FLAGS_MODE,(ix)
   jr z,zdbg_exec.step

zdbg_exec.stepn:
   ld de,zdbg_stepn
   ld a,(de)
   or a,a
   jr nz,zdbg_exec.stepn_dec
   set ZDBG_FLAGS_STEP,(ix)
   jr zdbg_exec.step

zdbg_exec.stepn_dec:
   dec a
   ld (de),a

zdbg_exec.step:
   or a,a
   bit ZDBG_FLAGS_STEP,(ix)
   call nz,zdbg_step
   ld hl,(zframe_pc)
   jr c,zdbg_exit

zdbg_exec.instr:
   push hl
   call zcode_decode
   pop hl
   jp c,zdbg_exit
   jr zdbg_exec

;; zdbg_brkcmp -- check if should break -- stored in ZF
zdbg_brkcmp:
   ld de,(zdbg_break)
   ld hl,(zframe_pc)
   jp cp_hl_de

zdbg_stkcmp:
   ld de,(zframe_fp)
   ld hl,(zdbg_frame)
   jp cp_hl_de



;; zdbg_exit -- handle errors during execution
;; INPUTS:
;;  hl = PC, i.e. addr of instruction that triggered error
;;  zdbg_prev contains previous PC
;; OUTUPTS:
;; DESTROYS:
;; ERRORS:
zdbg_exit:
   push af
   ld de,zdbg_exit.buf
   call hexstr
   ld hl,zdbg_exit.buf
   call zdbg_puts
   pop af
   ret

zdbg_exit.buf: RESB(32)

;; zdbg_readaddr -- read address
;; INPUTS:
;; OUTPUTS:
;;  hl = address
;; DESTROYS:
;; ERRORS:
zdbg_readaddr:
   ld hl,zdbg_readaddr.buf
   ld bc,16
   call zdbg_getsn
   ex de,hl
   ld hl,0
   ld a,c
   ld b,c
   or a,a
   ret z
zdbg_readaddr.loop:
   ld a,(de)
   inc de
   or a,a
   ret z
   JCLASS('0', '9', zdbg_readaddr.digit)
   JCLASS('A', 'F', zdbg_readaddr.letter)
   ret

zdbg_readaddr.digit:
   sub a,'0'
   jr zdbg_readaddr.shift

zdbg_readaddr.letter:
   sub a,'A'-10
   jr zdbg_readaddr.shift

zdbg_readaddr.shift:
   add hl,hl
   add hl,hl
   add hl,hl
   add hl,hl
   or a,l
   ld l,a
   djnz zdbg_readaddr.loop



zdbg_readaddr.buf: RESB(16)
;; zdbg_gets -- get string
;; INPUTS:
;;  hl = pointer to output buffer
;;  bc = count
;; OUTPUTS:
;;  hl = pointer to output buffer
;;  bc = count read
;; DESTROYS: all bux ix
;; ERRORS: no.
;; NOTE: only supports A-Z, 0-9.
zdbg_getsn:
   push ix
   ld ix,win_dbgin
   push hl \ push bc
   call zwin_clear
   pop bc \ pop hl
   call zwin_getsn
   pop ix
   ret


;; zdbg_watch_hook -- check if var was accessed
;; INPUTS:
;;  hl = value
;;  a = var
;;  CF = read or write (NC = read, C = write)
;; OUTPUTS:
;; ERRORS:
;; DESTROYS: (none)
zdbg_watch_hook:
   push af
   push hl
   push de
   push bc
   push ix
   push iy
   ; set r/w char
   ld c,'r'
   jr nc,_
   ld c,'w'
_  ; check if watched var
   ld iy,0 ; set up stack
   add iy,sp
   ex de,hl
   ld hl,zdbg_watch
   cp a,(hl)
   ex de,hl
   jr nz,zdbg_watch_hook.done ; not watched
   ; watched
   push hl ; arg5
   push bc ; arg4
   ld de,0
   ld e,a
   push de ; arg3
   ld de,zdbg_watch_hook.fmt
   push de ; arg2
   ld de,zdbg_alert_watch.str
   push de
   call _sprintf
   ld sp,iy ; remove args from stack
   ld hl,zdbg_alerts
   set ZDBG_ALERTS_WATCH,(hl)
zdbg_watch_hook.done:
   pop iy
   pop ix
   pop bc
   pop de
   pop hl
   pop af
   ret

zdbg_watch_hook.fmt: .db "%2x/%c/%4x",0


ZDBG_DISP_STACK.SPACE .equ 3 * (4 + 1)
;; zdbg_disp_stack -- display stack
;; INPUTS: (none)
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: (all), ix
zdbg_disp_stack:
   push ix
   push iy
   ld iy,0
   add iy,sp
   lea hl,iy-ZDBG_DISP_STACK.SPACE
   ld sp,hl
   ld ix,win_dbgstack
   call zwin_clear
   ld hl,(zframe_fp) ; (points to first local)
   ld a,(zframe_nl) ; fetch number of locals to skip over
   sla a ; multiply by 2
   ld de,0
   ld e,a
   add hl,de ; hl points to first stack entyr
   jr zdbg_disp_stack.entry
zdbg_disp_stack.loop:
   ld (iy-9),de ; arg3
   ld de,0
   ld d,(hl)
   inc hl
   ld e,(hl)
   inc hl
   ld (iy-3),hl ; loc1 -- save iterator
   ld (iy-6),de ; arg4
   ld hl,zdbg_disp_stack.fmt
   ld (iy-12),hl ; arg2
   ld hl,zdbg_disp_stack.buf
   ld (iy-15),hl ; arg1
   call _sprintf
   ; print result
   ld ix,win_dbgstack
   ld hl,zdbg_disp_stack.buf
   push iy
   ld iy,flags
   call zwin_puts_bare
   call zwin_newline
   pop iy
   ; restore iterator
   ld hl,(iy-3) ; loc1
zdbg_disp_stack.entry:
   ld de,(zframe_sp) ; end
   or a,a ; NC
   ex de,hl
   sbc hl,de
   ex de,hl
   jr nz,zdbg_disp_stack.loop
zdbg_disp_stack.done:
   ld sp,iy
   pop iy
   pop ix
   ret

zdbg_disp_stack.buf: RESB(16)
zdbg_disp_stack.fmt: .db "%2x: %4x",0


;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; DEBUGGING GLOBALS ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

zdbg_flags:  .db 0
zdbg_alerts: .db 0
zdbg_break:  .dl 0 ; address to break at
zdbg_frame:  .dl 0 ; frame to return once reached
zdbg_stepn:  .db 0 ; number to step before breaking?
zdbg_watch:  .db 0 ; variable to watch

zdbg_alert_watch.str: RESB(16)
