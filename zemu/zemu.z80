#include "ti84pce.inc"
.assume ADL=1
.org userMem-2

VARNAMELEN .equ 8
ZMAP_TABENTLEN .equ (VARNAMELEN + 1 + 3) ; this should be manually updated

ZMAP_HDR_HEADERSIZE .equ 0
ZMAP_HDR_PAGESIZE .equ ZMAP_HDR_HEADERSIZE + 1
ZMAP_HDR_STORYSIZE .equ ZMAP_HDR_PAGESIZE + 2
ZMAP_HDR_NPAGES .equ ZMAP_HDR_STORYSIZE + 3

ZMAP_ENT_VARNAME .equ 0
ZMAP_ENT_FLAGS .equ ZMAP_ENT_VARNAME + VARNAMELEN
ZMAP_ENT_PTR .equ ZMAP_ENT_FLAGS + 1

ZMAP_ENT_FLAGS_INRAM .equ 0

.db tExtTok, tAsm84CeCmp


start:
   ld hl,zork_zmap
   call zemu_init
   ret

; perform initial setup of zemu
; INPUTS:
;  - hl = pointer to name of zmap appvar (should be 8 bytes)
zemu_init:
   ; save bottom of stack for early exits
   ld (zemu_stackbottom),sp
   ; find zmap appvar
   call appvar_to_OP1
   call _ChkFindSym
   jp c,_ErrInvalid  ; zmap appvar not found
   ; store zmap pointers
   ex de,hl
   ld (zmap_appvar),hl      ; store zmap ptr
   inc hl
   inc hl
   ld (zmap_header),hl
   ld de,0
   ld e,(hl)         ; get header size
   add hl,de         ; pointer to table
   ld (zmap_table),hl
zemu_init.table_init:
   ld ix,(zmap_header)
   ld b,(ix+ZMAP_HDR_NPAGES)
   ld ix,(zmap_table)
zemu_init.table_init.loop:
   ; move varname into OP1
   lea hl,ix+ZMAP_ENT_VARNAME
   call appvar_to_OP1
   call _ChkFindSym
   jr c,zemu_error.missing_zmap
   ld (ix+ZMAP_ENT_FLAGS),0
   xor a
   cp b    ; CF set iff archived
   ccf     ; CF set iff in RAM
   rl (ix+ZMAP_ENT_FLAGS)
      
   ; loop condition
   djnz zemu_init.table_init.loop
   ret
   
;; zemu_error
;; INPUTS:
;;  hl = pointer to error message string
;; NOTE: never returns.
zemu_error:
   ld.s de,0
   ld.s (curRow),de
   push hl
   call _ClrScrnFull
   pop hl
   call _PutS
   call _GetKey
   call zemu_cleanup
   ret

;; zemu_exit -- exit from zemu, performing necessary cleanup, etc.
;; NOTE: returns to main's stack frame, so main cannot call zemu_exit.
zemu_exit:
zemu_cleanup:
   ; check if zmap was found
   ld hl,(zmap_appvar)
   ld de,0
   sbc hl,de ; (hl == 0)
   jr z,zemu_cleanup.table_loop.end ; skip table cleanup if zmap not loaded
   ld ix,(zmap_header)
   ld b,(ix+ZMAP_HDR_NPAGES)
   ld ix,(zmap_table)
zemu_cleanup.table_loop:
   ; if zpage is in RAM, archive it
   bit ZMAP_ENT_FLAGS_INRAM,(ix+ZMAP_ENT_FLAGS)
   jr z,zemu_cleanup.table_loop.cond
   ; move varname into OP1
   lea hl,ix+ZMAP_ENT_VARNAME
   call appvar_to_OP1
   call _Arc_Unarc ; archive zpage
zemu_cleanup.table_loop.cond:
   lea ix,ix+ZMAP_TABENTLEN
   djnz zemu_cleanup.table_loop
zemu_cleanup.table_loop.end:
zemu_cleanup.done:
zemu_exit.done:
   ld sp,(zemu_stackbottom)
   ret

zemu_error.missing_zmap:
   ld hl,zemu_errmsg.missing_zpage
   jp zemu_error

; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: a, hl, bc, de
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   ld bc,VARNAMELEN
   ldir
   ret

zemu_stackbottom: .dl 0
zmap_appvar: .dl 0
zmap_header: .dl 0
zmap_table:  .dl 0

zemu_errmsg.missing_zpage: .db "zemu: missing zpage.",0



;; TESTING ;;
zork_zmap: .db "ZORK",0,0,0,0

