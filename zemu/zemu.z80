#include "ti84pce.inc"
#include "zemu.inc"
#include "zhdr.inc"
#include "zutil.inc"
#include "zwin.inc"
#include "zhex.inc"

.assume ADL=1
.org userMem-2


.db tExtTok, tAsm84CeCmp

start:
   call zdisp_init
   call zdbg_init
   call init_windows
   
   ; clear screen & reset cursor
   ; no scrolling for now
   res appAutoScroll,(iy+appFlags)

   xor a,a
   ld (curRow),a
   ld (curCol),a
   
   ld hl,zork_zmap
   call zemu_open ; open story file
   ld hl,zemu_open_str
   jp c,zemu_perror
   call zmem_init ; initialize memory
   ld hl,zmem_init_str
   jp c,zemu_perror
   call test
   jp _GetKey


;; intialize windows
init_windows:
   ld ix,win_main
   call zwin_clear

   push iy
   
   ld iy,win_dbgout
   ld a,SFONT_HEIGHT
   ld b,0 ; don't buffer
   call zwin_split_bottom

   ld iy,win_dbgin
   ld a,SFONT_HEIGHT
   ld b,MASK(ZWIN.FLAGS.BUFD)
   call zwin_split_bottom

   ld iy,win_dbg1
   ld hl,75
   ld b,0 ; don't buffer
   call zwin_split_right

   ld ix,win_dbg1
   ld iy,win_dbg2
   ld a,lcdHeight/2-SFONT_HEIGHT
   ld b,0 ; don't buffer
   call zwin_split_bottom

   pop iy
   
   ret

win_main: D_ZWIN(0, 0, DISP_WIDTH, DISP_HEIGHT, MASK(ZWIN.FLAGS.BUFD), 256)

win_dbgout: RES_ZWIN(0) ; not buffered
win_dbgin: D_ZWIN(0, 0, 0, 0, 0, WIN_DBGIN_BUFSIZE) ; buffered
win_dbg1: RES_ZWIN(0) ; not buffered
win_dbg2: RES_ZWIN(0) ; not buffered

test:
   ; test call & run until
   ld hl,zdbg_step
   ld (zcode_stepuntil.fn),hl
   
   ld a,0 ; 3 arg
   ld de,10
   ld hl,$4f04
   call zcall_ext
   ld hl,test_str
   jp c,zemu_perror
   ret

test_str: .db "test",0

test_hex:
   push ix
   ld ix,0
   add ix,sp

   ld hl,test_hex.print_params
   push hl ; print_context
   ld hl,test_hex.print
   push hl ; print
   ld hl,test_hex.fetch_z80
   push hl ; fetch
   ld hl,MASK(HEXDUMP_IDXSIZE)
   push hl ; flags
   ld hl,4
   push hl ; ipl
   ld hl,2
   push hl ; size
   ld hl,16
   push hl ; count
   ld hl,$D00000
   push hl ; index
   ld hl,$D00000
   push hl ; base

   call _hexdump

   ld sp,ix
   pop ix

   ret
   
   

test_hex.print_params: .dl win_main
test_hex.print:
   push ix
   push iy
   ld iy,0
   add iy,sp
   ld hl,(iy+9)  ; arg1 -- string
   ld ix,(iy+12) ; arg2 -- context
   ld ix,(ix)   ; window
   
   push iy
   ld iy,flags
   call zwin_puts
   pop iy
   
   ld sp,iy
   pop iy
   pop ix
   ret

test_hex.fetch:
   push ix
   push iy
   ld iy,0
   add iy,sp

   ld hl,(iy+9) ; address
   call zaddr_fetch
   ld hl,0
   ld l,a
   
   ld sp,iy
   pop iy
   pop ix
   ret


test_hex.fetch_z80:
   push ix
   ld ix,0
   add ix,sp
   ld hl,(ix+6) ; address
   ld a,(hl)
   ld hl,0
   ld l,a
   pop ix
   ret

zemu_open_str: .db "zemu_open",0
zmem_init_str: .db "zmem_init",0
zsave_create_str: .db "zsave_create",0
zaddr_to_paddr_str: .db "zaddr_to_paddr",0
zcode_decode_str: .db "zcode_decode",0

; zemu_open -- open zemu story file
; INPUTS:
;  - hl = pointer to name of zmap appvar
; OUTPUTS:
;  zemu_appvar, zemu_header, zemu_table set
; DESTROYS: (all)
zemu_open:
   ; save name
   push hl
   ld de,zmap_name
   ld bc,VARNAMELEN
   call strncpy
   pop hl
zemu_open.find_zmap:
   call appvar_to_RAM
   ld a,ZERR_NOVAR
   ret c
   ; store zmap pointers
   ex de,hl
   ld (zmap_appvar),hl      ; store zmap ptr
   inc hl
   inc hl
   ld (zmap_header),hl
   ld de,ZMAP_HDRSIZE
   add hl,de         ; pointer to table
   ld (zmap_table),hl
zemu_open.table_init:
   ld ix,(zmap_header)
   ld b,(ix+ZMAP_HDR_NPAGES)
   ld ix,(zmap_table)
zemu_open.table_init.loop:
   ; move varname into OP1
   push ix
   push bc
   lea hl,ix+ZMAP_ENT_VARNAME
   call appvar_to_OP1
   call _ChkFindSym
   pop bc
   pop ix
   ld a,ZERR_NOVAR
   ret c  ; return if no page found
   ld (ix+ZMAP_ENT_FLAGS),0
   call _ChkInRAM
   jr nz,zemu_open.table_init.loop_end
   ; set RAM flag
   set ZMAP_ENT_FLAGS_INRAM,(ix+ZMAP_ENT_FLAGS)
   ; save pointer
   inc de
   inc de
   ld (ix+ZMAP_ENT_PTR),de
zemu_open.table_init.loop_end:      
   lea ix,ix+ZMAP_TABENTLEN
   ; loop condition
   djnz zemu_open.table_init.loop
   scf \ ccf ; success
   ret
   
;; zemu_cleanup -- cleanup in preparation for exit
zemu_cleanup:
   ; check if zmap was found
   ld hl,(zmap_appvar)
   ld de,0
   sbc hl,de ; (hl == 0)
   jr z,zemu_cleanup.table_loop.end ; skip table cleanup if zmap not loaded
   ld ix,(zmap_header)
   ld b,(ix+ZMAP_HDR_NPAGES)
   ld ix,(zmap_table)
zemu_cleanup.table_loop:
   ; if zpage is in RAM, archive it
   bit ZMAP_ENT_FLAGS_INRAM,(ix+ZMAP_ENT_FLAGS)
   jr z,zemu_cleanup.table_loop.cond
   ; move varname into OP1
   lea hl,ix+ZMAP_ENT_VARNAME
   call appvar_to_OP1
   call _Arc_Unarc ; archive zpage
zemu_cleanup.table_loop.cond:
   lea ix,ix+ZMAP_TABENTLEN
   djnz zemu_cleanup.table_loop
zemu_cleanup.table_loop.end:
zemu_cleanup.done:
zemu_exit.done:
   scf \ ccf ; success
   ret

zmap_appvar: .dl 0
zmap_header: .dl 0
zmap_table:  .dl 0
zmap_name: ; .byte VARNAMELEN
           .dw 0,0,0,0

;; TESTING ;;
zork_zmap: .db "ZORK",0
zork_save: .db "SAVE1",0

#include "zerr.z80"
#include "zutil.z80"
#include "zmem.z80"
#include "zaddr.z80"
#include "zmap.z80"
#include "zcode.z80"
#include "zvar.z80"
#include "zobj.z80"
#include "zop.z80"
#include "zbranch.z80"
#include "zexec.z80"
#include "zstr.z80"
#include "zrand.z80"
#include "zcall.z80"
#include "zdisp.z80"
#include "zdbg.z80"
#include "zwin.z80"
#include "zhex.z80"
#include "zin.z80"