ZERRCNT .equ 8

ZERR_NOVAR .equ 0
ZERR_NOMEM .equ 1
ZERR_BADADDR .equ 2
ZERR_NOTAVAIL .equ 3
ZERR_NOLOCL .equ 4
ZERR_STACKEMPTY .equ 5
ZERR_BADINSTR .equ 6
ZERR_BADVARNO .equ 7
ZERR_DIVZERO .equ 8
ZERR_BADOBJ .equ 9

zerrmsg_novar:      .db "appvar not found",0
zerrmsg_nomem:      .db "not enough free RAM",0
zerrmsg_badaddr:    .db "bad address",0
zerrmsg_notavail:   .db "opcode not supported",0
zerrmsg_nolocl:     .db "invalid local variable",0
zerrmsg_stackempty: .db "cannot pop from empty stack",0
zerrmsg_badinstr:   .db "illegal instruction",0
zerrmsg_badvarno:   .db "invalid variable number",0
zerrmsg_divzero:    .db "divide by 0",0
zerrmsg_badobj:     .db "invalid object",0

zerrtab:
   .dl zerrmsg_novar
   .dl zerrmsg_nomem
   .dl zerrmsg_badaddr
   .dl zerrmsg_notavail
   .dl zerrmsg_nolocl
   .dl zerrmsg_stackempty
   .dl zerrmsg_badinstr
   .dl zerrmsg_badvarno
   .dl zerrmsg_divzero
   .dl zerrmsg_badobj

;; zemu_perror -- print error message given zerror code.
;; INPUTS:
;;  a = zerror code
;;  hl = string
;; OUTPUTS: (none)
;; DESTROYS: All
;; NOTE: zemu_perror always sets the carry flag to indicate
;;  error condition. This doesn't mean that zemu_perror failed
;;  (it can't fail), but it is rather for convenience so that
;;  error-handling code can jump to zemu_perror without having
;;  to set the carry flag after calling zemu_perror.
zemu_perror:
   call _PutS
   ld hl,zemu_perror.sep
   call _PutS
   call zemu_perror_bare
   call _NewLine   
   scf
   ret
zemu_perror.sep: .db ": ",0

zemu_perror_bare:
   call zemu_strerror
   call _PutS
   ret

zemu_perror_OP1:
   call zemu_perror_bare
   ld hl,zemu_perror_sep
   call _PutS
   ld hl,OP1+1
   call _PutS
   scf
   ret

zemu_perror_sep: .db ": ",0

;; zemu_strerror -- return error string given error code.
;; INPUTS:
;;  a = zerror code
;; OUTPUTS:
;;  hl = error string (null-terminated)
;;  CF is set
;; DESTROYS: de, ix
zemu_strerror:
   ld d,a
   ld e,3
   mlt de
   ld ix,zerrtab
   add ix,de
   ld hl,(ix+0)
   scf
   ret
