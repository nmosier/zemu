
;; NOTE: each zexec.* function expects operands to be set properly
;;       and to have %a hold the relevant opcode.

;; zexec_cmp.* -- comparison function
;; INPUTS:
;;  hl = lhs
;;  de = rhs
;; OUTPUTS:
;;  a = 0 if false; a == $ff if true
;; DESTROYS: (all)
;; ERRORS: yes.

;; hl == de ?
zexec_cmp.eq:
   call cp_hl_de_sgn
   ld a,$FF
   ret z
   xor a
   ret

;; hl < de ?
zexec_cmp.lt:
   call cp_hl_de_sgn
   ld a,$FF
   jr c,zexec_cmp.lt.clr
   xor a,a
zexec_cmp.lt.clr:
   or a,a ; reset carry flag
   ret

;; hl > de ?
zexec_cmp.gt:
   ex de,hl
   jp zexec_cmp.lt

;; (hl & de) == hl ?
zexec_cmp.tst:
   push hl
   call zexec_binop.and
   pop de
   sbc hl,de
   ld a,$FF
   jr z,zexec_cmp.tst.clr
   xor a,a
zexec_cmp.tst.clr:
   or a,a
   ret

;; obj(de) is parent of obj(hl) ?
;; TODO -- should perform downcasting checks. But if failure is not an option...
zexec_cmp.in:
   ld a,l ; last byte
   push de
   call zobj_parent
   pop de
   ret c ; obj tree error
   cp a,e
   ret z ; NC
   or a,a
   ret   ; NC

;; does obj(hl) have attribute attr(de)?
;; TODO -- should perform downcasting checks.
zexec_cmp.attr:
   ld a,l
   ld c,e
   jp zobj_attrtest ; sets flags properly

;-----------------------;
;    unary comparisons  ;
;-----------------------;
zexec_cmp.zero:
   xor a,a
   ld de,0
   sbc hl,de
   ; NOTE: CF reset always
   ret nz
   cpl
   ret

;---------------------------;
;   unary operations        ;
;---------------------------;
; zexec_unop.* -- modification function
; INPUTS:
;  hl = value (24-bit, signed)
; OUTPUTS:
;  hl = modified value (24-bit, signed)
; DESTROYS: (all)
; ERRORS: no.

zexec_unop.inc:
   inc hl
   scf \ ccf
   ret

zexec_unop.dec:
   dec hl
   scf \ ccf
   ret

zexec_unop.not:
   ex de,hl
   ld hl,$ffffff
   sbc hl,de
   scf \ ccf
   ret

;---------------------------;
;     behavior functions    ;
;---------------------------;




;; zexec_binop.* -- binary operations
;; INPUTS:
;;  hl = lhs
;;  de = rhs
;; OUTPUTS:
;;  hl = result
;; DESTROYS: (all)
;; ERRORS: yes.

zexec_binop.lhs: .dl 0
zexec_binop.rhs: .dl 0

zexec_binop.or:
   ld (zexec_binop.lhs),hl
   ld (zexec_binop.rhs),de
   ld hl,zexec_binop.lhs
   ld de,zexec_binop.rhs
   ld b,3
zexec_binop.or.loop:
   ld a,(de)
   or (hl)
   ld (de),a
   inc hl
   inc de
   djnz zexec_binop.or.loop
zexec_binop.or.done:
   ld hl,(zexec_binop.rhs)
   scf \ ccf
   ret

zexec_binop.and:
   ld (zexec_binop.lhs),hl
   ld (zexec_binop.rhs),de
   ld hl,zexec_binop.lhs
   ld de,zexec_binop.rhs
   ld b,3
zexec_binop.and.loop:
   ld a,(de)
   or (hl)
   ld (de),a
   inc hl
   inc de
   djnz zexec_binop.and.loop
zexec_binop.and.done:
   ld hl,(zexec_binop.rhs)
   scf \ ccf
   ret

zexec_binop.add:
   add hl,de
   scf \ ccf
   ret

zexec_binop.sub:
   scf \ ccf
   sbc hl,de
   scf \ ccf
   ret

zexec_binop.mul:
   call mul_hl_de
   scf \ ccf
   ret

zexec_binop.div:
   call div_hl_de
   ret

zexec_binop.mod:
   call div_hl_de
   ex de,hl
   ret

zexec_binop.loadw:
   ;; hl = array
   ;; de = word-index
   add hl,de
   add hl,de ; hl <- hl + 2*de
   ;; NOTE: stored in big-endian order.
   call zaddr_fetch
   ret c
   ld d,a
   call zaddr_fetch
   ret c
   ld e,a
   call wtols
   scf \ ccf
   ret
   
zexec_binop.loadb:
   ;; hl = array
   ;; de = byte-index
   add hl,de
   call zaddr_fetch
   ret c
   call btols
   scf \ ccf
   ret

zexec_binop.propval:
   ;; hl = object number
   ;; de = property number
   ld a,l
   ld c,e
   call zobj_propval
   ex de,hl
   ret

zexec_binop.propaddr:
   ;; hl = object number
   ;; de = property number
   ld a,l
   ld c,e
   jp zobj_propaddr
   
zexec_binop.propsize:
   ;; hl = object number
   ;; de = property number
   ld a,l
   ld c,e
   call zobj_propaddr
   ret c
   ld hl,0
   ld l,a
   ret

zexec_binop.nextprop:
   ;; hl = object
   ;; de = property
   ld c,e
   ld a,c
   call zobj_nextprop
   ret c
   call btols
   scf \ ccf
   ret


;------------------------------------;
;           opcode handlers          ;
;------------------------------------;
;; INPUT:
;;  zcode_decode.types, zcode_decode.op_laddr set
;;  zframe_pc set
;; OUTPUT:
;; DESTROYS:
;; ERRORS: yes.

;-------------------------;
;         2 OP            ;
;-------------------------;

zexec.je:
   ld a,2
   call zop_readn
   call nc,zexec_cmp.eq
   jp nc,zexec_cjmp
   ret

zexec.jl:
   ld a,2
   call zop_readn
   call nc,zexec_cmp.lt
   jp nc,zexec_cjmp
   ret

zexec.jg:
   ld a,2
   call zop_readn
   call nc,zexec_cmp.gt
   jp nc,zexec_cjmp
   ret

zexec.dec_chk:
   ld a,2
   call zop_readn
   call nc,zvar_downcast
   ld hl,zexec_unop.dec
   push de
   call nc,zvar_modify
   pop de
   call nc,zexec_cmp.lt
   jp nc,zexec_cjmp
   ret

zexec.inc_chk:
   ld a,2
   call zop_readn
   call nc,zvar_downcast
   ld hl,zexec_unop.inc
   push de
   call nc,zvar_modify
   pop de
   call nc,zexec_cmp.gt
   jp nc,zexec_cjmp
   ret

zexec.jin:
   ld a,2
   call zop_readn
   call nc,zexec_cmp.in
   jp nc,zexec_cjmp
   ret

zexec.test:
   ld a,2
   call zop_readn
   call nc,zexec_cmp.tst
   jp nc,zexec_cjmp
   ret

zexec.or:
   ld a,2
   call zop_readn
   call nc,zexec_binop.or
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.and:
   ld a,2
   call zop_readn
   call nc,zexec_binop.and
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.test_attr:
   ld a,2
   call zop_readn
   call nc,zexec_cmp.attr
   jp nc,zexec_cjmp
   ret

;; TODO -- continue from here.
zexec.set_attr:
   ld a,2
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   ld c,e
   jp nc,zobj_attrset
   ret

zexec.clear_attr:
   ld a,2
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   ld c,e
   jp nc,zobj_attrclear
   ret

zexec.store:
   ld a,2
   call zop_readn
   call nc,zvar_downcast
   ex de,hl
   jp nc,zvar_store
   ret

zexec.insert_obj:
   ld a,2
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   ld c,e
   jp nc,zobj_insert
   ret

zexec.loadw:
   ld a,2
   call zop_readn
   call nc,zexec_binop.loadw
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.loadb:
   ld a,2
   call zop_readn
   call nc,zexec_binop.loadb
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_prop:
   ld a,2
   call zop_readn
   call nc,zexec_binop.propval
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_prop_addr:
   ld a,2
   call zop_readn
   call nc,zexec_binop.propaddr
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_next_prop:
   ld a,2
   call zop_readn
   call nc,zexec_binop.nextprop
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.add:
   ld a,2
   call zop_readn
   call nc,zexec_binop.add
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.sub:
   ld a,2
   call zop_readn
   call nc,zexec_binop.sub
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.mul:
   ld a,2
   call zop_readn
   call nc,zexec_binop.mul
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.div:
   ld a,2
   call zop_readn
   call nc,zexec_binop.div
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.mod:
   ld a,2
   call zop_readn
   call nc,zexec_binop.mod
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

;; 4 -- zexec.call_2s
;; 5 -- zexec.call_2n
;; 5 -- set_colour
;; 6 -- throw


;--------------------;
;        1 OP        ;
;--------------------;
zexec.jz:
   ld a,1
   call zop_readn
   call nc,zexec_cmp.zero
   jp nc,zexec_cjmp

zexec.get_sibling:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   call zobj_sibling
   call nc,btolu ; upcast obj val
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_child:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   call zobj_child
   call nc,btolu ; upcast obj val
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_parent:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   call zobj_parent
   call nc,btolu
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_prop_len:
   ld a,1
   call zop_readn
   ret c
   ;; NOTE -- this is an address, not an obj/prop number.
   dec hl
   call zaddr_fetch
   ret c
   call zobj_propid_to_size
   call btolu
   call zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.inc:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   ld hl,zexec_unop.inc
   jp zvar_modify
   ret

zexec.dec:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   ld hl,zexec_unop.dec
   jp zvar_modify
   ret

zexec.print_addr:
   ld a,1
   call zop_readn
   ;; cast op back to unsigned
   ex de,hl
   ld hl,0
   ld h,d
   ld l,e
   jp zstr_puts


;; 4 -- zexec.call_1s

zexec.remove_obj:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   jp zobj_remove
   ret

zexec.print_obj:
   ld a,1
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_O_PROPS
   call zaddr_fetchwu
   inc hl ; skip length byte
   jp zstr_puts


zexec.ret:
   ld a,1
   call zop_readn
   ret c
   push hl
   call zstack_leave
   pop hl
   ret c
   ld a,ZVAR_STACK
   jp zvar_store

zexec.jump:
   ld a,1
   call zop_readn
   ret c
   ;; NOTE -- this is encoded differently from a branch instruction.
   ld de,(zframe_pc)
   add hl,de
   dec hl
   dec hl
   ld (zframe_pc),hl
   scf \ ccf ; success
   ret

zexec.print_paddr:
   ld a,1
   call zop_readn
   ret c
   ex de,hl
   ld hl,0
   ld h,d
   ld l,e
   call zaddr_unpack
   jp zstr_puts

zexec.load:
   ld a,1
   call zop_readn
   call nc,zvar_downcast
   call nc,zvar_fetch
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.not:
   ld a,1
   call zop_readn
   call nc,zexec_unop.not
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret


;------------------------------------;
;             0OP opcodes            ;
;------------------------------------;
zexec.rtrue:
   call zstack_leave
   ret c
   ld a,ZVAR_STACK
   ld hl,ZTRUE
   jp zvar_store

zexec.rfalse:
   call zstack_leave
   ret c
   ld a,ZVAR_STACK
   ld hl,ZFALSE
   jp zvar_store

zexec.print:
   ; NOTE: This is analogous to a Z80 string operation.
   ld hl,(zframe_pc)
   call zstr_puts
   ld (zframe_pc),hl
   ret

zexec.print_ret:
   call zexec.print
   ret c
   call _NewLine
   jp zexec.rtrue

zexec.nop:
   scf \ ccf
   ret

zexec.save:

zexec.restore:

zexec.restart:

zexec.ret_popped:
   ld a,ZVAR_STACK
   call zvar_fetch
   ret c
   push hl
   call zstack_leave
   pop hl
   ret c
   ld a,ZVAR_STACK
   jp zvar_store

;; TODO -- this could be optimized
zexec.pop:
   ld a,ZVAR_STACK
   jp zvar_fetch 

zexec.quit:

zexec.new_line:
   call _NewLine
   or a,a
   ret

zexec.show_status:
   

zexec.verify:


;------------------------------------;
;           VAR opcodes              ;
;------------------------------------;
zexec.call:
   ;; NOTE: 6.4.4 Arguments are written onto local variables.
   ; read packed address of routine
   call zcode_readop_force
   ret c
   ; set up bare call state
   call zcall0
   ret c
   ; assign arguments to locals
   xor a,a
   ld (zexec.call.varno),a
   jr zexec.call.entry
zexec.call.loop:
   ld a,(zexec.call.varno)
   inc a
   ld (zexec.call.varno),a
   call zvar_store
zexec.call.entry:
   call zcode_readop
   ret c
   jr nz,zexec.call.loop
   or a,a
   ret
zexec.call.varno: .db 0


zexec.storew:
   ;; stores the given value in the word at address array+2*word-index
   ;; NOTE: unknown whether word-index is signed or unsigned.
   ; hl = array
   ; de = word-index
   ; bc = value
   ld a,3
   call zop_readn
   ret c
   call wtolu
   ex de,hl
   call wtolu
   add hl,hl ; word-index *= 2
   add hl,de ; hl = address of word to store in
   ; move value into de
   ld d,b
   ld e,c
   jp zaddr_storew
   
zexec.storeb:
   ;; stores the given value in the byte at address array+byte-index
   ;; NOTE: unknown whether byte-index is signed or unsigned.
   ; hl = array
   ; de = byte-index
   ; bc = value
   ld a,3
   call zop_readn
   ret c
   call wtolu
   ex de,hl
   call wtolu
   add hl,de ; byte address
   ld a,c
   jp zaddr_store
   
zexec.put_prop:
   ;; put_prop object property value
   ; hl = object
   ; de = property
   ; bc = value
   ld a,3
   call zop_readn
   ret c
   ld a,l ; object
   ld c,e ; property
   push bc
   call zobj_propaddr
   pop de
   ret c
   cp a,3
   jr nc,zexec.put_prop.err
   cp a,1
   ; 1 byte?
   ld a,e
   jp z,zaddr_store
   ; 2 bytes?
   jp c,zaddr_storew
   ; 0 bytes?
   ret
zexec.put_prop.err:
   ld a,ZERR_BADPROP
   scf
   ret

zexec.sread:

;; TODO -- should this support multiple chars?
zexec.print_char:
   ld a,1
   call zop_readn
   call nc,ltobu     ; downcast to byte
   jp nc,zstr_putc
   ret               ; error

;; print_num -- print signed number in decimal
zexec.print_num:
   ld a,1
   call zop_readn
   jp nc,zstr_putn
   ret

zexec.random:
   ld a,1
   call zop_readn
   ret c
   call sgnl
   jr c,zexec.random.seed
   ld de,0
   call cp_hl_de
   jr z,zexec.random.newseed
zexec.random.gen:
   call zrand_gen
   or a,a
   ret
zexec.random.newseed:
   call zrand_newseed
zexec.random.seed:
   call zrand_seed
   or a,a
   ret


zexec.push:
   ld a,1
   call zop_readn
   ld a,ZVAR_STACK
   jp nc,zvar_store
   ret

zexec.pull:
   ld a,ZVAR_STACK
   call zvar_fetch ; pop val off stack
   push hl
   ; get variable number destination
   ld a,1
   call nc,zop_readn
   ld a,l ; variable number
   pop hl
   jp nc,zvar_store
   ret
   
zexec.split_window:

zexec.set_window:

zexec.output_stream:

zexec.input_stream:

zexec.sound_effect:

