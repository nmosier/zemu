;; zexec.z80 -- routines for executing instructions

;; NOTE: each zexec.* function expects operands to be set properly
;;       and to have %a hold the relevant opcode.

;; zexec_cmp.* -- comparison function
;; INPUTS:
;;  hl = lhs
;;  de = rhs
;; OUTPUTS:
;;  a = 0 if false; a == $ff if true
;; DESTROYS: (all)
;; ERRORS: yes.

;; hl == de ?
zexec_cmp.eq:
   call cp_hl_de_sgn
   ld a,$FF
   ret z
   xor a
   ret

;; hl < de ?
zexec_cmp.lt:
   call cp_hl_de_sgn
   ld a,$FF
   jr c,zexec_cmp.lt.clr
   xor a,a
zexec_cmp.lt.clr:
   or a,a ; reset carry flag
   ret

;; hl > de ?
zexec_cmp.gt:
   ex de,hl
   jp zexec_cmp.lt

;; (hl & de) == hl ?
zexec_cmp.tst:
   push hl
   call zexec_binop.and
   pop de
   sbc hl,de
   ld a,$FF
   jr z,zexec_cmp.tst.clr
   xor a,a
zexec_cmp.tst.clr:
   or a,a
   ret

;; obj(de) is parent of obj(hl) ?
;; TODO -- should perform downcasting checks. But if failure is not an option...
zexec_cmp.in:
   ld a,l ; last byte
   push de
   call zobj_parent
   pop de
   ret c ; obj tree error
   cp a,e
   ret z ; NC
   or a,a
   ret   ; NC

;; does obj(hl) have attribute attr(de)?
;; TODO -- should perform downcasting checks.
zexec_cmp.attr:
   ld a,l
   ld c,e
   jp zobj_attrtest ; sets flags properly

;---------------------------;
;   unary operations        ;
;---------------------------;
; zexec_unop.* -- modification function
; INPUTS:
;  hl = value (24-bit, signed)
; OUTPUTS:
;  hl = modified value (24-bit, signed)
; DESTROYS: (all)
; ERRORS: no.

zexec_unop.inc:
   inc hl
   ret

zexec_unop.dec:
   dec hl
   ret


;; zexec_unop -- unary operation
;; INPUTS:
;;  hl = unary op function pointer
;; OUTPUTS:
;;  updates zframe_pc, variables, etc
;; DESTROYS: (all)
;; ERRORS: yes.
zexec_unop:
   push hl
   call zcode_readop_force
   pop ix
   ret c
   call zexec_unop.jump
   push hl
   call zexec_readvarnum
   pop hl
   ret c
   jp zvar_store

zexec_unop.jump:
   jp (ix)

zexec_unop.fn: .dl 0

;---------------------------;
;     behavior functions    ;
;---------------------------;

;; zexec_cond_jump -- routine for executing conditional, branching jump,
;;                    given condition as parameter.
;; INPUT:
;;  hl = pointer to comparison function
;;  zcode_decode.types, zcode_decode.op_laddr set
;;  zframe_pc set
;; OUTPUT:
;;  zframe_pc updated
;; DESTROYS: (all)
;; ERRORS: yes
;; TODO -- work in progress
;; TODO -- this really shouldn't loop
zexec_cond_jump:
   ; save function pointer
   ld (zexec_cond_jump.fn),hl
   ; read first operand
   call zcode_readop_force
   ret c
   ; read remaining operands, check for true comparison
   ex de,hl
   jr zexec_cond_jump.loop_entry
zexec_cond_jump.loop:
   ex de,hl
   ; hl = root op, de = comparison op
   ld ix,(zexec_cond_jump.fn)
   call zexec_cond_jump.jump    ; this is messy; I don't like it
   ret c ; comparison error
   ld b,$ff ; take branch (unless inverted)
   jr nz,zexec_cond_jump.handle ; condition was true   
zexec_cond_jump.loop_entry:
   push hl
   call zcode_readop
   pop de ; restore root op to de
   ret c ; error
   jr nz,zexec_cond_jump.loop
zexec_cond_jump.cont:
   ; condition failed to be met
   ld b,0 ; don't take branch
zexec_cond_jump.handle:
   ; decode branch
   ld hl,(zframe_pc)
   push bc
   call zcode_decode_branch
   pop bc
   jr c,zexec_cond_jump.err ; error
   ld a,b
   jr nz,zexec_cond_jump.condition ; adjust result based on condition inversion bit
   ; flip condition
   cpl
zexec_cond_jump.condition:
   ld (zframe_pc),hl ; store pc
   ex de,hl
   or a
   call nz,zexec_branch
   ret ; NOTE: carry flag will be properly set

zexec_cond_jump.jump:
   jp (ix)

zexec_cond_jump.data:
zexec_cond_jump.fn: .dl 0


;; zexec_branch: execute branch in running program.
;; INPUTS:
;;  hl = raw offset (24 bits)
;; OUTPUTS:
;; ERRORS: yes.
;; NOTE: updates global state variables in zmem.z80.
;; NOTE: zframe_pc MUST point to the address directly after the current instruction.
;; TODO: this shouldn't directly modify zframe_pc. Ought to be parameterized
zexec_branch:
   ; 4.7.1 An offset of 0 means return false from the current routine, and 1 means
   ;       return true from the current routine.
   ld de,1
   call cp_hl_de
   jr c,zexec_branch.ret
   jr z,zexec_branch.ret
   ; apply offset to program counter
   ld de,(zframe_pc)
   dec de
   dec de
   add hl,de
   ld (zframe_pc),hl
   scf \ ccf
   ret

zexec_branch.ret:
   push hl
   call zstack_leave
   pop hl
   ret c
   ld a,l
   or a
   ld.s hl,ZVAR_TRUE
   jr nz,zexec_branch.ret_cont
zexec_branch.ret_f:
   ld.s hl,ZTRUE
zexec_branch.ret_cont:
   ld a,ZVAR_STACK
   call zvar_store ; push return value onto stack
   ret ; C or NC


;; zexec_chk -- function used for *_chk opcodes
;; INPUTS:
;;  hl = pointer to function applied to variable value
;;  de = pointer to comparison function
;;  zcode_decode.types, zcode_decode.op_laddr set
;; OUTPUTS:
;;  updates zframe_pc
;; DESTROYS: (all)
;; ERRORS: yes.
zexec_chk:
   ; store parameters
   ld (zexec_chk.modfn),hl
   ld (zexec_chk.cmpfn),de
   ; get variable number
   call zcode_readop_force
   ret c
   ; convert variable number to 8 bits
   call zvar_downcast
   ret c
   ; save variable number
   ld (zexec_chk.varnum),a
   ; fetch value
   call zvar_fetch
   ret c
   ; apply fn to val
   ld ix,(zexec_chk.modfn)
   call zexec_chk.jump
   ; save & store result
   ld (zexec_chk.varval),hl
   ld a,(zexec_chk.varnum)
   call zvar_store
   ret c
   ; get comparison operator
   call zcode_readop_force
   ret c
   ld (zexec_chk.cmpval),hl
   ; decode branch
   ld hl,(zframe_pc)
   call zcode_decode_branch
   ret c
   ld (zframe_pc),hl
   push de ; branch offset
   ld hl,(zexec_chk.varval)
   ld de,(zexec_chk.cmpval)
   ld ix,(zexec_chk.cmpfn)
   call zexec_chk.jump
   pop hl
   jr nc,zexec_chk.post_branch
zexec_chk.branch:
   call zexec_branch
   ret c
zexec_chk.post_branch:
   ret
   
zexec_chk.jump:
   jp (ix)

zexec_chk.varnum: .db 0
zexec_chk.varval: .dl 0
zexec_chk.cmpval: .dl 0
zexec_chk.modfn:  .dl 0
zexec_chk.cmpfn:  .dl 0


;; zexec_binop.* -- binary operations
;; INPUTS:
;;  hl = lhs
;;  de = rhs
;; OUTPUTS:
;;  hl = result
;; DESTROYS: (all)
;; ERRORS: yes.

zexec_binop.lhs: .dl 0
zexec_binop.rhs: .dl 0

zexec_binop.or:
   ld (zexec_binop.lhs),hl
   ld (zexec_binop.rhs),de
   ld hl,zexec_binop.lhs
   ld de,zexec_binop.rhs
   ld b,3
zexec_binop.or.loop:
   ld a,(de)
   or (hl)
   ld (de),a
   inc hl
   inc de-
   djnz zexec_binop.or.loop
zexec_binop.or.done:
   ld hl,(zexec_binop.rhs)
   scf \ ccf
   ret

zexec_binop.and:
   ld (zexec_binop.lhs),hl
   ld (zexec_binop.rhs),de
   ld hl,zexec_binop.lhs
   ld de,zexec_binop.rhs
   ld b,3
zexec_binop.and.loop:
   ld a,(de)
   or (hl)
   ld (de),a
   inc hl
   inc de
   djnz zexec_binop.and.loop
zexec_binop.and.done:
   ld hl,(zexec_binop.rhs)
   scf \ ccf
   ret

zexec_binop.add:
   add hl,de
   scf \ ccf
   ret

zexec_binop.sub:
   scf \ ccf
   sbc hl,de
   scf \ ccf
   ret

zexec_binop.mul:
   call mul_hl_de
   scf \ ccf
   ret

zexec_binop.div:
   call div_hl_de
   ret

zexec_binop.mod:
   call div_hl_de
   ex de,hl
   ret

zexec_binop.loadw:
   ;; hl = array
   ;; de = word-index
   add hl,de
   add hl,de ; hl <- hl + 2*de
   ;; NOTE: stored in big-endian order.
   call zaddr_fetch
   ret c
   ld d,a
   call zaddr_fetch
   ret c
   ld e,a
   call wtols
   scf \ ccf
   ret
   
zexec_binop.loadb:
   ;; hl = array
   ;; de = byte-index
   add hl,de
   call zaddr_fetch
   ret c
   call btols
   scf \ ccf
   ret

zexec_binop.propval:
   ;; hl = object number
   ;; de = property number
   ld a,l
   ld c,e
   call zobj_propval
   ex de,hl
   ret

zexec_binop.propaddr:
   ;; hl = object number
   ;; de = property number
   ld a,l
   ld c,e
   jp zobj_propaddr
   
zexec_binop.propsize:
   ;; hl = object number
   ;; de = property number
   ld a,l
   ld c,e
   call zobj_propaddr
   ret c
   ld hl,0
   ld l,a
   ret

zexec_binop.nextprop:
   ;; hl = object
   ;; de = property
   ld c,e
   ld a,c
   call zobj_nextprop
   ret c
   call btols
   scf \ ccf
   ret

;; zexec_binop -- execute binop instruction
;; INPUTS:
;;  hl = pointer to binary operation function
;;  zframe_pc, args set
;; OUTPUTS:
;; DESTROYS:
;; ERRORS: yes.
zexec_binop:
   ld (zexec_binop.fn),hl
   call zcode_readop_force
   ret c
   push hl
   call zcode_readop_force
   ex de,hl
   pop hl
   ret c
   ld ix,(zexec_binop.fn)
   call zexec_binop.jmp
   push hl
   call zcode_readvarnum
   pop hl
   call zvar_store
   ret ; carry flag set 

zexec_binop.jmp:
   jp (ix)

zexec_binop.fn: .dl 0


;; zexec_attrmod -- execute attribute modification instruction
;; INPUTS:
;;  hl = pointer to attribute modfication function
;;  zframe_pc, args set
;; OUTPUTS: 
;;  zframe_pc updated
;; DESTROYS: (all)
;; ERRORS: yes.
;; TODO: downcast vals.
zexec_attrmod:
   ld (zexec_attrmod.fn),hl
   call zcode_readop_force
   ret c
   push hl
   call zcode_readop_force
   pop de
   ret c
   ld a,e ; object number
   ld c,l ; attribute number
   ld hl,(zexec_attrmod.fn)
   jp (hl)

zexec_attrmod.fn: .dl 0

;------------------------------------;
;           opcode handlers          ;
;------------------------------------;
;; INPUT:
;;  zcode_decode.types, zcode_decode.op_laddr set
;;  zframe_pc set
;; OUTPUT:
;; DESTROYS:
;; ERRORS: yes.

;-------------------------;
;         2 OP            ;
;-------------------------;

zexec.je:
   ld hl,zexec_cmp.eq
   jp zexec_cond_jump

zexec.jl:
   ld hl,zexec_cmp.lt
   jp zexec_cond_jump

zexec.jg:
   ld hl,zexec_cmp.gt
   jp zexec_cond_jump

zexec.dec_chk:
   ld hl,zexec_unop.dec
   ld de,zexec_cmp.lt
   jp zexec_chk

zexec.inc_chk:
   ld hl,zexec_unop.inc
   ld de,zexec_cmp.gt
   jp zexec_chk

zexec.jin:
   ld hl,zexec_cmp.in
   jp zexec_cond_jump

zexec.test:
   ld hl,zexec_cmp.tst
   jp zexec_cond_jump

zexec.or:
   ld hl,zexec_binop.or
   jp zexec_binop

zexec.and:
   ld hl,zexec_binop.and
   jp zexec_binop

zexec.test_attr:
   ld hl,zexec_cmp.attr
   jp zexec_cond_jump

zexec.set_attr:
   ld hl,zobj_attrset
   jp zexec_attrmod

zexec.clear_attr:
   ld hl,zobj_attrset
   jp zexec_attrmod

zexec.store:
   call zcode_readop_force ; variable number
   push hl
   call nc,zcode_readop_force ; value to store
   call nc,zvar_downcast
   pop hl
   call nc,zvar_store
   ret

zexec.insert_obj:
   call zcode_readop_force ; child object
   push hl
   call nc,zcode_readop_force ; parent (dst.) object
   pop de
   ld b,e ; object
   ld c,l ; new parent
   jp zobj_insert

zexec.loadw:
   ld hl,zexec_binop.loadw
   jp zexec_binop

zexec.loadb:
   ld hl,zexec_binop.loadb
   jp zexec_binop

zexec.get_prop:
   ld hl,zexec_binop.propval
   jp zexec_binop

zexec.get_prop_addr:
   ld hl,zexec_binop.propaddr
   jp zexec_binop

zexec.get_next_prop:
   ld hl,zexec_binop.nextprop
   jp zexec_binop

zexec.add:
   ld hl,zexec_binop.add
   jp zexec_binop

zexec.sub:
   ld hl,zexec_binop.sub
   jp zexec_binop

zexec.mul:
   ld hl,zexec_binop.mul
   jp zexec_binop

zexec.div:
   ld hl,zexec_binop.div
   jp zexec_binop

zexec.mod:
   ld hl,zexec_binop.mod
   jp zexec_binop

;; 4 -- zexec.call_2s
;; 5 -- zexec.call_2n
;; 5 -- set_colour
;; 6 -- throw


;--------------------;
;        1 OP        ;
;--------------------;
zexec.jz:
   call zcode_readop_force
   ret c
   push hl
   ld hl,(zframe_pc)
   call zcode_decode_branch
   ret c
   ld (zframe_pc),hl
   push de
   push af ; save ZF for later
   pop hl
   xor a,a ; %a holds branching status (a=0 if no, a=$ff if yes)
   add hl,hl
   jr z,zexec.jz.skip
   cpl
zexec.jz.skip:
   pop af
   jr nz,zexec.jz.skip2
   cpl
zexec.jz.skip2:
   ; now conditionally apply branch
   or a,a
   pop hl
   call z,zexec_branch
   ret ; CF properly set

zexec.get_sibling:
   

zexec.get_child:

zexec.get_parent:

zexec.get_prop_len:

zexec.inc:
   ld hl,zexec_unop.inc
   jp zexec_unop

zexec.dec:
   ld hl,zexec_unop.dec
   jp zexec_unop

zexec.print_addr:

;; 4 -- zexec.call_1s

zexec.remove_obj:

zexec.print_obj:

zexec.ret:

zexec.jump:

zexec.print_paddr:

zexec.load:

zexec.not:

