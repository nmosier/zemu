#include "zutil.inc"

;; NOTE: each zexec.* function expects operands to be set properly
;;       and to have %a hold the relevant opcode.

;; zexec_cmp.* -- comparison function
;; INPUTS:
;;  hl = lhs
;;  de = rhs
;; OUTPUTS:
;;  a = 0 if false; a == $ff if true
;; DESTROYS: (all)
;; ERRORS: yes.

;; hl == de ?
zexec_cmp.eq:
   call cp_hl_de;_sgn
   ld a,$FF
   ret z
   xor a
   ret

;; hl < de ?
zexec_cmp.lt:
   call cp_hl_de;_sgn
   scf \ ccf
   ld a,0
   ret p ; S flag reset, so (hl-de) is non-negative, so hl >= de
   dec a ; ld a,$ff
   ret

;; hl > de ?
zexec_cmp.gt:
   ex de,hl
   jp zexec_cmp.lt

;; (hl & de) == hl ?
zexec_cmp.tst:
   push de
   call zexec_binop.and
   pop de
   or a,a
   sbc hl,de
   ld a,$FF
   jr z,zexec_cmp.tst.clr
   xor a,a
zexec_cmp.tst.clr:
   or a,a
   ret

;; obj(de) is parent of obj(hl) ?
zexec_cmp.in:
   call zobj_downcast
   push de
   call nc,zobj_parent
   pop hl
   ld b,a ; save actual parent
   call nc,zobj_downcast
   ret c
   cp a,b
   ld a,$ff
   ret z ; NC
   xor a,a
   ret   ; NC

;; does obj(hl) have attribute attr(de)?
;; TODO -- should perform downcasting checks.
zexec_cmp.attr:
   ex de,hl
   call zobj_downcast
   ld c,a
   ex de,hl
   call nc,zobj_downcast
   call nc,zobj_attrtest ; sets flags properly
   ret c
   ld a,0
   ret z
   dec a ; ld a,$ff
   ret

;-----------------------;
;    unary comparisons  ;
;-----------------------;
zexec_cmp.zero:
   xor a,a
   ld de,0
   sbc hl,de
   ; NOTE: CF reset always
   ret nz
   cpl
   ret

zexec_cmp.nonzero:
   call zexec_cmp.zero
   cpl
   ret

;---------------------------;
;   unary operations        ;
;---------------------------;
; zexec_unop.* -- modification function
; INPUTS:
;  hl = value (24-bit, signed)
; OUTPUTS:
;  hl = modified value (24-bit, signed)
; DESTROYS: (all)
; ERRORS: no.

zexec_unop.inc:
   inc hl
   scf \ ccf
   ret

zexec_unop.dec:
   dec hl
   scf \ ccf
   ret

zexec_unop.not:
   ex de,hl
   ld hl,$ffffff
   sbc hl,de
   scf \ ccf
   ret

;---------------------------;
;     behavior functions    ;
;---------------------------;




;; zexec_binop.* -- binary operations
;; INPUTS:
;;  hl = lhs
;;  de = rhs
;; OUTPUTS:
;;  hl = result
;; DESTROYS: (all)
;; ERRORS: yes.

zexec_binop.lhs: .dl 0
zexec_binop.rhs: .dl 0

zexec_binop.or:
   ld (zexec_binop.lhs),hl
   ld (zexec_binop.rhs),de
   ld hl,zexec_binop.lhs
   ld de,zexec_binop.rhs
   ld b,3
zexec_binop.or.loop:
   ld a,(de)
   or (hl)
   ld (de),a
   inc hl
   inc de
   djnz zexec_binop.or.loop
zexec_binop.or.done:
   ld hl,(zexec_binop.rhs)
   scf \ ccf
   ret

zexec_binop.and:
   ld (zexec_binop.lhs),hl
   ld (zexec_binop.rhs),de
   ld hl,zexec_binop.lhs
   ld de,zexec_binop.rhs
   ld b,3
zexec_binop.and.loop:
   ld a,(de)
   and (hl)
   ld (de),a
   inc hl
   inc de
   djnz zexec_binop.and.loop
zexec_binop.and.done:
   ld hl,(zexec_binop.rhs)
   scf \ ccf
   ret

zexec_binop.add:
   add hl,de
   scf \ ccf
   ret

zexec_binop.sub:
   scf \ ccf
   sbc hl,de
   scf \ ccf
   ret

zexec_binop.mul:
   call mul_hl_de
   scf \ ccf
   ret

zexec_binop.div:
   call div_hl_de
   ret

zexec_binop.mod:
   call div_hl_de
   ex de,hl
   ret

zexec_binop.loadw:
   ; NOTE: pretend args are unsigned. (???)
   ;; hl = array
   ;; de = word-index
   add hl,de
   add hl,de ; hl <- hl + 2*de
   ;; NOTE: stored in big-endian order.
   call ltowu ; downcast   
   call zaddr_fetchw
   ex de,hl
   ret
   
zexec_binop.loadb:
   ;; hl = array
   ;; de = byte-index
   add hl,de
   call zaddr_fetch
   ret c
   call btolu
   or a,a
   ret

zexec_binop.propval:
   ;; hl = object number
   ;; de = property number
   ex de,hl
   call zobj_downcast
   ret c
   ld c,a
   ex de,hl
   call zobj_downcast
   ret c
   call zobj_propval
   ex de,hl
   ret

zexec_binop.propaddr:
   ;; hl = object number
   ;; de = property number
   ex de,hl
   call zobj_downcast
   ld c,a
   ex de,hl
   call nc,zobj_downcast
   jp nc, zobj_propaddr
   ret
   
zexec_binop.propsize:
   ;; hl = object number
   ;; de = property number
   ld a,l
   ld c,e
   call zobj_propaddr
   ret c
   ld hl,0
   ld l,a
   ret

zexec_binop.nextprop:
   ;; hl = object
   ;; de = property
   ld c,e
   ld a,c
   call zobj_nextprop
   ret c
   call btols
   scf \ ccf
   ret

;----------------------------------;
;     variable arg functions       ;
;----------------------------------;

;; zexec_repbcmp -- repeat binary comparison for variable number of arguments
;; INPUTS:
;;  hl = comparison function
;; OUTPUTS:
;;  a = truth value of comparison
;; ERROR: yes.
;; DESTROYS: (all), ix
zexec_repbcmp:
   ld (zexec_repcmp.cmp),hl ; save comparison function
   ld a,1
   call zop_readn
   ret c ; require at least one argument
   ld (zexec_repbcmp.lhs),hl
   xor a,a
   jr zexec_repbcmp.entry
zexec_repbcmp.loop:
   ex de,hl
   ld hl,(zexec_repbcmp.lhs)
   or a,a                    ; NC
   call z,zexec_repcmp.call ; perform comparison (only if truth-value is still FALSE)
   ret c
zexec_repbcmp.entry:
   push af  ; preserve truth-value
   call zcode_readop
   pop bc
   ld a,b   ; restore truth-value
   ret c    
   jr nz,zexec_repbcmp.loop
zexec_repbcmp.done:
   or a,a
   ret
   
zexec_repbcmp.lhs: .dl 0

;; zexec_repucmp -- repeat unary comparison for variable number of arguments
;; INPUTS:
;;  hl = comparison function
;; OUTPUTS:
;;  a = truth value of comparison
;; ERRORS: yes.
;; DESTROYS: (all), ix
zexec_repucmp:
   ld (zexec_repcmp.cmp),hl ; save comparison function
   xor a,a
   jr zexec_repucmp.entry
zexec_repucmp.loop:
   or a,a
   call z,zexec_repcmp.call   ; compare iff truth-value is still FALSE
   ret c
zexec_repucmp.entry:
   push af  ; preserve truth-value
   call zcode_readop
   pop bc
   ld a,b   ; restore truth-value
   ret c
   jr nz,zexec_repucmp.loop
zexec_repucmp.done:
   ret

;; shared
zexec_repcmp.call:
   ld ix,(zexec_repcmp.cmp)
   jp (ix)

zexec_repcmp.cmp: .dl 0


;------------------------------------;
;           opcode handlers          ;
;------------------------------------;
;; INPUT:
;;  zcode_decode.types, zcode_decode.op_laddr set
;;  zframe_pc set
;; OUTPUT:
;; DESTROYS:
;; ERRORS: yes.

;-------------------------;
;         2 OP            ;
;-------------------------;

zexec.je:
   ld hl,zexec_cmp.eq
   call zexec_repbcmp
   jp nc,zexec_cjmp
   ret

zexec.jl:
   ld hl,zexec_cmp.lt
   call zexec_repbcmp
   jp nc,zexec_cjmp
   ret

zexec.jg:
   ld hl,zexec_cmp.gt
   call zexec_repbcmp
   jp nc,zexec_cjmp
   ret

zexec.dec_chk:
   ld a,2
   call zop_readn
   ret c
   call zvar_downcast
   ld hl,zexec_unop.dec
   push de
   call zvar_modify
   pop de
   call nc,zexec_cmp.lt
   jp nc,zexec_cjmp
   ret

zexec.inc_chk:
   ld a,2
   call zop_readn
   ret c
   call zvar_downcast
   ld hl,zexec_unop.inc
   push de
   call zvar_modify
   pop de
   call nc,zexec_cmp.gt
   jp nc,zexec_cjmp
   ret

zexec.jin:
   ld hl,zexec_cmp.in
   call zexec_repbcmp
   jp nc,zexec_cjmp
   ret

   ld a,2
   call zop_readn
   call nc,zexec_cmp.in
   jp nc,zexec_cjmp
   ret

zexec.test:
   ld hl,zexec_cmp.tst
   call zexec_repbcmp
   jp nc,zexec_cjmp
   ret

zexec.or:
   ld a,2
   call zop_readn
   call nc,zexec_binop.or
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.and:
   ld a,2
   call zop_readn
   call nc,zexec_binop.and
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.test_attr:
   ld hl,zexec_cmp.attr
   call zexec_repbcmp
   jp nc,zexec_cjmp
   ret

zexec.set_attr:
   ld a,2
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   ld c,e
   jp nc,zobj_attrset
   ret

zexec.clear_attr:
   ld a,2
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   ld c,e
   jp nc,zobj_attrclear
   ret

zexec.store:
   ld a,2
   call zop_readn
   ret c
   call zvar_downcast
   ex de,hl
   jp zvar_store

zexec.insert_obj:
   ld a,2
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   ld c,e
   jp nc,zobj_insert
   ret

zexec.loadw:
   ld a,2
   call zop_readn
   call nc,zexec_binop.loadw
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.loadb:
   ld a,2
   call zop_readn
   call nc,zexec_binop.loadb
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_prop:
   ld a,2
   call zop_readn
   call nc,zexec_binop.propval
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_prop_addr:
   ld a,2
   call zop_readn
   call nc,zexec_binop.propaddr
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.get_next_prop:
   ld a,2
   call zop_readn
   call nc,zexec_binop.nextprop
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.add:
   ld a,2
   call zop_readn
   call nc,zexec_binop.add
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.sub:
   ld a,2
   call zop_readn
   call nc,zexec_binop.sub
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.mul:
   ld a,2
   call zop_readn
   call nc,zexec_binop.mul
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.div:
   ld a,2
   call zop_readn
   call nc,zexec_binop.div
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.mod:
   ld a,2
   call zop_readn
   call nc,zexec_binop.mod
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret

;; 4 -- zexec.call_2s
;; 5 -- zexec.call_2n
;; 5 -- set_colour
;; 6 -- throw


;--------------------;
;        1 OP        ;
;--------------------;
zexec.jz:
   ld hl,zexec_cmp.zero
   call zexec_repucmp
   jp nc,zexec_cjmp
   ret

   ld a,1
   call zop_readn
   call nc,zexec_cmp.zero
   jp nc,zexec_cjmp
   ret

zexec.get_sibling:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   call zobj_sibling
   call nc,btolu ; upcast obj val
   call nc,zcode_readvarnum
   push hl
   call nc,zvar_store
   pop hl
   call nc,zexec_cmp.nonzero
   call nc,zexec_cjmp
   ret

zexec.get_child:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   call zobj_child
   call nc,btolu ; upcast obj val
   call nc,zcode_readvarnum
   push hl
   call nc,zvar_store
   pop hl
   call nc,zexec_cmp.nonzero
   call nc,zexec_cjmp
   ret

zexec.get_parent:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   call zobj_parent
   call nc,btolu
   call nc,zcode_readvarnum
   call nc,zvar_store
   ret

zexec.get_prop_len:
   ld a,1
   call zop_readn
   ret c
   ;; NOTE -- this is an address, not an obj/prop number.
   dec hl
   call zaddr_fetch
   ret c
   call zobj_propid_to_size
   call btolu
   call zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.inc:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   ld hl,zexec_unop.inc
   jp zvar_modify
   ret

zexec.dec:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   ld hl,zexec_unop.dec
   jp zvar_modify
   ret

zexec.print_addr:
   ld a,1
   call zop_readn
   ;; cast op back to unsigned
   ex de,hl
   ld hl,0
   ld h,d
   ld l,e
   ld ix,win_main
   jp zstr_puts


;; 4 -- zexec.call_1s

zexec.remove_obj:
   ld a,1
   call zop_readn
   ret c
   ;; TODO -- obj downcast
   ld a,l
   jp zobj_remove
   ret

zexec.print_obj:
   ld a,1
   call zop_readn
   ;; TODO -- obj downcast
   ld a,l
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_O_PROPS
   call zaddr_fetchwu
   ex de,hl
   inc hl ; skip length byte
   ld ix,win_main
   jp zstr_puts


zexec.ret:
   ld a,1
   call zop_readn
   ret c
   ld a,(zframe_rv)
   push hl
   call zstack_leave ; %a preserved
   pop hl
   ret c
   jp zvar_store

zexec.jump:
   ld a,1
   call zop_readn
   ret c
   ;; NOTE -- this is encoded differently from a branch instruction.
   ld de,(zframe_pc)
   add hl,de
   dec hl
   dec hl
   ld (zframe_pc),hl
   scf \ ccf ; success
   ret

zexec.print_paddr:
   ld a,1
   call zop_readn
   ret c
   ex de,hl
   ld hl,0
   ld h,d
   ld l,e
   call zaddr_unpack
   ld ix,win_main
   jp zstr_puts

zexec.load:
   ld a,1
   call zop_readn
   ret c
   call zvar_downcast
   call zvar_fetch
   ret c
   call zcode_readvarnum
   jp nc,zvar_store
   ret

zexec.not:
   ld a,1
   call zop_readn
   call nc,zexec_unop.not
   call nc,zcode_readvarnum
   jp nc,zvar_store
   ret


;------------------------------------;
;             0OP opcodes            ;
;------------------------------------;
zexec.rtrue:
   ld a,(zframe_rv)
   call zstack_leave ; %a preserved
   ld hl,ZTRUE
   jp nc,zvar_store
   ret

zexec.rfalse:
   ld a,(zframe_rv)
   call zstack_leave ; %a preserved
   ld hl,ZFALSE
   jp nc,zvar_store
   ret

zexec.print:
   call zstr_reset
   ld hl,(zframe_pc)
   ld ix,win_main
   call zstr_puts
   ld (zframe_pc),hl
   ret

zexec.print_ret:
   call zexec.print
   ld ix,win_main
   call nc,zstr_putln
   jp nc,zexec.rtrue
   ret

zexec.nop:
   or a,a
   ret

zexec.save:
   ld a,ZERR_BADINSTR
   scf
   ret

zexec.restore:
   ld a,ZERR_BADINSTR
   scf
   ret

zexec.restart:
   ld a,ZERR_BADINSTR
   scf
   ret

zexec.ret_popped:
   ld a,ZVAR_STACK
   call zvar_fetch
   ret c
   ld a,(zframe_rv)
   push hl
   call zstack_leave ; %a preserved
   pop hl
   ret c
   jp zvar_store

zexec.pop:
   ld a,ZVAR_STACK
   jp zvar_fetch 

zexec.quit:
   ld a,ZERR_BADINSTR
   scf
   ret

zexec.new_line:
   ld ix,win_main
   call zstr_putln
   or a,a
   ret

zexec.show_status:
   ld a,ZERR_BADINSTR
   scf
   ret
   
zexec.verify:
   ld a,ZERR_BADINSTR
   scf
   ret

;------------------------------------;
;           VAR opcodes              ;
;------------------------------------;
zexec.call:
   ;; NOTE: 6.4.4 Arguments are written onto local variables.
   ;; read packed address of routine
   call zcode_readop_force
   ret c
   call wtolu
   ;; read parameters into locals
   push hl ; save packed address for after we've read in the params
   call zexec.call.readvars
   ;; read return value
   push bc
   call nc,zcode_readvarnum
   pop bc
   pop hl
   ret c
   ;; check if CALL address is 0 -- if so, do nothing
   call cp_hl_0
   ret z
   ;; set up bare call state
   ld c,a ; save return varno
   push bc
   call zcall0
   pop bc
   ret c
   ld a,c
   ld (zframe_rv),a ; save return value
   push hl ; save new address
   call zexec.call.storevars
   pop hl ; restore new address
   ret c
zexec.call.done:
   ld ix,(zframe_fp)
   ld de,(zframe_pc) ; end of CALL instruction
   ld (ix+zframe_pc-zframe_end),de ; save return address
   ld (zframe_pc),hl ; save new PC
   or a,a
   ret

#if 0
   push hl ; save PC after procedure is entered
   ; assign arguments to locals
   xor a,a
   ld (zexec.call.varno),a
   jr zexec.call.entry
zexec.call.loop:
   ld a,(zexec.call.varno)
   inc a
   ld (zexec.call.varno),a
   call nc,zvar_store
zexec.call.entry:
   call nc,zcode_readop
   jr nz,zexec.call.loop
zexec.call.rv:
   ; read return variable
   call zcode_readvarnum
   ld de,(zframe_pc) ; save PC after call instruction
   pop hl
   ret c
   ; save return variable
   ld (zframe_rv),a
zexec.call.pc:
   ; hacky part -- don't like this
   ld ix,(zframe_fp)
   ld (ix+zframe_pc-zframe_end),de ; update PC
   ld (zframe_pc),hl
   ret
zexec.call.varno: .db 0

#endif

;; get variables before setting up new call frame
zexec.call.readvars:
   ld de,zexec.call.locals ; locals are temporarily stored here
   or a,a
   jr zexec.call.readvars.entry
zexec.call.readvars.loop:
   ex de,hl
   ld (hl),d
   inc hl
   ld (hl),e
   inc hl
   ex de,hl
zexec.call.readvars.entry:
   push de
   call zcode_readop
   pop de
   ret c ; error
   jr nz,zexec.call.readvars.loop
zexec.call.readvars.done:
   ex de,hl
   ld de,zexec.call.locals
   or a,a
   sbc hl,de
   ld b,l
   rr b ; b = # of locals
   or a,a ; NC
   ret

;; store variables after setting up new call frame
;; b = # of vars
zexec.call.storevars:
   ld hl,zexec.call.locals
   ld de,0
   ld e,b
   add hl,de
   add hl,de
   ld a,b
   or a,a
   ret z ; no vars to store
zexec.call.storevars.loop:
   ld de,0
   dec hl
   ld e,(hl)
   dec hl
   ld d,(hl)
   push hl
   ex de,hl
   ld a,b
   call zvar_store
   pop hl
   ret c ; error
   djnz zexec.call.storevars.loop
zexec.call.storevars.done:
   or a,a
   ret

zexec.call.locals: RESW(16) ; 16 = max # of locals

zexec.storew:
   ;; stores the given value in the word at address array+2*word-index
   ;; NOTE: unknown whether word-index is signed or unsigned.
   ; hl = array
   ; de = word-index
   ; bc = value
   ld a,3
   call zop_readn
   ret c
   call wtolu
   ex de,hl
   call wtolu
   add hl,hl ; word-index *= 2
   add hl,de ; hl = address of word to store in
   ; move value into de
   ld d,b
   ld e,c
   jp zaddr_storew
   
zexec.storeb:
   ;; stores the given value in the byte at address array+byte-index
   ;; NOTE: unknown whether byte-index is signed or unsigned.
   ; hl = array
   ; de = byte-index
   ; bc = value
   ld a,3
   call zop_readn
   ret c
   call wtolu
   ex de,hl
   call wtolu
   add hl,de ; byte address
   ld a,c
   jp zaddr_store
   
zexec.put_prop:
   ;; put_prop object property value
   ; hl = object
   ; de = property
   ; bc = value
   ld a,3
   call zop_readn
   ret c
   ld a,l ; object
   ld c,e ; property
   push bc
   call zobj_propaddr
   pop de
   ret c
   cp a,3
   jr nc,zexec.put_prop.err
   cp a,1
   ; 1 byte?
   ld a,e
   jp z,zaddr_store
   ; 2 bytes?
   jp c,zaddr_storew
   ; 0 bytes?
   ret
zexec.put_prop.err:
   ld a,ZERR_BADPROP
   scf
   ret

zexec.read:
   ld a,2
   call zop_readn
   jp nc,zin_read ; read text into buffer
   ret
   ;; TODO

zexec.print_char:
   ld a,1
   call zop_readn
   call nc,ltobu     ; downcast to byte
   ld ix,win_main
   jp nc,zstr_putcode
   ret               ; ERROR

;; print_num -- print signed number in decimal
zexec.print_num:
   ld a,1
   call zop_readn
   ret c
   ld ix,win_main
   call zstr_putn
   or a,a ; NC
   ret

zexec.random:
   ld a,1
   call zop_readn
   ret c
   call sgnl
   jr c,zexec.random.seed
   ld de,0
   call cp_hl_de
   jr z,zexec.random.newseed
zexec.random.gen:
   call zrand_gen
zexec.random.store:
   call zcode_readvarnum
   jp nc,zvar_store
   ret ; ERROR

zexec.random.newseed:
   call zrand_newseed
zexec.random.seed:
   call zrand_seed
   jr zexec.random.store

zexec.push:
   ld a,1
   call zop_readn
   ld a,ZVAR_STACK
   jp nc,zvar_store
   ret

zexec.pull:
   ld a,ZVAR_STACK
   call zvar_fetch ; pop val off stack
   push hl
   ; get variable number destination
   ld a,1
   call nc,zop_readn
   ld a,l ; variable number
   pop hl
   jp nc,zvar_store
   ret
   
zexec.split_window:

zexec.set_window:

zexec.output_stream:

zexec.input_stream:

zexec.sound_effect:
