;; zin.z80 -- input routines

#include "zin.inc"

;; zin_read -- read ASCII chars into given buffer
;; INPUTS:
;;  hl = text-buffer Z-ptr
;; OUTPUTS:
;;  b = number of bytes written
;; ERRORS: yes.
;; DESTROYS: (all)
zin_read:
   ; read number of bytes in buffer
   call zaddr_fetch
   ret c
   ld bc,0
   ld c,a
   cp a,ZIN_TXTBUF_MINSIZE
   ld a,ZERR_TXTBUF
   ret c
   ; allocate space on the stack
   inc bc ; +1 for Z-string null terminator; ASCII newline isn't necessary
   ex de,hl ; so that we don't clobber the dst Z-address
   ld hl,0
   add hl,sp
   or a,a
   sbc hl,bc ; hl = pointer to buffer on stack
   ld sp,hl
   push bc
   push de
   ld ix,win_main
   call zwin_getsn
   add hl,bc
   dec hl
   ld a,(hl)
   inc hl ; restore hl
   or a,a
   sbc hl,bc
   cp a,ASCII_NEWLINE
   jr nz,_
   ld (hl),a
   dec bc
_  ;; convert to lowercase
   call tolowers
   ;; ready to copy now
   ;; bc holds count
   inc bc ; also want to copy NUL byte
   ld b,c
   pop de ; restore dst Z-ptr
   call pmemcpyz_b
   ld a,0
   jr nc,_
   dec a
_  ; restore original stack state
   pop hl ; restore buffer length
   add hl,sp
   ld sp,hl
   ; recover carry flag (error)
   or a,a
   ret z
   scf
   ret

;; zin_parse -- parse input (as required by `read')
;; INPUTS:
;;  hl = pointer to text buffer (ZA)
;;  de = pointer to parse buffer (ZA)
;; OUTPUTS:
;; DESTROYS:
;; ERRORS:
zin_parse:
   ;; copy word-sep string onto stack
   push iy
   ld iy,0
   add iy,sp
   push hl
   push de
   call zdict_hdraddr
   call zaddr_fetch ; byte: size of word-sep buffer
   ex de,hl
   inc a ; NUL terminator
   inc a ; ZSCII SPACE
   ld hl,-1
   neg
   ld l,a
   add hl,sp
   ld sp,hl ; buffer starts at (sp)
   ex de,hl
   ld hl,(iy-6)
   call zmemcpyp_b ; copy word-sep string into memory
   ld (iy-7),ZSCII_NUL ; NUL terminate string
   ld (iy-8),' '       ; ZSCII SPACE
   ;; TODO

zin_parse.done:
   ld sp,iy
   pop iy
   ret

; need to allocate word-sep buffer on stack

;; zin_parse_word -- parse single word in input string
;; INPUTS:
;;  bc = pointer to next char in text buffer (PA)
;;  de = pointer to next entry in parse buffer (ZA)
;;  hl = pointer to word-sep string (PA)
;; OUTPUTS:
;;  bc points to beginning of next word (or NUL if none)
;;  de points to next entry in parse buffer
;;  hl unmodified
;; DESTROYS: ???
;; ERRORS: yes.
;; NOTE: assumes there is space in the parse buffer.
zin_parse_word:
   push iy
   ld iy,-9
   add iy,sp
   push hl ; word-sep (PA)
   push de ; parse-buf (ZA)
   push bc ; text-buf (PA)
   push af ; local 0
   ;; TODO ;;
   
   jr zin_parse_word.spaces_entry
   ; skip over leading spaces
zin_parse_word.spaces_loop:
   inc bc
zin_parse_word.spaces_entry:
   ld a,(bc)
   cp a,' ' ; ZSCII SPACE
   jr z,zin_parse_word.spaces_loop
   ; end spaces loop
   jr zin_parse_word.term_entry
   ; find word terminator
zin_parse_word.term_loop:
   ld hl,(iy+6) ; saved word-sep string
   inc bc   
zin_parse_word.term_entry:
   ld a,(bc)
   call strchr
   cp a,(hl) ; NOTE: this does what we want if a == '\0' already.
   jr nz,zin_parse_word.term_loop
   ; end term loop
   ; INVARIANT: bc points to (one past) end of word.
   ; now need to encode this ZSCII code array into a Z-string.
zin_parse_word.encode:
   ; allocate space on stack
   ld hl,-ZDICT_WORDLEN
   add hl,sp
   ld sp,hl
   ex de,hl
   ld (iy-3),af ; local 0
   ld hl,(iy+0) ; text-buf pointer
   ld (iy+0),bc ; update text-buf pointer
   xor a,a
   ld (bc),a    ; temporarily NUL-terminate word
   ; all args (hl, de, c) set
   ld c,ZDICT_WORDLEN/2 ; in words, not bytes
   call zstr_encode
   ld a,(iy-2) ; local 0 [H byte]
   ld (bc),a    ; restore word terminator
   jr c,zin_parse_word.leave ; ERROR
   ; search for word in dictionary
zin_parse_word.search:
   ld hl,0
   add hl,sp
   call zdict_search
   jr nc,zin_parse_word.found
   ;; check for error
   or a,a
   scf
   jr nz,zin_parse_word.leave ;; ERROR
   ;; not found
   ld hl,0
   ;; found in dictionary
   ;; INVARIANT: hl = pointer to entry in dict
zin_parse_word.found:
   

zin_parse_word.leave:
   ld sp,iy
   pop bc
   pop de
   pop hl
   pop iy
   ret