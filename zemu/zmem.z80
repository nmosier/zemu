;; zmem.z80 -- memory management for zemu & save states
;; TODO -- stack overflow?


ZMEM_SIZE .equ $2000

;; struct zsave {
;;   char map_name[VARNAMELEN];
;;   uint24_t sp;
;;   uint24_t fp;
;;   uint24_t pc;
;;   uint8_t mem_data[ZMEM_SIZE];
;; }

ZSAVE_BEGIN .equ 0
ZSAVE_MAP_NAME .equ ZSAVE_BEGIN
ZSAVE_SPOFF .equ ZSAVE_MAP_NAME + VARNAMELEN
ZSAVE_FPOFF .equ ZSAVE_SPOFF + 3
ZSAVE_MEM_DATA .equ ZSAVE_FPOFF + 3
ZSAVE_END .equ ZSAVE_MEM_DATA + ZMEM_SIZE

ZSAVE_SIZE .equ ZSAVE_END - ZSAVE_BEGIN


;; GLOBAL VARIABLES ;;

;; NOTE: stack grows up.
zstack_begin: .dl 0

zframe_begin:
zframe_fp: .dl 0
zframe_sp: .dl 0
zframe_pc: .dl 0
zframe_nl: .db 0
zframe_rv: .db 0
zframe_end:

ZFRAME_BASESIZE .equ zframe_end - zframe_begin
;;

;; zmem_init -- initialize memory for zemu. Empty call state and program stack.
;; INPUTS: (none)
;; OUTPUTS:
;;  Sets zmem_appvar, zmem_callstate_top, zmem_stack_top.
;; ERROR: a = error code, CF set
;; DESTROYS: (all), OP1
;; TODO: check size bytes of appvar.
zmem_init:
   ; get appvar in RAM
   ld hl,zmem_name
   ld de,ZMEM_SIZE+2 ; +2 for size bytes
   call appvar_touch
   ret c
   ex de,hl
   inc hl ; skip size bytes
   inc hl
   ld (zstack_begin),hl
   ld (zframe_fp),hl
   ld (zframe_sp),hl
   xor a,a
   ld (zframe_nl),a
   ld hl,$ffffff
   ld (zframe_pc),hl
   ret
   

zmem_name: .db "ZEMUM",0

;; zsave_open -- open save file (and perform any call state / stack init.)
;; INPUTS:
;;  hl = name of save
;; OUTPUTS:
;;  zmem_stack_top, zmap_header, zmap_table
;; ERROR: yes.
;; TODO: better error handling.
zsave_open:
   call appvar_to_RAM
   ret c
   inc de
   inc de ; skip size bytes
   push de
   call zmem_init
   pop ix ; ix points to save appvar
   ret c
   ; restore mem (call state & stack)
   lea hl,ix+ZSAVE_MEM_DATA
   ld de,(zstack_begin)
   ld bc,ZMEM_SIZE
   ldir
   ; restore stack pointer
   ld hl,(ix+ZSAVE_SPOFF)
   ld de,(zstack_begin)
   add hl,de
   ld (zframe_sp),hl
   ; restore frame pointer
   ld hl,(ix+ZSAVE_FPOFF)
   add hl,de
   ld (zframe_fp),hl
   ; open zmap file
   lea hl,ix+ZSAVE_MAP_NAME
   call zemu_open
   ret c
   scf \ ccf
   ret

;; zsave_create -- create new save file from current memory state.
;; INPUTS:
;;  hl = new save name
;; OUTPUTS: (none)
;; ERROR: yes.
;; NOTE: zmem_init must alreay have been called.
zsave_create:
   ld.s de,ZSAVE_SIZE+2 ; +2 for size bytes
   push hl
   call appvar_create
   pop hl
   ret c
   inc de
   inc de ; skip size bytes
   push de
   pop ix   ; ld ix,de
   ; store name
   ld hl,zmap_name
   lea de,ix+ZSAVE_MAP_NAME
   ld bc,VARNAMELEN
   call strncpy
   ; store stack ptr offset
   ld hl,(zframe_sp)
   ld de,(zframe_begin)
   scf \ ccf
   sbc hl,de
   ld (ix+ZSAVE_SPOFF),hl
   ; store frame ptr offset
   ld hl,(zframe_fp)
   scf \ ccf
   sbc hl,de
   ld (ix+ZSAVE_FPOFF),hl
   ; store state data
   lea de,ix+ZSAVE_MEM_DATA
   ld hl,(zframe_begin)
   ld bc,ZMEM_SIZE
   ldir
   scf \ ccf ; success
   ret

;; zstack_enter -- enter new stack frame
;; INPUTS:
;;  a = number of local variables
;; OUTPUTS: (none)
;; DESTROYS: hl,de,ix
;; ERRORS: (none)
zstack_enter:
   push bc ; save variable number
   ; push new stack frame onto stack
   ld hl,zframe_begin
   ld de,(zframe_sp)
   ld bc,ZFRAME_BASESIZE
   ldir
   ; de == (zframe_sp) + ZFRAME_BASESIZE
   ; update frame pointer
   ld (zframe_fp),de
   ; update stack pointer
   ld hl,$000002
   ld h,a
   mlt hl
   add hl,de
   ld (zframe_sp),hl
   ; update number of locals (NL)
   ld (zframe_nl),a
   ; update return variable
   pop bc ; restore variable number
   ret   


;; zstack_leave -- leave current stack frame
;; INPUTS: (none)
;; OUTPUTS: (none)
;; DESTROYS: hl,bc,de,ix
;; ERRORS: (none)
zstack_leave:
   ; restore stack frame
   ld ix,(zframe_fp)
   lea hl,ix-ZFRAME_BASESIZE
   ld de,zframe_begin
   ld bc,ZFRAME_BASESIZE
   ldir
   ret


;; zframe_sp_base -- get base of stack pointer
;; INPUTS: (none)
;; OUTPUTS:
;;  hl = pointer to s.p. base
;; ERRORS: no.
;; DESTROYS: (none)
zframe_sp_base:
   push de
   ld hl,0
   ld a,(zframe_nl)
   ld l,a
   add hl,hl
   ld de,(zframe_fp)
   add hl,de
   pop de
   ret

   push ix
   ld ix,(zframe_fp)
   ld hl,0
   ld l,(ix+zframe_nl-zframe_end)
   add hl,hl ; multiply by word size
   ex de,hl
   add ix,de
   ex de,hl
   lea hl,ix
   pop ix
   ret