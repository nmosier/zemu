#include "zobj.inc"


;; zobj_tabaddr -- return logical address of object table
;; INPUTS:
;;  zmap_header set
;; OUTPUTS:
;;  ix = logical address of object table
;; ERRORS: yes.
;; DESTROYS:
zobj_tabaddr:
   ld ix,(zmap_header)
   lea hl,ix+ZHDR_OBJTAB
   call zaddr_fetchw
   ret nc ; error
   call wtolu ; zero-extend address
   add ix,de
   lea ix,ix+ZOBJTAB_PROPDEFAULTS_SIZE
   scf \ ccf ; success
   ret
   
;; zobj_objaddr -- return logical address of object
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  ix = logical address of object
;; ERRORS: yes.
;; DESTROYS: hl,de
zobj_objaddr:
   ld l,a
   ld h,ZOBJSIZE
   or a,a
   ld a,ZERR_BADOBJ
   ccf
   ret z ; error: cannot take address of object 0
   ld a,l
   mlt hl
   call wtolu
   add ix,de
   scf \ ccf
   ret

;; zobj_attr -- find attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS:
;;  hl = logical address of byte containing attribute
;;  a = mask for extracting bit
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_attr:
   call zobj_objaddr
   ret c
   ; find bit offset within byte
   ; boff <- 8 - (attrno % 8) == (8 - attrno) % 8
   ld a,8
   sub a,c
   and a,$07 ; last 3 bits
   call maskb ; 1 << (c % 8)
   ld b,a
   ld a,c
   cp a,32
   ccf
   ld a,ZERR_BADATTR
   ret c
   ; get logical address of byte containing attribute
   srl c
   srl c
   srl c
   ld de,0
   ld e,c
   lea hl,ix+ZOBJ_ATTRS
   add hl,de ; logical address
   ld a,b ; mask
   scf \ ccf
   ret

;; zobj_attrtest -- test attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS:
;;  zero flag set (Z) if attribute is set, reset (NZ) otherwise
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_attrtest:
   call zobj_attr
   ret c
   call zaddr_to_paddr
   ret c
   and a,(hl)
   ret

;; zobj_attrclear -- clear attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS: (none)
;; ERRORS: yes.
;; DESTROYS: (All)
zobj_attrclear:
   call zobj_attr
   ret c
   call zaddr_to_paddr
   ret c
   cpl
   and a,(hl)
   ld (hl),a
   ret

;; zobj_attrset -- set attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS: (none)
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_attrset:
   call zobj_attr
   ret c
   call zaddr_to_paddr
   ret c
   or a,(hl)
   ld (hl),a
   ret


;; zobj_valid -- check whether object number is valid
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  NC if valid, C if valid
;; ERRORS: see OUTPUTS.
;; DESTROYS: (none)
zobj_valid:
   cp a,1
   ret

;; zobj_insert -- transfer childhood of object to another parent
;; INPUTS:
;;  b = object number
;;  c = new parent object number
;; OUTPUTS:
;;  modifies object table
;; ERRORS: yes.
;; DESTROYS: (all)
;; TODO -- this doesn't account for the fact when the object is not the first child of parent
zobj_insert:
   ; 0. Save params
   ld hl,zobj_insert.data
   ld (hl),b
   inc hl
   ld (hl),c
   ; 1. Remove object from parent
   ld a,b
   call zobj_remove
   ret c
   ; 2.   Insert object as first child of new parent
   ; 2.a  Get parent's address
   ld a,(zobj_insert.parent)
   call zobj_objaddr
   ret c
   ; 2.b  Fetch parent's current child
   lea hl,ix+ZOBJ_CHILD
   call zaddr_fetch
   ret c
   ld (zobj_insert.newsib),a
   ; 2.c  Update parent's child
   dec hl
   ld a,(zobj_insert.obj)
   call zaddr_store
   ret c
   ; 2.d  Update child's parent and sibling
   ld a,(zobj_insert.obj)
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_FAMILY
   ld a,(zobj_insert.parent)
   call zaddr_store
   ret c
   ld a,(zobj_insert.newsib)
   call zaddr_store
   ret c
zobj_insert.done:
   scf \ ccf
   ret

zobj_insert.data:
zobj_insert.obj:        .db 0
zobj_insert.parent:     .db 0
zobj_insert.newsib:     .db 0


;; zobj_remove -- remove object from parent
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  object table modified
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_remove:
   ; get object
   call zobj_objaddr
   ret c
   ld de,zobj_remove.data
   ld (de),a ; save obj no
   inc de
   ; get parent and sibling
   lea hl,ix+ZOBJ_FAMILY
   call zaddr_fetch
   ret c
   ld (de),a ; save parent no
   inc de
   call zaddr_fetch
   ret c
   ld (de),a ; save next sib no
   ; find first child of parent
   dec de
   ld a,(de) ; parent no
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_CHILD
   call zaddr_fetch ; current first child
   ret c
   dec hl ; use this later for updating
   ;; TODO -- loop to traverse list.
   ; update parent & sibling list
   ; 2 cases: (i) obj is first child; (ii) otherwise
   ex de,hl ; de = pointer to child byte of parent object
   ld hl,zobj_remove.obj
   cp a,(hl) ; check if current first child == object being removed
   jr nz,zobj_remove.caseii
   ; case (i)
   ex de,hl
   ld a,(zobj_remove.nextsib)
   call zaddr_store
   ret c
   jr zobj_remove.update_obj
zobj_remove.caseii:
   ; case (ii)
   call zobj_objaddr ; address of first sibling object -> ix
   ret c
   ; don't care about a -- loop will overwrite it before using it
   ; loop invariants at special label:
   ;  - hl points to child entry of previous sibling of current object
   ;  - a contains current sibling number
   ; loop terminates when a == object being removed
   ; error if a == 0
zobj_remove.loop:
   lea hl,ix+ZOBJ_SIBLING
   call zaddr_fetch
   ret c
   ex de,hl
   ld hl,zobj_remove.obj
   cp a,(hl)
   ex de,hl
   jr z,zobj_remove.found
   call zobj_objaddr ; handles case when a = 0
   ret c
   jr zobj_remove.loop

zobj_remove.found:
   dec hl
   ld a,(zobj_remove.nextsib)
   call zaddr_store
   ret c

zobj_remove.update_obj:
   ld a,(zobj_remove.obj)
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_FAMILY
   xor a
   call zaddr_store ; no parent
   ret c
   xor a
   call zaddr_store ; no siblings
   ret c
zobj_remove.done:
   scf \ ccf
   ret

zobj_remove.data:
zobj_remove.obj:     .db 0
zobj_remove.parent:  .db 0
zobj_remove.nextsib: .db 0


;--------------------------------;
;        PROPERTY FUNCTIONS      ;
;--------------------------------;

;; zobj_proptab -- get logical address of property table [header]
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  hl = logical address of object's property table
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_proptab:
zobj_proptab_hdr:
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_PROPS
   call zaddr_fetchw ; fetch word
   ret c
   ; zero-extend address
   ex de,hl
   call wtolu
zobj_proptab.done:
   scf \ ccf
   ret

;; zobj_proptab_body -- get logical address of object's property table body
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  hl = logical address of object's property table body
;; DESTROYS: (all)
;; ERRORS: yes.
zobj_proptab_body:
   call zobj_proptab
   ret c
   call zaddr_fetch
   ret c
   ex de,hl
   ld hl,0
   ld l,a
   add hl,hl
   add hl,de
zobj_proptab_body.done:
   scf \ ccf
   ret

;; zobj_propaddr -- get logical address of object property data
;; INPUTS:
;;  a = object number
;;  c = property number
;; OUTPUTS:
;;  hl = logical address of object property data
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_propaddr:
   push bc
   call zobj_proptab_body
   pop de
   ret c
   ; loop invariants:
   ;  - e holds target property number
   ;  - hl holds address of next unexamined entry
   ;  - hl may or may not point to 0
   jr zobj_propaddr.entry
zobj_propaddr.loop:
   ld a,c
   call zobj_propid_to_size
   ld bc,0
   ld c,a
   add hl,bc
zobj_propaddr.entry:
   call zaddr_fetch
   ret c
   or a,a
   jr z,zobj_propaddr.notfound
   ld c,a
   call zobj_propid_to_num
   cp a,e ; are the property numbers equal?
   jr z,zobj_propaddr.found
   jr nc,zobj_propaddr.loop
zobj_propaddr.notfound:
   ; not found
   ld hl,0
zobj_propaddr.found:
   ; found
   scf \ ccf
   ret

;; zobj_propid_to_size -- extract raw byte size from property ID byte
;; INPUTS:
;;  a = property ID byte
;; OUTPUTS:
;;  a = byte size
;; DESTROYS: a
;; ERRORS: no.
zobj_propid_to_size:
   and a,$E0 ; 0b1110.0000
   rlca
   rlca
   rlca
   inc a
   ret
   

;; zobj_propid_to_num -- extract property number from property ID byte
;; INPUTS:
;;  a = property ID byte
;; OUTPUTS:
;;  a = property number
;; DESTROYS: a
;; ERRORS: yes.
zobj_propid_to_num:
   and a,$1F
   ret


;; zobj_propsize -- get size of object property data
;; INPUTS:
;;  a = object number
;;  c = property number
;; OUTPUTS:
;;  a = size of object property data
;; DESTROYS: (all)
;; ERRORS: yes.
zobj_propsize:
   call zobj_propaddr
   ret c
   ld de,1
   ; scf \ ccf
   sbc hl,de ; dec hl with zero flag set
   ld a,ZERR_NOPROP
   ret c ; then hl = 0, so property wasn't found
zobj_propsize.done:
   scf \ ccf
   ret


;; zobj_nextprop -- compute logical address of next prop
;; INPUTS:
;;  hl = logical address of current prop data
;; OUTPUTS:
;;  hl = logical address of next prop data
;; DESTROYS: all but de
;; ERRORS: no.
zobj_nextprop:
   dec hl
   call zaddr_fetch
   ret c
   call zobj_propid_to_size
   inc a
   ld bc,0
   ld c,a
   add hl,bc
   ret

;------------------------------;
;        FAMILY FUNCTIONS      ;
;------------------------------;

;; zobj_parent -- get object's parent
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  a = object's parent (0 if no parent)
;; DESTROYS: (all)
;; ERRORS: yes.
zobj_parent:
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_PARENT
   jp zaddr_fetch

;; zobj_sibling -- get object's sibling
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  a = object's first sibling (0 if no sibling)
;; DESTROYS: (all)
;; ERRORS: yes.
zobj_sibling:
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_SIBLING
   jp zaddr_fetch


;; zobj_child -- get object's first child
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  a = object's first child
;; DESTROYS: (all)
;; ERRORS: yes.
zobj_child:
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_CHILD
   jp zaddr_fetch


;; zobj_ischild -- determine if object A is child of object B
;; INPUTS:
;;  a = parent object
;;  c = potentially child object
;; OUTPUTS:
;;  a = if child, target child object
;;  a = 0 otherwise
;; DESTROYS: (all)
;; ERRORS: yes.
zobj_ischild:
   push bc
   call zobj_child
   pop bc
   ret c
zobj_ischild.loop:
   cp a,c ; is current child the target child?
   ret c ; NC, found
   or a,a
   ret z ; NC, not found
   push bc
   call zobj_sibling   
   pop bc
   ret c
   jr zobj_ischild.loop
