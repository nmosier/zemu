#include "zobj.inc"


;; zobj_tabaddr -- return logical address of object table
;; INPUTS:
;;  zmap_header set
;; OUTPUTS:
;;  ix = logical address of object table
;; ERRORS: yes.
;; DESTROYS:
zobj_tabaddr:
   ld ix,(zmap_header)
   lea hl,ix+ZHDR_OBJTAB
   call zaddr_fetchw
   ret nc ; error
   call wtolu ; zero-extend address
   add ix,de
   lea ix,ix+ZOBJ_PROPDEFAULTS
   scf \ ccf ; success
   ret
   
;; zobj_objaddr -- return logical address of object
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  ix = logical address of object
;; ERRORS: yes.
;; DESTROYS: hl,de
zobj_objaddr:
   ld l,a
   ld h,ZOBJSIZE
   or a,a
   ld a,ZERR_BADOBJ
   ccf
   ret z ; error: cannot take address of object 0
   ld a,l
   mlt hl
   call wtolu
   add ix,de
   scf \ ccf
   ret

;; zobj_attr -- find attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS:
;;  hl = logical address of byte containing attribute
;;  a = mask for extracting bit
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_attr:
   call zobj_objaddr
   ret c
   ; find bit offset within byte
   ; boff <- 8 - (attrno % 8) == (8 - attrno) % 8
   ld a,8
   sub a,c
   and a,$07 ; last 3 bits
   call maskb ; 1 << (c % 8)
   ld b,a
   ld a,c
   cp a,32
   ccf
   ld a,ZERR_BADATTR
   ret c
   ; get logical address of byte containing attribute
   srl c
   srl c
   srl c
   ld de,0
   ld e,c
   lea hl,ix+ZOBJ_ATTRS
   add hl,de ; logical address
   ld a,b ; mask
   scf \ ccf
   ret

;; zobj_attrtest -- test attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS:
;;  zero flag set (Z) if attribute is set, reset (NZ) otherwise
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_attrtest:
   call zobj_attr
   ret c
   call zaddr_to_paddr
   ret c
   and a,(hl)
   ret

;; zobj_attrclear -- clear attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS: (none)
;; ERRORS: yes.
;; DESTROYS: (All)
zobj_attrclear:
   call zobj_attr
   ret c
   call zaddr_to_paddr
   ret c
   cpl
   and a,(hl)
   ld (hl),a
   ret

;; zobj_attrset -- set attribute of object
;; INPUTS:
;;  a = object number
;;  c = attribute number
;; OUTPUTS: (none)
;; ERRORS: yes.
;; DESTROYS: (all)
zobj_attrset:
   call zobj_attr
   ret c
   call zaddr_to_paddr
   ret c
   or a,(hl)
   ld (hl),a
   ret


;; zobj_valid -- check whether object number is valid
;; INPUTS:
;;  a = object number
;; OUTPUTS:
;;  NC if valid, C if valid
;; ERRORS: see OUTPUTS.
;; DESTROYS: (none)
zobj_valid:
   cp a,1
   ret

;; zobj_insert -- transfer childhood of object to another parent
;; INPUTS:
;;  a = child object number
;;  c = new parent object number
;; OUTPUTS:
;;  modifies object table
;; ERRORS: yes.
;; DESTROYS: (all)
;; TODO -- this doesn't account for the fact when the object is not the first child of parent
zobj_insert:
   ; get info about old parent & sibs
   ld hl,zobj_insert.data
   ld (hl),a ; child obj
   call obj_valid
   inc hl
   ld (hl),c ; new parent
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_PARENT
   call zaddr_fetch ; parent object number
   ret c
   ld (zobj_insert.oldparent),a
   call zaddr_fetch ; first sibling object number
   ret c
   ld (zobj_insert.oldsib),a
   ; remove from old parent
   ;; change first child to old child's first sibling
   ld a,(zobj_insert.oldparent)
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_CHILD
   ld a,(zobj_insert.oldsib)
   call zaddr_store
   ret c
   ; add to new parent
   ;; update new charent's pild
   ld a,(zobj_insert.newparent)
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_CHILD
   call zaddr_fetch ; fetch new sibling
   ret c
   ld (zobj_insert.newsib),a
   dec hl
   ld a,(zobj_insert.obj)
   call zaddr_store ; set new child
   ret c
   ;; update object's info
   ld a,(zobj_insert.obj)
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_FAMILY
   ld a,(zobj_insert.newparent)
   call zaddr_store
   ret c
   ld a,(zobj_insert.newsib)
   call zaddr_store
   ret c
zobj_insert.done:
   scf \ ccf
   ret

zobj_insert.data:
zobj_insert.obj:       .db 0
zobj_insert.newparent: .db 0
zobj_insert.oldparent: .db 0
zobj_insert.oldsib:    .db 0
zobj_insert.newsib:    .db 0


;; zobj_remove -- remove object from parent
;; INPUTS:
;;  a = object
;; OUTPUTS:
;;  object table modified
;; ERRORS: yes.
;; DESTROYS:
zobj_remove:
   ; get object
   call zobj_objaddr
   ret c
   ld de,zobj_remove.data
   ld (de),a ; save obj no
   inc de
   ; get parent and sibling
   lea hl,ix+ZOBJ_FAMILY
   call zaddr_fetch
   ret c
   ld (de),a ; save parent no
   inc de
   call zaddr_fetch
   ret c
   ld (de),a ; save next sib no
   ; find first child of parent
   dec de
   ld a,(de) ; parent no
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_CHILD
   call zaddr_fetch ; current first child
   ret c
   dec hl ; use this later for updating
   ;; TODO -- loop to traverse list.
   ; update parent & sibling list
   ; 2 cases: (i) obj is first child; (ii) otherwise
   ex de,hl ; de = pointer to child byte of parent object
   ld hl,zobj_remove.obj
   cp a,(hl) ; check if current first child == object being removed
   jr nz,zobj_remove.caseii
   ; case (i)
   ex de,hl
   ld a,(zobj_remove.nextsib)
   call zaddr_store
   ret c
   jr zobj_remove.update_obj
zobj_remove.caseii:
   ; case (ii)
   call zobj_objaddr ; address of first sibling object -> ix
   ret c
   ; don't care about a -- loop will overwrite it before using it
   ; loop invariants at special label:
   ;  - hl points to child entry of previous sibling of current object
   ;  - a contains current sibling number
   ; loop terminates when a == object being removed
   ; error if a == 0
zobj_remove.loop:
   lea hl,ix+ZOBJ_SIBLING
   call zaddr_fetch
   ret c
   ex de,hl
   ld hl,zobj_remove.obj
   cp a,(hl)
   ex de,hl
   jr z,zobj_remove.found
   call zobj_objaddr ; handles case when a = 0
   ret c
   jr zobj_remove.loop

zobj_remove.found:
   dec hl
   ld a,(zobj_remove.nextsib)
   call zaddr_store
   ret c

zobj_remove.update_obj:
   ld a,(zobj_remove.obj)
   call zobj_objaddr
   ret c
   lea hl,ix+ZOBJ_FAMILY
   xor a
   call zaddr_store ; no parent
   ret c
   xor a
   call zaddr_store ; no siblings
   ret c
zobj_remove.done:
   scf \ ccf
   ret

zobj_remove.data:
zobj_remove.obj:     .db 0
zobj_remove.parent:  .db 0
zobj_remove.nextsib: .db 0