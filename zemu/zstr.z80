; zstr.z80 -- routines for printing ZSCII codes

#include "zstr.inc"

zstr_flags: .db 0
zstr_abbrtab: .dl 0

zstr_abbraddr:
   ld ix,(zmap_header)
   lea ix,ix+ZHDR_ABBR
   ret

;; zstr_printc -- print single zcode of z-string
;; INPUTS:
;;  a = Z-code (0 <= a < 32)
;; OUTPUTS:
;;  updates zstr_{shiftmode,abbrtab}
;; DESTROYS:
;; ERRORS:
zstr_putc:
   ld hl,zstr_flags
   ; 1. Interpet as abbreviation code?
   bit ZSTR_FLAGS_ABBR,(hl)
   jr nz,zstr_putc.abbr_apply
   ; 2. Is it a space?
   or a,a
   jr z,zstr_putc.space
   ; 3. Is it an abbreviation prefix?
   cp a,ZSTR_ABBRMAX+1
   jr c,zstr_putc.abbr_select
   ; 4. Is it a shift code?
   cp a,ZSTR_A1
   jr z,zstr_putc.shift_A1
   cp a,ZSTR_A2
   jr z,zstr_putc.shift_A2
   ; 5. Otherwise, is a character.
zstr_putc.char:
   sub a,ZSTR_AMIN
   bit ZSTR_FLAGS_SHIFT,(hl)
   res ZSTR_FLAGS_SHIFT,(hl)
   jr z,zstr_putc.char.A0
   bit ZSTR_FLAGS_AX,(hl)
   jr z,zstr_putc.char.A1
   jr zstr_putc.char.A2

zstr_putc.shift_A1:
   set ZSTR_FLAGS_SHIFT,(hl)
   res ZSTR_FLAGS_AX,(hl)
   scf \ ccf
   ret

zstr_putc.shift_A2:
   set ZSTR_FLAGS_SHIFT,(hl)
   set ZSTR_FLAGS_AX,(hl)
   scf \ ccf
   ret


zstr_putc.char.A0:
   ld hl,zstr_A0.tab
   jr zstr_putc.char.print

zstr_putc.char.A1:
   ld hl,zstr_A1.tab
   jr zstr_putc.char.print

zstr_putc.char.A2:
   cp a,1
   ld hl,zstr_A2.tab
   jr nz,zstr_putc.char.print
   ;; newline
   call _NewLine
   scf \ ccf
   ret

zstr_putc.char.print:
   ld de,0
   ld e,a
   add hl,de
   ld a,(hl)
   call _PutC
   scf \ ccf
   ret

zstr_putc.space:
   ld a,' '
   call _PutC
   scf \ ccf
   ret

zstr_putc.abbr_apply:
   ; NOTE: %a still holds unmodified 5-bit code.
   res ZSTR_FLAGS_ABBR,(hl)
   ld hl,(zstr_abbrtab)
   rla ; a <- a * WORD_SIZE == a * 2 == a << 1
   ld de,0
   ld e,a
   add hl,de
   call zaddr_fetchwu ; get word address to expanded string
   ret c
   ex de,hl
   ; convert to byte address
   add hl,hl
   call zstr_puts
   ret c
   ld a,(zstr_flags)
   res ZSTR_FLAGS_SHIFT,a
   ld (zstr_flags),a
   ret   


zstr_putc.abbr_select:
   set ZSTR_FLAGS_ABBR,(hl)
   sub a,ZSTR_ABBRMIN
   rrca
   rrca ; a <- a * TABLE SIZE * WORD SIZE == a * 64 == a << 6 == a >> 2
   ld hl,ZHDR_ABBR
   push af
   call zaddr_fetchwu
   pop bc
   ex de,hl
   ld de,0
   ld e,b
   add hl,de
   ld (zstr_abbrtab),hl
   scf \ ccf
   ret

;; zstr_putw -- print Z-string contained in z-word
;; INPUTS:
;;  hl[15:0] = encoded z-string
;;  zstr_shiftmode set
;; OUTPUTS:
;;  Z if end-of-string, NZ otherwise
;;  zstr_shiftmode updated
;; DESTROYS:
;; ERRORS: yes.
zstr_putw:
   ld a,h
   rrca
   rrca
   and a,ZSTR_CODEMASK
   push hl
   call zstr_putc
   pop hl
   ret c
   ld a,h ; lower 2 bits are upper 2 bits of 2nd code
   ld b,l
   rl b
   rla
   rl b
   rla
   rl b
   rla
   and a,ZSTR_CODEMASK
   push hl
   call zstr_putc
   pop hl
   ret c
   ld a,l
   and a,ZSTR_CODEMASK
   push hl
   call zstr_putc
   pop hl
   ret c
   bit 7,h ; whether end of string
   ret
   

;; zstr_puts -- print Z-string
;; INPUTS:
;;  hl points to Z-string
;;  zstr_shiftmode set
;; OUTPUTS:
;;  hl points to word after Z-string
;;  zstr_shiftmode updated
;; DESTROYS:
;; ERRORS: yes.
zstr_puts:
   ld a,(zstr_flags)
   res ZSTR_FLAGS_SHIFT,a
   ld (zstr_flags),a
zstr_puts.loop:
   call zaddr_fetchwu
   ret c
   ex de,hl
   push de
   call zstr_putw
   pop hl
   ret c
   jr z,zstr_puts.loop ; not end of string
zstr_puts.end:
   ret

zstr_puts_phys:
   ld a,(zstr_flags)
   res ZSTR_FLAGS_SHIFT,a
   ld (zstr_flags),a
zstr_puts_phys.loop:
   ld de,0
   ld d,(hl)
   inc hl
   ld e,(hl)
   inc hl
   ex de,hl
   push de
   call zstr_putw
   pop hl
   ret c
   jr z,zstr_puts_phys.loop ; not end of string
zstr_puts_phys.end:
   ret

zstr_A0.tab:
   .db "abcdefghijklmnopqrstuvwxyz"
zstr_A1.tab:
   .db "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
zstr_A2.tab: .db " ^0123456789.,!?_#'\"/\-:()"

;; zstr_putn -- print signed number
;; INPUTS:
;;  hl = signed long to print
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; ERRORS: no.
zstr_putn:
   ; 1. Check sign
   ex de,hl
   ld hl,0
   or a,a ; reset CF
   sbc hl,de
   ; hl = negated val, de = original val
   or a,a ; reset CF
   sbc hl,de
   ; if val is nonnegative, then hl >= de, so CF should be reset (NC)
   ex de,hl
   jr nc,zstr_putn.u
   ex de,hl
   add hl,de ; get back abs val
   ld a,'-'
   call _PutC ; display negative sign
zstr_putn.u:
   ; NOTE: at least one digit will always be written, even if hl = 0.
   ;       this is what we want.
   ld bc,zstr_putn.buf_end
zstr_putn.loop:
   ld de,10
   dec bc
   push bc
   call div_hl_de
   ld bc,0
   or a,a ; reset CF
   sbc hl,bc ; set ZF
   pop bc
   ld a,e
   ld (bc),a
   jr nz,zstr_putn.loop

   ld hl,zstr_putn.buf_end
   sbc hl,bc ; hl holds string length
   push bc
   ld b,l    ; length < 256, so safe downcast
   pop hl
zstr_putn.disploop:
   ld a,(hl)
   add a,'0'
   call _PutC
   inc hl
   djnz zstr_putn.disploop
   ret

zstr_putn.buf:
   .db 0,0,0,0,0,0,0,0
zstr_putn.buf_end:



;; zstr_encode.c -- encode character as unpacked string of Z-codes in zstr_encode.buf
;; INPUTS:
;;  a = ASCII character
;;  hl = buffer pointer (must be at least ZENCODE_MAXCHARLEN in size)
;; OUTPUTS:
;;  b = number of codes written
;; DESTROYS: (all)
;; ERRORS: yes.
zstr_encode.c:
   ; NOTE: checks most likely character class first.
   ; 1. Check character classes.
   JCLASS('a', 'z', zstr_encode.c.lowercase)
   JCLASS('A', 'Z', zstr_encode.c.uppercase)
   JCLASS('0', '9', zstr_encode.c.digit)
   ; 2. Check if space.
   cp a,' '
   jr z,zstr_encode.c.space
   ; 3. Look through character code translation table.
   ex de,hl
   ld hl,zstr_encode.c.tab
   ld b,(hl)
   inc hl
zstr_encode.c.loop:
   cp a,(hl)
   inc hl
   jr z,zstr_encode.c.other
   inc hl
   djnz zstr_encode.c.loop
zstr_encode.c.notfound:
   ld a,ZERR_BADCHAR
   scf
   ret

zstr_encode.c.lowercase:
   add a,6-'a'
   ld (hl),a
   ld b,1
   or a,a
   ret
   
zstr_encode.c.uppercase:
   ld b,ZSTR_A1
   add a,6-'A'
   jr zstr_encode.c.write_pfx

zstr_encode.c.digit:
   ld b,ZSTR_A2
   add a,8-'0'
   jr zstr_encode.c.write_pfx

zstr_encode.c.space:
   ld (hl),0
   ld b,1
   ret

zstr_encode.c.other:
   ld a,ZSTR_A2 ; write prefix
   ld (de),a
   inc de
   ldi ; write character
   ld b,2
   or a,a
   ret

zstr_encode.c.write_pfx:
   ld (hl),b
   inc hl
   ld (hl),a
   ld b,2
   or a,a
   ret


zstr_encode.c.tab:
zstr_encode.c.tab_hdr:
   .db (zstr_encode.c.tab_body_end-zstr_encode.c.tab_body)/ZENCODE_TABENTSIZE
zstr_encode.c.tab_body:
   .db '.', $12
   .db ',', $13
   .db '!', $14
   .db '?', $15
   .db '_', $16
   .db '#', $17
   .db '\'',$18
   .db '\"',$19
   .db '/', $1a
   .db '\\',$1b
   .db '-', $1c
   .db ':', $1d
   .db '(', $1e
   .db ')', $1f
zstr_encode.c.tab_body_end:

;; zstr_encode.w -- Z-encode ASCII chars and coalesce into Z-char (word) if possible
;; INPUTS:
;;  a = ASCII char to encode
;;  hl = buffer begin
;;  de = pointer to packed word (output)
;;  b = count in zcode buffer
;;  c = count in output buffer
;; OUTPUTS:
;;  b, c, de updated properly
;; DESTROYS: (all)
;; ERRORS: yes.
;; NOTE: 0 <= hl - de < 3 upon invokation.
zstr_encode.w:
   push bc
   push hl
   push de
   ld de,0
   ld e,b
   add hl,de
   call zstr_encode.c
   ld a,b
   pop de
   pop ix
   pop bc
   ret c
   add a,b
   ld b,a
   cp a,3  ; enough to reduce?
   ccf
   ret nc
   call zstr_encode.pack
zstr_encode.w.done:
   push de
   push bc
   ld a,b
   sub a,3
   jr z,zstr_encode.w.after_cpy
   lea hl,ix+3
   lea de,ix+0
   ld bc,0
   ld c,a
   ldir
zstr_encode.w.after_cpy:   
   pop bc
   pop de
   ld b,a
   dec c ; update words left
   xor a,a ; NC and Z
   ret

;; zstr_encode.pack -- pack loose Z-codes into Z-string word
;; INPUTS:
;;  ix = pointer to loose Z-code buffer with at least 3 entries (bytes)
;;  de = pointer to word in which to store packed result
;; OUTPUTS:
;;  (de) <- packed Z-code word
;;  de <- de + 2
;; DESTROYS: hl, a
;; ERRORS: no.
zstr_encode.pack:
   ld h,(ix+0)
   rlc h
   rlc h
   ld l,(ix+1)
   rrc l
   rrc l
   rrc l
   ld a,$03
   and a,l
   or a,h
   ld (de),a ; store high byte
   inc de
   ld a,l
   and a,~ZSTR_CODEMASK
   or a,(ix+2)
   ld (de),a ; store low byte
   inc de
   ret

;; zstr_encode -- encode ASCII string as Z-string
;; INPUTS:
;;  hl = source ASCII string
;;  de = destination Z-string
;;  c = destination max size in words
;; OUTPUTS:
;;  Z if full string written; NZ if ran out of space
;; DESTROYS:
;; ERRORS: yes.
zstr_encode:
   ld b,0 ; none in buffer initially
   xor a,a
   cp a,(hl)
   jr z,zstr_encode.empty
   jr zstr_encode.entry
zstr_encode.loop:
   ; INVARIANTS:
   ;  a = current ASCII char (non-null)
   ;  b = number of unpacked z-codes in buffer.
   ;  c = number of words left in output buffer.
   ;  hl = pointer to next (possibly null) character in ASCII string
   ;  de = pointer to next word in Z-string.
   ;  (zstr_encode.len) > 0
   push hl ; ASCII pointer
   ld hl,zstr_encode.buf
   call zstr_encode.w
   pop hl ; ASCII pointer
   ret c
zstr_encode.entry:
   ld a,c
   or a,a
   jr z,zstr_encode.nospace ; out of words
   ld a,(hl)
   inc hl
   or a,a
   jr nz,zstr_encode.loop
zstr_encode.term:
   ld a,b
   or a,a
   jr z,zstr_encode.mark
   ld ix,zstr_encode.buf
   cp a,2
   jr z,zstr_encode.pad2
zstr_encode.pad1:
   ld (ix+1),ZSTR_A2
zstr_encode.pad2:
   ld (ix+2),ZSTR_A2
zstr_encode.do_pack:
   call zstr_encode.pack
zstr_encode.mark:
   ex de,hl
   dec hl
   dec hl
   set 7,(hl)
   xor a,a ; NC, Z (string fit)
   ret
   
zstr_encode.empty:
   ex de,hl
   ld de,ZSTR_EMPTYSTR
   ld (hl),d
   inc hl
   ld (hl),e
   xor a,a ; NC, Z
   ret

zstr_encode.nospace:
   or a,$ff ; NC, NZ -- not enough space
   ret

;; NOTE: codes are not packed; each 5-bit code stored in separate byte.
zstr_encode.buf:
   .db 0,0,0,0,0,0
zstr_encode.buf_end:
