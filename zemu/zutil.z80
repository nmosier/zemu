; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: a, hl, bc, de
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   xor a
   ld bc,VARNAMELEN
appvar_to_OP1.loop:
   ldi
   ret po
   cp (hl)
   jr nz,appvar_to_OP1.loop
   ld b,c ; remainder bytes to zero out
appvar_to_OP1.zero:
   ld (de),a
   inc de
   djnz appvar_to_OP1.zero
   ret

; appvar_to_RAM -- bring appvar into RAM
; INPUTS:
;  hl = name string
; OUTPUTS:
;  de = pointer to appvar data in RAM
; ERROR: a = error code, CF set
; DESTROYS: (all), OP1
appvar_to_RAM:
   call appvar_to_OP1
   call _ChkFindSym
   ld a,ZERR_NOVAR
   ret c ; appvar not found
   call _ChkInRAM
   jr z,appvar_to_RAM.done
   ex de,hl
   ld de,0 ; ld deu,0
   ld e,(hl)
   inc hl
   ld d,(hl)
   call _MemChk
   scf \ ccf
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   call _Arc_Unarc
appvar_to_RAM.done:
   call _ChkFindSym
   ret ; NOTE: CF will always be reset

;; appvar_touch -- create appvar (if doens't already exist) and move it into RAM. 
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; ERROR: yes.
appvar_touch:
   push.s de
   call appvar_to_RAM
   pop.s hl   ; appvar size now in hl.s
   ret nc ; found appvar and is in RAM
   ; check if enough RAM
   push.s hl
   call _MemChk
   pop.s de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c
   ; create var
   ex.s de,hl
   call _CreateAppVar
   scf \ ccf ; success
   ret

;; appvar_create -- create appvar (deleting existing one of same name).
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; DESTROYS: (all)
;; ERROR: yes.
appvar_create:
   push.s de
   call appvar_to_OP1
   call _ChkFindSym
   jr c,appvar_create.deleted
   call _DelVarArc
appvar_create.deleted:
   call _MemChk
   pop.s de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c ; not enough mem
   ex.s de,hl ; hl = size
   call _CreateAppVar
   ; de = ptr to appvar
   ret


;; strncpy -- copy at most n bytes of null-terminated string
;; INPUTS:
;;  hl = src
;;  de = dst
;;  bc = n
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; NOTE: n must be positive. Also, string cannot be empty.
strncpy:
   xor a
strncpy.loop:
   ldi
   ret po
   cp (hl)
   jr nz,strncpy.loop
   ret


;; div -- divide
;; INPUTS:
;;  hl.s = 16-bit dividend
;;  de.s = 16-bit divisor
;; OUTPUTS:
;; DESTROYS: (all)

div:
   ld bc,0
   push bc ; initialize remainder
   ld b,16
div.loop:
   add.s hl,hl
   ex (sp),hl
   rl l
   rl h
   jr c,div.overflow
   ld a,h
   cp d
   jr c,div.skip
   ld a,l
   cp e
   jr c,div.skip
div.overflow:
   xor a ; faster than scf \ ccf
   sbc.s   hl,de
   ex (sp),hl
   inc.s   hl
   djnz  div.loop
   jr div.done
div.skip:
   ex (sp),hl
   djnz div.loop
div.done:
   pop de ; remainder
   ret

;; cp_hl_de -- compare hl to de
;; INPUTS:
;;  hl, de
;; OUTPUTS:
;;  C if hl < de (NC if hl >= de)
;;  Z if hl = de (NZ if hl != de)
;; DESTROYS:
cp_hl_de:
   ld (cp_hl_de.hl),hl
   ld (cp_hl_de.de),de
   ld hl,cp_hl_de.hl+2
   ld de,cp_hl_de.de+2
   ld b,3
cp_hl_de.loop:
   ; if (hl) > (de) or (de) > (hl), easy
   ld a,(de)
   cp (hl) ; cp (de),(hl), i.e. (de) - (hl)
   jr nz,cp_hl_de.nz
   ; (hl) = (de)
   dec hl
   dec de
   djnz cp_hl_de.loop
   ; but then (hl+i)=(de+i) for all i in 0..2, so hl = de
   ; furthermore, Z already set and NC
   scf \ ccf
   ret
cp_hl_de.nz:
   ; if C, then (hl) > (de), so hl > de
   ccf ; so we flip the carry flag
   ret ; and the flags are properly set now

cp_hl_de.hl: .dl 0
cp_hl_de.de: .dl 0
