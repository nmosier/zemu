#include "zemu.inc"
#include "zutil.inc"

; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: a, hl, bc, de
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   xor a
   ld bc,VARNAMELEN
appvar_to_OP1.loop:
   ldi
   ret po
   cp (hl)
   jr nz,appvar_to_OP1.loop
   ld b,c ; remainder bytes to zero out
appvar_to_OP1.zero:
   ld (de),a
   inc de
   djnz appvar_to_OP1.zero
   ret

; appvar_to_RAM -- bring appvar into RAM
; INPUTS:
;  hl = name string
; OUTPUTS:
;  de = pointer to appvar data in RAM
; ERROR: a = error code, CF set
; DESTROYS: (all), OP1
appvar_to_RAM:
   call appvar_to_OP1
   call _ChkFindSym
   ld a,ZERR_NOVAR
   ret c ; appvar not found
   call _ChkInRAM
   jr z,appvar_to_RAM.done
   ex de,hl
   ld de,0 ; ld deu,0
   ld e,(hl)
   inc hl
   ld d,(hl)
   call _MemChk
   scf \ ccf
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   call _Arc_Unarc
appvar_to_RAM.done:
   call _ChkFindSym
   ret ; NOTE: CF will always be reset

;; appvar_touch -- create appvar (if doens't already exist) and move it into RAM. 
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; ERROR: yes.
;; TODO: fix this -- shouldn't be using short instruction.
appvar_touch:
   push.s de
   call appvar_to_RAM
   pop.s hl   ; appvar size now in hl.s
   ret nc ; found appvar and is in RAM
   ; check if enough RAM
   push.s hl
   call _MemChk
   pop.s de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c
   ; create var
   ex.s de,hl
   call _CreateAppVar
   scf \ ccf ; success
   ret

;; appvar_create -- create appvar (deleting existing one of same name).
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; DESTROYS: (all)
;; ERROR: yes.
appvar_create:
   push.s de
   call appvar_to_OP1
   call _ChkFindSym
   jr c,appvar_create.deleted
   call _DelVarArc
appvar_create.deleted:
   call _MemChk
   pop.s de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c ; not enough mem
   ex.s de,hl ; hl = size
   call _CreateAppVar
   ; de = ptr to appvar
   ret


;; strncpy -- copy at most n bytes of null-terminated string
;; INPUTS:
;;  hl = src
;;  de = dst
;;  bc = n
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; NOTE: n must be positive. Also, string cannot be empty.
strncpy:
   xor a
strncpy.loop:
   ldi
   ret po
   cp (hl)
   jr nz,strncpy.loop
   ret


;; mul_hl_de -- multiply hl by de (signed), placing the result in hl
;; INPUTS:
;;  hl, de (24-bit)
;; OUTPUTS:
;;  hl <- hl * de
;; DESTROYS: (all)
;; ERRORS: no.
mul_hl_de:
	ld bc,0
	push bc ; top of stack stores accumulator
	xor a
	ld b,24
mul_hl_de.loop:
	add hl,hl
	ex (sp),hl
	jr nc,mul_hl_de.loop.skip
	add hl,hl
	add hl,de
	ex (sp),hl
	djnz mul_hl_de.loop
	jr mul_hl_de.done
mul_hl_de.loop.skip:
	add hl,hl
	ex (sp),hl
	djnz mul_hl_de.loop
mul_hl_de.done:
	pop hl ; restore result
	ret

;; memcpl_short -- complement up to 256 bytes of memory
;; INPUTS:
;;  hl = pointer
;;  b = count
;; OUTPUTS:
;;  hl <- hl + b
;; DESTROYS: a, b, hl
memcpl_short:
memcpl_short.loop:
   ld a,(hl)
   cpl
   ld (hl),a
   inc hl
   djnz memcpl_short.loop
   ret

;; memneg_short -- negate up to 256 bytes of memory
;; INPUTS:
;;  hl = pointer
;;  b = count
;; OUTPUTS:
;; DESTROYS: a, bc, hl
memneg_short:
   ld c,b
   push hl
   call memcpl_short
   pop hl
memneg_short.loop:
   inc (hl)
   ret po ; no overflow
   inc hl
   dec c
   jr nz,memneg_short.loop
   ret

;; memset_short -- set up to 256 bytes of memory to a value
;; INPUTS:
;;  hl = pointer to memory
;;  b = count (in bytes)
;;  a = value
;; OUTPUTS:
;;  hl <- hl + b
;;  b <- 0
;; DESTROYS: hl, b
;; ERRORS: no.
memset_short:
memset_short.loop:
   ld (hl),a
   inc hl
   djnz memset_short.loop
   ret

;; div_hl_de -- divide hl by de using 24-bit signed division
;; INPUTS:
;;  hl (dividend), de (divisor)
;; OUTPUTS:
;;  hl <- hl / de
;;  de <- hl % de
;; DESTROYS: (all)
;; ERRORS: no???
;; TODO: divide by zero error
div_hl_de:
   ld bc,0
   ex de,hl
   or a,a
   sbc hl,bc ; cp de,bc
   ld a,ZERR_DIVZERO
   ccf
   ret z
   ex de,hl
	xor a ; initialize A to store sign
div_hl_de.signs:
   call absl
   jr nc,div_hl_de.signs.de
   cpl
div_hl_de.signs.de:
   ex de,hl
   call absl
   jr nc,div_hl_de.signs.done
   cpl
div_hl_de.signs.done:
   ex de,hl
div_hl_de.loopinit:
	push af ; save sign bit
	ld bc,0
	push bc ; initialize accumulator on stack
	xor a
	ld	b,24
div_hl_de.loop:
   ; INVARIANTS:
   ;  (sp) -- remainder
   ;  hl -- dividend
   ;  de -- divisor
	add hl,hl ; sets/resets carry flag for rl
	ex	(sp),hl
   adc hl,hl ; rl h \ rl l
	jr	c,div_hl_de.overflow
   call cp_hl_de
   jr c,div_hl_de.skip
div_hl_de.overflow:
   ; overflow and when rem > divisor
	xor a ; faster
	sbc	hl,de
	ex	(sp),hl
	inc	hl
	djnz	div_hl_de.loop
	jr div_hl_de.done
div_hl_de.skip:
	ex	(sp),hl
	djnz div_hl_de.loop
div_hl_de.done:
	pop de ; remainder?
	pop af ; restore sign of result
	or a
	ret z ; if positive, return result
   push de
	ex de,hl
	ld hl,0
	sbc hl,de ; else negate result
   ex de,hl
   pop bc ; restore remainder
   ld hl,0
   sbc hl,bc ; negate remainder
   ex de,hl
	ret

div_hl_de.hl: .dl 0
div_hl_de.de: .dl 0


;; cp_hl_de -- flags(hl - de)
;; INPUTS:
;;  hl, de
;; OUTPUTS:
;;  all flags
;; DESTROYS: (none)
;; ERRORS: no.
cp_hl_de:
   or a,a
   sbc hl,de
   push af
   add hl,de
   pop af
   ret


;; cp_hl_de_sgn -- signed flags(hl - de)
;; TODO -- there must be a more elegant way to do this.
cp_hl_de_sgn:
   push ix
   ld ix,cp_hl_de_sgn.tab
cp_hl_de_sgn.lhs:
   call sgnl ; sign of lhs
   jr nc,cp_hl_de_sgn.rhs
   lea ix,ix+(2*3)
cp_hl_de_sgn.rhs:
   ex de,hl
   call sgnl
   ex de,hl
   jr nc,cp_hl_de_sgn.op
   lea ix,ix+(1*3)
cp_hl_de_sgn.op:
   jp (ix)

cp_hl_de_sgn.tab:
   .dl cp_hl_de_sgn.pp
   .dl cp_hl_de_sgn.pn
   .dl cp_hl_de_sgn.np
   .dl cp_hl_de_sgn.nn

cp_hl_de_sgn.pp:
   jp cp_hl_de
   
cp_hl_de_sgn.pn:
   push de
   ld de,0
   inc hl
   call cp_hl_de
   dec hl
   pop de
   ret

cp_hl_de_sgn.np:
   push hl
   ld hl,0
   inc de
   call cp_hl_de
   dec de
   pop hl
   ret

cp_hl_de_sgn.nn: ; flags(-1 - -2) == flags(1) == flags(2 - 1) 
   call negl
   ex de,hl
   call negl
   jp cp_hl_de


;; absl -- absolute value of long
;; INPUTS:
;;  hl = signed long
;; OUTPUTS:
;;  hl <- |hl|
;; DESTROYS: (none)
;; FLAGS: C if negative, NC otherwise
;; ERRORS: no.
absl:
   call sgnl
   jp c,negl ; flag: C
   ; flag: NC
   ret

;; sgnl -- sign of long
;; INPUTS:
;;  hl = long
;; OUTPUTS:
;;  C if negative
;;  NC if nonnegative
;; DESTROYS: (none)
;; ERRORS: no.
sgnl:
   push de
   ld de,LONG_MAX
   call cp_hl_de
   pop de
   ccf
   ret

;; negl -- negate long
;; INPUTS:
;;  hl = long
;; OUTPUTS:
;;  hl <- -hl
;; DESTROYS: (none)
;; ERRORS: no.
;; FLAGS: C if hl != 0
negl:
   push de
   ex de,hl
   ld hl,0
   or a,a
   sbc hl,de
   pop de
   ret


;; wtols -- word to long, signed
;; INPUTS:
;;  hl[15:0] = 16-bit word, signed
;; OUTPUTS:
;;  de = 24-bit long, sign-extended from hl[15:0]
;; DESTROYS: de
wtols:
   ld de,0
   bit 7,h
   jr z,wtols.transfer
   dec de ; de <- $FFFFFF
wtols.transfer:
   ld d,h
   ld e,l
wtols.done:
   ret

;; wtolu -- word to long, unsigned
;; INPUTS:
;;  hl[15:0] = 16-bit word, unsigned
;; OUTPUTS:
;;  de = 24-bit unsigned long from hl[15:0]
;; DESTROYS: de
wtolu:
   ld de,0
   ld d,h
   ld e,l
   ret

;; btols -- byte to long, signed
;; INPUTS:
;;  a = byte, signed
;; OUTPUTS:
;;  hl = 24-bit long, sign-extended from %a
;; DESTROYS: hl
btols:
   ld hl,0
   bit 7,a
   jr z,btols.transfer
   dec hl ; hl <- $FFFFFF
btols.transfer:
   ld l,a
btols.done:
   ret

;; btolu -- byte to long, unsigned
;; INPUTS:
;;  a = byte, unsigned
;; OUTPUTS:
;;  hl = 24-bit unsigned long from %a
;; DESTROYS: hl
;; ERRORS: no.
btolu:
   ld hl,0
   ld l,a
   ret

;; ltobu -- long to byte, unsigned
;; INPUTS:
;;  hl = 24-bit unsigned long
;; OUTPUTS:
;;  a = hl[7:0]
;;  C if downcast fails; NC otherwise
;; DESTROYS: a
;; ERRORS: no.
ltobu:
   ld a,l
   push de
   ld de,$000100
   call cp_hl_de
   pop de
   ccf
   ret



;; maskb/exp2b -- get bitmask / find 2^n
;; INPUTS:
;;  a = bit/power
;; OUTPUTS:
;;  a = 2^n / 1 << n
;; ERRORS:
;; DESTROYS: hl,de
maskb:
exp2b:
   ld hl,exp2b.tab
   ld de,0
   ld e,a
   add hl,de
   ld a,(hl)
   ret

exp2b.tab:
   .db $01
   .db $02
   .db $04
   .db $08
   .db $10
   .db $20
   .db $40
   .db $80


;; cftoa -- carry flag to a
;; INPUTS:
;;  carry flag (CF)
;; OUTUTS:
;;   if C, a <- $FF
;;   if NC, a <- $00
;; DESTROYS: a
;; ERRORS: no.
cftoa:
   ld a,$FF
   ret c
   xor a
   ret

