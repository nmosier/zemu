; appvar_to_OP1 -- put AppVarObj token followed by varname in OP1
; INPUTS:
;  hl = name string (8 chars)
; OUTPUTS: (none)
; DESTROYS: a, hl, bc, de
appvar_to_OP1:
   ld de,OP1
   ld a,AppVarObj
   ld (de),a
   inc de
   xor a
   ld bc,VARNAMELEN
appvar_to_OP1.loop:
   ldi
   ret po
   cp (hl)
   jr nz,appvar_to_OP1.loop
   ld b,c ; remainder bytes to zero out
appvar_to_OP1.zero:
   ld (de),a
   inc de
   djnz appvar_to_OP1.zero
   ret

; appvar_to_RAM -- bring appvar into RAM
; INPUTS:
;  hl = name string
; OUTPUTS:
;  de = pointer to appvar data in RAM
; ERROR: a = error code, CF set
; DESTROYS: (all), OP1
appvar_to_RAM:
   call appvar_to_OP1
   call _ChkFindSym
   ld a,ZERR_NOVAR
   ret c ; appvar not found
   call _ChkInRAM
   jr z,appvar_to_RAM.done
   ex de,hl
   ld de,0 ; ld deu,0
   ld e,(hl)
   inc hl
   ld d,(hl)
   call _MemChk
   scf \ ccf
   sbc hl,de
   ld a,ZERR_NOMEM
   ret c
   call _Arc_Unarc
appvar_to_RAM.done:
   call _ChkFindSym
   ret ; NOTE: CF will always be reset

;; appvar_touch -- create appvar (if doens't already exist) and move it into RAM. 
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; ERROR: yes.
appvar_touch:
   push.s de
   call appvar_to_RAM
   pop.s hl   ; appvar size now in hl.s
   ret nc ; found appvar and is in RAM
   ; check if enough RAM
   push.s hl
   call _MemChk
   pop.s de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c
   ; create var
   ex.s de,hl
   call _CreateAppVar
   scf \ ccf ; success
   ret

;; appvar_create -- create appvar (deleting existing one of same name).
;; INPUTS:
;;  hl = name string
;;  de.s = size of appvar
;; OUTPUTS:
;;  de = pointer to appvar data
;; DESTROYS: (all)
;; ERROR: yes.
appvar_create:
   push.s de
   call appvar_to_OP1
   call _ChkFindSym
   jr c,appvar_create.deleted
   call _DelVarArc
appvar_create.deleted:
   call _MemChk
   pop.s de
   sbc.s hl,de
   ld a,ZERR_NOMEM
   ret c ; not enough mem
   ex.s de,hl ; hl = size
   call _CreateAppVar
   ; de = ptr to appvar
   ret


;; strncpy -- copy at most n bytes of null-terminated string
;; INPUTS:
;;  hl = src
;;  de = dst
;;  bc = n
;; OUTPUTS: (none)
;; DESTROYS: (all)
;; NOTE: n must be positive. Also, string cannot be empty.
strncpy:
   xor a
strncpy.loop:
   ldi
   ret po
   cp (hl)
   jr nz,strncpy.loop
   ret


;; mul_hl_de -- multiply hl by de (signed), placing the result in hl
;; INPUTS:
;;  hl, de (24-bit)
;; OUTPUTS:
;;  hl <- hl * de
;; DESTROYS: (all)
;; ERRORS: no.
mul_hl_de:
	ld bc,0
	push bc ; top of stack stores accumulator
	xor a
	ld b,24
mul_hl_de.loop:
	add hl,hl
	ex (sp),hl
	jr nc,mul_hl_de.loop.skip
	add hl,hl
	add hl,de
	ex (sp),hl
	djnz mul_hl_de.loop
	jr mul_hl_de.done
mul_hl_de.loop.skip:
	add hl,hl
	ex (sp),hl
	djnz mul_hl_de.loop
mul_hl_de.done:
	pop hl ; restore result
	ret

;; memcpl_short -- complement up to 256 bytes of memory
;; INPUTS:
;;  hl = pointer
;;  b = count
;; OUTPUTS:
;;  hl <- hl + b
;; DESTROYS: a, b, hl
memcpl_short:
memcpl_short.loop:
   ld a,(hl)
   cpl
   ld (hl),a
   inc hl
   djnz memcpl_short.loop
   ret

;; memneg_short -- negate up to 256 bytes of memory
;; INPUTS:
;;  hl = pointer
;;  b = count
;; OUTPUTS:
;; DESTROYS: a, bc, hl
memneg_short:
   ld c,b
   push hl
   call memcpl_short
   pop hl
memneg_short.loop:
   inc (hl)
   ret po ; no overflow
   inc hl
   dec c
   jr nz,memneg_short.loop
   ret

;; memset_short -- set up to 256 bytes of memory to a value
;; INPUTS:
;;  hl = pointer to memory
;;  b = count (in bytes)
;;  a = value
;; OUTPUTS:
;;  hl <- hl + b
;;  b <- 0
;; DESTROYS: hl, b
;; ERRORS: no.
memset_short:
memset_short.loop:
   ld (hl),a
   inc hl
   djnz memset_short.loop
   ret



;; div_hl_de -- divide hl by de using 24-bit signed division
;; INPUTS:
;;  hl (dividend), de (divisor)
;; OUTPUTS:
;;  hl <- hl / de
;;  de <- hl % de
;; DESTROYS: (all)
;; ERRORS: no???
;; TODO: divide by zero error
div_hl_de:
   ld bc,0
   ex de,hl
   sbc hl,bc ; cp de,bc
   ld a,ZERR_DIVZERO
   ccf
   ret z
   ex de,hl
	xor a ; initialize A to store sign
div_hl_de.signs:
   ld (div_hl_de.hl),hl
   ld (div_hl_de.de),de
   ld hl,div_hl_de.hl
   ld b,3
   call memabs_short
   ld hl,div_hl_de.de
   ld b,3
   call memabs_short
   ld hl,(div_hl_de.hl)
   ld de,(div_hl_de.de)
div_hl_de.loopinit:
	push af ; save sign bit
	ld bc,0
	push bc ; initialize accumulator on stack
	xor a
	ld	b,24
div_hl_de.loop:
   ; INVARIANTS:
   ;  (sp) -- remainder
   ;  hl -- dividend
   ;  de -- divisor
	add hl,hl ; sets/resets carry flag for rl
	ex	(sp),hl
   adc hl,hl ; rl h \ rl l
	jr	c,div_hl_de.overflow
   call cp_hl_de
   jr c,div_hl_de.skip
div_hl_de.overflow:
   ; overflow and when rem > divisor
	xor a ; faster
	sbc	hl,de
	ex	(sp),hl
	inc	hl
	djnz	div_hl_de.loop
	jr div_hl_de.done
div_hl_de.skip:
	ex	(sp),hl
	djnz div_hl_de.loop
div_hl_de.done:
	pop de ; remainder?
	pop af ; restore sign of result
	or a
	ret z ; if positive, return result
   push de
	ex de,hl
	ld hl,0
	sbc hl,de ; else negate result
   ex de,hl
   pop bc ; restore remainder
   ld hl,0
   sbc hl,bc ; negate remainder
   ex de,hl
	ret

div_hl_de.hl: .dl 0
div_hl_de.de: .dl 0


;; memabs_short -- find absolute value of up to 256-byte integer in memory
;; INPUTS:
;;  hl = pointer to little endian integer in memory
;;  b = count (1 <= b <= 256)
;; OUTPUTS:
;;  if (hl) < 0, a <- ~a, (hl) <- ~(hl)
;; DESTROYS: (all)
;; ERRORS: no.
memabs_short:
   ld de,0
   ld e,b
   dec e
   add hl,de
   bit 7,(hl)
   ret z ; (hl) >= 0
   scf \ ccf
   sbc hl,de
   push af
   call memneg_short
   pop af
   xor a,$ff
   ret


;; cp_hl_de
cp_hl_de:
   scf \ ccf
   sbc hl,de
   push af
   add hl,de
   pop af
   ret

;; wtols -- word to long, signed
;; INPUTS:
;;  hl[15:0] = 16-bit word, signed
;; OUTPUTS:
;;  de = 24-bit long, sign-extended from hl[15:0]
;; DESTROYS: de
wtols:
   ld de,0
   bit 7,h
   jr z,wtols.transfer
   dec de ; de <- $FFFFFF
wtols.transfer:
   ld d,h
   ld e,l
wtols.done:
   ret

;; wtolu -- word to long, unsigned
;; INPUTS:
;;  hl[15:0] = 16-bit word, unsigned
;; OUTPUTS:
;;  de = 24-bit unsigned long from hl[15:0]
;; DESTROYS: de
wtolu:
   ld de,0
   ld d,h
   ld e,l
   ret

;; btols -- byte to long, signed
;; INPUTS:
;;  a = byte, signed
;; OUTPUTS:
;;  hl = 24-bit long, sign-extended from %a
;; DESTROYS: hl
btols:
   ld hl,0
   bit 7,a
   jr z,btols.transfer
   dec hl ; hl <- $FFFFFF
btols.transfer:
   ld l,a
btols.done:
   ret

;; btolu -- byte to long, unsigned
;; INPUTS:
;;  a = byte, unsigned
;; OUTPUTS:
;;  hl = 24-bit unsigned long from %a
;; DESTROYS: hl
btolu:
   ld hl,0
   ld l,a
   ret


;; maskb/exp2b -- get bitmask / find 2^n
;; INPUTS:
;;  a = bit/power
;; OUTPUTS:
;;  a = 2^n / 1 << n
;; ERRORS:
;; DESTROYS: hl,de
maskb:
exp2b:
   ld hl,exp2b.tab
   ld de,0
   ld e,a
   add hl,de
   ld a,(hl)
   ret

exp2b.tab:
   .db $01
   .db $02
   .db $04
   .db $08
   .db $10
   .db $20
   .db $40
   .db $80
   