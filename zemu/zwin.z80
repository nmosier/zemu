A;; zwin.z80 -- window management routines
;; TODO -- need to unscale rows


#include "zwin.inc"
#include "zstr.inc"

;; zwin_select -- select window for displaying characters
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: (none)
;; ERRORS: no.
zwin_select:
   push af
   push hl
   ld a,(ix+ZWIN.CURROW)
   ld (penRow),a
   ld hl,(ix+ZWIN.CURCOL)
   ld (penCol),hl
   pop hl
   pop af
   ret

;; zwin_clear -- clear window
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: a, hl, de, bc
;; ERRORS: no.
zwin_clear:
   ld hl,$ffff
   call zwin_fill
   jp zwin_org
   

;; zwin_fill -- fill window
;; INPUTS:
;;  hl = value to fill with
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: a, hl, de, bc
;; ERRORS: no.
zwin_fill:
   push ix
   lea ix,ix+ZWIN.RECT
   call zdisp_fillrect
   pop ix
   ret
   
;; zwin_org -- set window's cursor back to the origin
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: a, hl
;; ERRORS: no.
zwin_org:
   ld hl,(ix+ZWIN.ORGCOL)
   ld (ix+ZWIN.CURCOL),hl
   ld a,(ix+ZWIN.ORGROW)
   ld (ix+ZWIN.CURROW),a
   ret

;; zwin_putc -- put character in window, buffered
;; zwin_putc_bare -- put character in window, unbuffered
;; INPUTS:
;;  ix = pointer to window struct
;;  a = character
;; OUTPUTS: (none)
;; DESTROYS: all but a,ix
;; ERRORS: no.
zwin_putc:
   scf
   jr zwin_putc.base

zwin_putc_bare:
   or a,a
   jr zwin_putc.base

;; preserves %a
zwin_putc.base:
   push bc \ push hl \ push de
   push af
   ; 1.  Check if newline.
   cp a,ASCII_NEWLINE
   jr z,zwin_putc.newline
   ; 2. Check if delete.
   cp a,ASCII_DEL
   jr z,zwin_putc.del
   ; 3. Check if clear.
   cp a,ASCII_CLEAR
   jr z,zwin_putc.clear
   ; Otherwise
   push ix
   ld hl,(ix+ZWIN.CURCOL)
   ld de,(ix+ZWIN.ORGCOL)
   or a,a
   sbc hl,de ; find current width of line
   ld bc,0
   call sfont_width ; bc = character width
   push bc
   add hl,bc
   ld bc,(ix+ZWIN.WIDTH)
   scf
   sbc hl,bc ; new strlen - width - 1
   call nc,zwin_newline_bare ; don't buffer
   call zwin_select ; select window for writing
   call _VPutMap ; display char
   pop bc
   pop ix
   ; update current column
   ld hl,(ix+ZWIN.CURCOL)
   add hl,bc
   ld (ix+ZWIN.CURCOL),hl
zwin_putc.done:
   pop af
   ; Buffer char
   call c,zwin_bufc
zwin_putc.done_nbuf:
   pop de \ pop hl \ pop bc
   ret

zwin_putc.newline:
   call zwin_newline_bare ; already buffered
   jr zwin_putc.done

zwin_putc.del:
   call zwin_unputc
   pop af
   jr zwin_putc.done_nbuf

zwin_putc.clear:
   call zwin_clear
   pop af
   jr zwin_putc.done_nbuf

;; zwin_unputc -- remove last character from window
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; ERRORS:
;; DESTROYS:
;; NOTES: erases character on screen.
;; TODO: optimization.
zwin_unputc:
   push hl \ push de
   ld hl,(ix+ZWIN.BUFPTR)
   lea de,ix+ZWIN.BUF
   or a,a
   sbc hl,de
   jr z,_ ; nothing to unput
   add hl,de
   dec hl
   ld (ix+ZWIN.BUFPTR),hl
   call zwin_redraw
_  pop de \ pop hl
   ret

;; zwin_newline -- put newline in window, buffered
;; zwin_newline_bare -- put newline in window, unbuffered
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: all but ix and %a
;; ERRORS: no.
;; TODO: buffer this.
zwin_newline:
   scf
zwin_newline.base:
   push af
   ld a,ASCII_NEWLINE
   call c,zwin_bufc ; put newline character in buffer
zwin_newline.loop:
   ld a,(ix+ZWIN.CURROW)
   sub a,(ix+ZWIN.ORGROW)   
   add a,SFONT_HEIGHT
   cp a,(ix+ZWIN.HEIGHT)
   jr c,zwin_newline.curset
   ; test if window is single line
   ld a,(ix+ZWIN.HEIGHT)
   cp a,SFONT_HEIGHT*2
   jr c,zwin_newline.oneline
   ; scroll
   call zwin_scroll
   jr zwin_newline.loop ; retry now
zwin_newline.curset:
   add a,(ix+ZWIN.ORGROW)
   ld (ix+ZWIN.CURROW),a
   ld hl,(ix+ZWIN.ORGCOL)
   ld (ix+ZWIN.CURCOL),hl
   pop af
   ret

zwin_newline.oneline:
   call zwin_clear
   pop af
   ret

zwin_newline_bare:
   or a,a ; NC
   jr zwin_newline.base

;; zwin_scroll -- scroll down one line of text in window
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: all but ix
zwin_scroll:
   call zwin_trunc
   jp zwin_redraw

;; zwin_redraw -- clear and then display contents of window
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: all but ix
;; TODO: this could be optimized to just copy contents in VRAM.
zwin_redraw:
   call zwin_clear
   call zwin_org ; reset internal cursor to origin
   lea bc,ix+ZWIN.BUF
   ld hl,(ix+ZWIN.BUFPTR)
   or a,a ; NC
   sbc hl,bc
   push hl \ pop bc
   lea hl,ix+ZWIN.BUF
   jp zwin_putsn_bare

;; zwin_bufc -- put character in buffer
;; INPUTS:
;;  ix = pointer to window struct
;;  a = character
;; OUTPUTS: (none)
;; DESTROYS: all but a
;; ERRORS: no.
;; NOTE: This never fails. If there isn't enough space in the buffer,
;;       it truncates it first then appends the character.
zwin_bufc:
   bit ZWIN.FLAGS.BUFD,(ix+ZWIN.FLAGS)
   ret z ; this window isn't buffered
   lea hl,ix+ZWIN.BUF
   ld de,(ix+ZWIN.BUFLEN)
   add hl,de
   ex de,hl
   ld hl,(ix+ZWIN.BUFPTR)
   sbc hl,de
   call nc,zwin_trunc ; a preserved
   ld hl,(ix+ZWIN.BUFPTR)
   ld (hl),a
   inc hl
   ld (ix+ZWIN.BUFPTR),hl
   ret


;; zwin_eol -- find end of first line
;; INPUTS:
;;  de = buffer begin pointer
;;  bc = buffer end pointer
;;  hl = width of window
;; OUTPUTS:
;;  hl = pointer to end of first line
;;  CF indicates whether line was overflown
;; DESTROYS: all but a
;; ERRORS: no.
zwin_eol:
   jr zwin_eol.entry
zwin_eol.loop:
   ; hl = remaining width
   ; de = buffer pointer
   ; bc = buffer end
   ; 1. Check if newline. Note that we do want to delete this char (i.e. inc de).
   ld a,(de)
   cp a,ASCII_NEWLINE
   jr z,zwin_eol.inc_found
   push bc
   ld bc,0 ; zero-extend char width
   call sfont_width
   or a,a ; NC
   sbc hl,bc
   pop bc
   jr c,zwin_eol.found ; found 1st character that doens't find on line
   inc de ; otherwise, need to consider next character
zwin_eol.entry:
   ; compare buffer pointer with buffer end
   ex de,hl
   or a,a
   sbc hl,bc
   add hl,bc
   ex de,hl
   jr nz,zwin_eol.loop
   ; reached end of buffer without overflowing first line
zwin_eol.end:
   ex de,hl
   ; hl = pointer to end of buffer
   scf ; C
   ret
zwin_eol.inc_found:
   inc de
zwin_eol.found:
   ex de,hl
   ; hl = pointer to end of line
   or a,a ; NC
   ret

;; zwin_trunc -- truncate line from buffer
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS: (none)
;; DESTROYS: all but a
;; ERRORS: no.
;; NOTE: doesn't trigger redisplay of window.
zwin_trunc:
   bit ZWIN.FLAGS.BUFD,(ix+ZWIN.FLAGS)
   ret z ; can't truncate if not buffered
   ; hl = width of window
   ; de = buffer begin
   ; bc = buffer end
   ld hl,(ix+ZWIN.WIDTH)
   lea de,ix+ZWIN.BUF
   ld bc,(ix+ZWIN.BUFPTR)
   call zwin_eol
   ; hl = (one past) end of first line
   ; need to erase all bytes between ix+ZWIN.BUF and hl
   ex de,hl
   ld hl,(ix+ZWIN.BUFPTR)
   or a,a
   sbc hl,de ; hl = # of bytes to keep
   push hl \ pop bc
   ; bc = count
   ; de = EOL ptr
   push de ; save EOL ptr
   ex de,hl ; hl = EOL ptr
   lea de,ix+ZWIN.BUF
   sbc hl,de ; size of bytes to delete
   ex de,hl
   ld hl,(ix+ZWIN.BUFPTR)
   or a,a
   sbc hl,de ; shifted bufptr
   ld (ix+ZWIN.BUFPTR),hl ; save new bufptr
   pop hl ; restore EOL ptr
   lea de,ix+ZWIN.BUF
   ; hl = EOL ptr
   ; de = buf begin
   ; bc = number of bytes to keep
   jp memmove
   

;; zwin_puts -- put string in window, buffered, null-terminated
;; zwin_puts_bare -- put string in window, unbuffered
;; INPUTS:
;;  ix = pointer to window struct
;;  hl = pointer to string
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: all but ix
zwin_puts:
   jr zwin_puts.entry
zwin_puts.loop:
   ;; DEBUG HOOK
   cp a,'r'
   jr nz,_
   nop
_  ;; DEBUG HOOK END

   call zwin_putc
   inc hl
zwin_puts.entry:
   ld a,(hl)
   or a,a
   jr nz,zwin_puts.loop
zwin_puts.end:
   ret

zwin_puts_bare:
   jr zwin_puts_bare.entry
zwin_puts_bare.loop:
   call zwin_putc_bare
   inc hl
zwin_puts_bare.entry:
   ld a,(hl)
   or a,a
   jr nz,zwin_puts_bare.loop
zwin_puts_bare.end:
   ret

;; zwin_puts_c -- C wrapper for zwin_puts
;; INPUTS:
;;  arg1 = char *string
;;  arg2 = struct zwin **win
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS: (all)
zwin_puts_c:
   push ix
   push iy
   ld iy,0
   add iy,sp
   ld hl,(iy+9)  ; arg1 -- string
   ld ix,(iy+12) ; arg2 -- context
   ld ix,(ix)   ; window
   push iy
   ld iy,flags
   call zwin_puts
   pop iy
   ld sp,iy
   pop iy
   pop ix
   ret

;; zwin_putsn -- put string in window, buffered, n bytes
;; zwin_putsn_bare -- put string in window, unbuffered, n bytes
;; INPUTS:
;;  ix = pointer to window struct
;;  hl = pointer to string
;;  bc = length of string
;; OUTPUTS: (none)
;; ERRORS: no.
;; DESTROYS:
zwin_putsn_bare:
   ld de,0
   jr zwin_putsn_bare.entry
zwin_putsn_bare.loop:
   call zwin_putc_bare
   inc hl
   dec bc
zwin_putsn_bare.entry:
   ex de,hl
   or a,a
   sbc hl,bc
   add hl,bc
   ret z ; reached end of string
   ex de,hl
   ld a,(hl)
   or a,a
   jr nz,zwin_putsn_bare.loop
zwin_putsn_bare.done:
   ret


;; zwin_setcur -- set cursor in window
;; INPUTS:
;;  ix = pointer to window struct
;;  hl = col, relative to window origin
;;  a = row, relative to window origin
;; OUTPUTS: (none)
;; DESTROYS: (none)
;; ERRORS: no.
;; NOTE: doesn't check if given row and col are within bounds of window.
zwin_setcur:
   push de
   ld de,(ix+ZWIN.ORGCOL)
   add hl,de
   ld (ix+ZWIN.CURCOL),hl
   add a,(ix+ZWIN.CURROW)
   ld (ix+ZWIN.CURROW),a
   pop de
   ret

;; zwin_split_top -- split off window from top of base window
;; zwin_split_bottom -- split off window from bottom of base window
;; INPUTS:
;;  ix = base window
;;  iy = new window
;;  a = width / height of new window
;;  b = flags of new window
;; OUTPUTS: (none)
;; DESTROYS: a, hl, de, bc
;; ERRORS: no.
;; NOTES:
;;  Both cursors reset to origin.
;;  Doesn't modify buffer of either window.
zwin_split_top:
   ld c,1
   jr zwin_split_vert.base

zwin_split_bottom:
   ld c,0
   jr zwin_split_vert.base

; b contains new height
zwin_split_vert.org_top:
   ld a,(ix+ZWIN.ORGROW)
   ld (iy+ZWIN.ORGROW),a
   add a,(iy+ZWIN.HEIGHT)
   ld (ix+ZWIN.ORGROW),a
   jr zwin_split_vert.cont
   
zwin_split_vert.org_bottom:
   ld a,(ix+ZWIN.ORGROW)
   add a,(ix+ZWIN.HEIGHT)
   ld (iy+ZWIN.ORGROW),a
   jr zwin_split_vert.cont
   
zwin_split_vert.base:
   ; copy unchanged fields
   ld hl,(ix+ZWIN.ORGCOL)
   ld (iy+ZWIN.ORGCOL),hl
   ld hl,(ix+ZWIN.WIDTH)
   ld (iy+ZWIN.WIDTH),hl
   ; set flags
   ld (iy+ZWIN.FLAGS),b
   ; update heights
   ld (iy+ZWIN.HEIGHT),a
   sub a,(ix+ZWIN.HEIGHT)
   neg
   ld (ix+ZWIN.HEIGHT),a
   ; update org rows
   xor a,a
   cp a,c
   jr c,zwin_split_vert.org_top
   jr zwin_split_vert.org_bottom
zwin_split_vert.cont:
   ; reset main window to org
   call zwin_org
   push iy
   ex (sp),ix ; now iy <- ix
   ; reset and clear new window
   call zwin_org
   call zwin_clear
   ex (sp),ix
   pop iy
   ret


;; zwin_split_left -- split off window from left of base window
;; zwin_split_right -- split off window from right of base window
;; INPUTS:
;;  ix = base window
;;  iy = new window
;;  hl = width of new window
;;  b = flags of new window
;; OUTPUTS: (none)
;; DESTROYS: a, hl, de, bc
;; ERRORS: no.
;; NOTES:
;;  Both cursors reset to origin.
;;  Doesn't modify buffer of either window.
zwin_split_left:
   ld c,0
   jr zwin_split_horiz.base

zwin_split_right:
   ld c,1
   jr zwin_split_horiz.base

zwin_split_horiz.base:
   ; update window widths
   ld (iy+ZWIN.WIDTH),hl
   ld de,(ix+ZWIN.WIDTH)
   or a,a
   ex de,hl
   sbc hl,de
   ld (ix+ZWIN.WIDTH),hl
   ; save flags
   ld (iy+ZWIN.FLAGS),b
   ; copy unchanged fields
   ld a,(ix+ZWIN.ORGROW)
   ld (iy+ZWIN.ORGROW),a
   ld a,(ix+ZWIN.HEIGHT)
   ld (iy+ZWIN.HEIGHT),a
   ; update orgcols
   xor a,a
   cp a,c
   jr nc,zwin_split_horiz.org_left
   jr zwin_split_horiz.org_right
zwin_split_horiz.cont:
   call zwin_org
   push iy
   ex (sp),ix
   call zwin_org
   ex (sp),ix
   pop iy
   ret

zwin_split_horiz.org_left:
   ld hl,(ix+ZWIN.ORGCOL)
   ld (iy+ZWIN.ORGCOL),hl
   ld de,(iy+ZWIN.WIDTH)
   add hl,de
   ld (ix+ZWIN.ORGCOL),hl
   jr zwin_split_horiz.cont

zwin_split_horiz.org_right:
   ld hl,(ix+ZWIN.ORGCOL)
   ld de,(ix+ZWIN.WIDTH)
   add hl,de
   ld (iy+ZWIN.ORGCOL),hl
   jr zwin_split_horiz.cont

;; zwin_getc -- get input character, buffered
;; zwin_getc_bare -- get input char, unbuffered
;; INPUTS:
;;  ix = pointer to window struct
;; OUTPUTS:
;;  a = char
;; ERRORS: no.
;; DESTROYS: all but a, ix
zwin_getc:
   call _GetKey
   call ktoch
   jp zwin_putc
   
zwin_getc_bare:
   call _GetKey
   jp ktoch


;; zwin_getsn -- get input string
;; INPUTS:
;;  hl = pointer to buffer
;;  ix = pointer to window struct
;;  bc = number of bytes
;; OUTPUTS:
;;  hl = pointer to buffer
;;  bc = number of bytes written (including possible null byte)
;; ERRORS: no.
;; DESTROYS: all but hl
;; NOTE: No null-byte written if number of bytes written = number requested.
zwin_getsn:
   push hl
   push bc
   jr zwin_getsn.entry   
zwin_getsn.loop:
   push hl \ push bc
   call zwin_getc_bare ; preserves a
   pop bc \ pop hl
   or a,a ; check for null term
   jr z,zwin_getsn.done

   pop de \ push de
   call zwin_getsn.handle

   jr c,zwin_getsn.done

zwin_getsn.entry:
   ld de,0
   ex de,hl
   or a,a
   sbc hl,bc
   ex de,hl
   ; continue if count > 0
   jr nz,zwin_getsn.loop
zwin_getsn.done:
   pop hl
   or a,a
   sbc hl,bc
   push hl \ pop bc
   pop hl
   ret

;; handle character
;; assumes there is space in the buffer
zwin_getsn.handle:
   push hl \ push bc
   call zwin_putc ; only OK if this window isn't being shared
   pop bc \ pop hl
   call isprint   
   jr nc,zwin_getsn.special
zwin_getsn.print:
   ; is print
   ld (hl),a
   inc hl
   dec bc
   ; check if newline
   cp a,ASCII_NEWLINE
   ccf
   ret
   
zwin_getsn.special:
   cp a,ASCII_DEL
   jr z,zwin_getsn.del
   cp a,ASCII_CLEAR
   jr z,zwin_getsn.clear
   or a,a
   ret ; do nothing

zwin_getsn.del:
   ; make sure to not underflow the buffer
   ; expects de = full count
   ex de,hl
   or a,a
   sbc hl,bc
   ex de,hl
   ret z ; nothing to delete
   dec hl ; delete one char
   inc bc
   or a,a
   ret

zwin_getsn.clear:
   ; reset buffer pointer to start
   push de ; full count
   ex de,hl
   or a,a
   sbc hl,bc
   ex de,hl
   or a,a
   sbc hl,de ; hl now at beginning
   pop bc ; new count
   or a,a
   ret

